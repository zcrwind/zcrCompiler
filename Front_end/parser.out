Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    LLAVEI
    LLAVED
    MOD
    RETURN
    CHAR
    STRING
    USES
    CONST

Grammar

Rule 0     S' -> ProgDef
Rule 1     ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT
Rule 2     SubProg -> VarDef function_definition compound_statement
Rule 3     VarDef -> VAR VarDefList SEMICOLON
Rule 4     VarDefList -> VarDefList SEMICOLON VarDefState
Rule 5     VarDefList -> VarDefState
Rule 6     VarDefState -> VarList COLON Type
Rule 7     VarDefState -> ArrayDefState
Rule 8     VarList -> VarList COMMA Variable
Rule 9     VarList -> Variable
Rule 10    ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
Rule 11    arrayName -> ID
Rule 12    index_list -> index_list COMMA index
Rule 13    index_list -> index
Rule 14    index -> startIndex DOTDOT endIndex
Rule 15    Type -> INTEGER
Rule 16    Type -> REAL
Rule 17    Type -> BOOLEAN
Rule 18    Type -> arrayName
Rule 19    Variable -> ID
Rule 20    startIndex -> const
Rule 21    endIndex -> const
Rule 22    StateList -> StateList SEMICOLON Statement
Rule 23    StateList -> Statement
Rule 24    Statement -> open_statement
Rule 25    Statement -> closed_statement
Rule 26    open_statement -> label COLON non_labeled_open_statement
Rule 27    open_statement -> non_labeled_open_statement
Rule 28    closed_statement -> label COLON non_labeled_closed_statement
Rule 29    closed_statement -> non_labeled_closed_statement
Rule 30    non_labeled_open_statement -> open_if_statement
Rule 31    non_labeled_open_statement -> open_while_statement
Rule 32    non_labeled_open_statement -> open_for_statement
Rule 33    non_labeled_closed_statement -> assignment_statement
Rule 34    non_labeled_closed_statement -> compound_statement
Rule 35    non_labeled_closed_statement -> closed_if_statement
Rule 36    non_labeled_closed_statement -> closed_while_statement
Rule 37    non_labeled_closed_statement -> closed_for_statement
Rule 38    non_labeled_closed_statement -> goto_statement
Rule 39    non_labeled_closed_statement -> empty
Rule 40    non_labeled_closed_statement -> case_statement
Rule 41    non_labeled_closed_statement -> continue_statement
Rule 42    continue_statement -> CONTINUE
Rule 43    non_labeled_closed_statement -> break_statement
Rule 44    break_statement -> BREAK
Rule 45    case_statement -> CASE case_index OF case_element_list END
Rule 46    case_statement -> CASE case_index OF case_element_list SEMICOLON END
Rule 47    case_index -> Expr
Rule 48    case_element_list -> case_element_list SEMICOLON case_element
Rule 49    case_element_list -> case_element
Rule 50    case_element -> case_constant COLON Statement
Rule 51    case_constant -> const
Rule 52    open_if_statement -> IF BoolExpr THEN Statement
Rule 53    open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement
Rule 54    closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement
Rule 55    open_while_statement -> WHILE BoolExpr DO open_statement
Rule 56    closed_while_statement -> WHILE BoolExpr DO closed_statement
Rule 57    open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
Rule 58    closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
Rule 59    initial_value -> Expr
Rule 60    final_value -> Expr
Rule 61    direction -> TO
Rule 62    direction -> DOWNTO
Rule 63    assignment_statement -> Variable ASSIGNMENT Expr
Rule 64    compound_statement -> BEGIN StateList END
Rule 65    goto_statement -> GOTO label
Rule 66    label -> DIGSEQ
Rule 67    Expr -> Expr PLUS Expr
Rule 68    Expr -> Expr MINUS Expr
Rule 69    Expr -> Expr TIMES Expr
Rule 70    Expr -> Expr DIVIDE Expr
Rule 71    Expr -> LPAREN Expr RPAREN
Rule 72    Expr -> MINUS Expr
Rule 73    Expr -> Variable
Rule 74    Expr -> const
Rule 75    const -> INT_NUMBER
Rule 76    const -> REAL_NUMBER
Rule 77    BoolExpr -> Expr LT Expr
Rule 78    BoolExpr -> Expr LE Expr
Rule 79    BoolExpr -> Expr GT Expr
Rule 80    BoolExpr -> Expr GE Expr
Rule 81    BoolExpr -> Expr EQ Expr
Rule 82    BoolExpr -> Expr NE Expr
Rule 83    BoolExpr -> BoolExpr AND BoolExpr
Rule 84    BoolExpr -> BoolExpr OR BoolExpr
Rule 85    BoolExpr -> NOT BoolExpr
Rule 86    BoolExpr -> LPAREN BoolExpr RPAREN
Rule 87    BoolExpr -> Expr
Rule 88    empty -> <empty>
Rule 89    function_definition -> function_heading SEMICOLON function_block
Rule 90    function_definition -> empty
Rule 91    function_heading -> FUNCTION funcName COLON return_type
Rule 92    function_heading -> FUNCTION funcName parameter_list COLON return_type
Rule 93    parameter_list -> LPAREN VarDefList RPAREN
Rule 94    funcName -> ID
Rule 95    return_type -> Type
Rule 96    function_block -> compound_statement

Terminals, with rules where they appear

AND                  : 83
ARRAY                : 10
ASSIGNMENT           : 57 58 63
BEGIN                : 64
BOOLEAN              : 17
BREAK                : 44
CASE                 : 45 46
CHAR                 : 
COLON                : 6 26 28 50 91 92
COMMA                : 8 12
CONST                : 
CONTINUE             : 42
DIGSEQ               : 66
DIVIDE               : 70
DO                   : 55 56 57 58
DOTDOT               : 14
DOWNTO               : 62
ELSE                 : 53 54
END                  : 45 46 64
ENDPOINT             : 1
EQ                   : 10 81
FOR                  : 57 58
FUNCTION             : 91 92
GE                   : 80
GOTO                 : 65
GT                   : 79
ID                   : 1 11 19 94
IF                   : 52 53 54
INTEGER              : 15
INT_NUMBER           : 75
LBRAC                : 10
LE                   : 78
LLAVED               : 
LLAVEI               : 
LPAREN               : 71 86 93
LT                   : 77
MINUS                : 68 72
MOD                  : 
NE                   : 82
NOT                  : 85
OF                   : 10 45 46
OR                   : 84
PLUS                 : 67
PROGRAM              : 1
RBRAC                : 10
REAL                 : 16
REAL_NUMBER          : 76
RETURN               : 
RPAREN               : 71 86 93
SEMICOLON            : 1 3 4 22 46 48 89
STRING               : 
THEN                 : 52 53 54
TIMES                : 69
TO                   : 61
TYPE                 : 10
USES                 : 
VAR                  : 3
WHILE                : 55 56
error                : 

Nonterminals, with rules where they appear

ArrayDefState        : 7
BoolExpr             : 52 53 54 55 56 83 83 84 84 85 86
Expr                 : 47 59 60 63 67 67 68 68 69 69 70 70 71 72 77 77 78 78 79 79 80 80 81 81 82 82 87
ProgDef              : 0
StateList            : 22 64
Statement            : 22 23 50 52
SubProg              : 1
Type                 : 6 10 95
VarDef               : 2
VarDefList           : 3 4 93
VarDefState          : 4 5
VarList              : 6 8
Variable             : 8 9 57 58 63 73
arrayName            : 10 18
assignment_statement : 33
break_statement      : 43
case_constant        : 50
case_element         : 48 49
case_element_list    : 45 46 48
case_index           : 45 46
case_statement       : 40
closed_for_statement : 37
closed_if_statement  : 35
closed_statement     : 25 53 54 54 56 58
closed_while_statement : 36
compound_statement   : 2 34 96
const                : 20 21 51 74
continue_statement   : 41
direction            : 57 58
empty                : 39 90
endIndex             : 14
final_value          : 57 58
funcName             : 91 92
function_block       : 89
function_definition  : 2
function_heading     : 89
goto_statement       : 38
index                : 12 13
index_list           : 10 12
initial_value        : 57 58
label                : 26 28 65
non_labeled_closed_statement : 28 29
non_labeled_open_statement : 26 27
open_for_statement   : 32
open_if_statement    : 30
open_statement       : 24 53 55 57
open_while_statement : 31
parameter_list       : 92
return_type          : 91 92
startIndex           : 14

Parsing method: LALR

state 0

    (0) S' -> . ProgDef
    (1) ProgDef -> . PROGRAM ID SEMICOLON SubProg ENDPOINT

    PROGRAM         shift and go to state 2

    ProgDef                        shift and go to state 1

state 1

    (0) S' -> ProgDef .



state 2

    (1) ProgDef -> PROGRAM . ID SEMICOLON SubProg ENDPOINT

    ID              shift and go to state 3


state 3

    (1) ProgDef -> PROGRAM ID . SEMICOLON SubProg ENDPOINT

    SEMICOLON       shift and go to state 4


state 4

    (1) ProgDef -> PROGRAM ID SEMICOLON . SubProg ENDPOINT
    (2) SubProg -> . VarDef function_definition compound_statement
    (3) VarDef -> . VAR VarDefList SEMICOLON

    VAR             shift and go to state 7

    SubProg                        shift and go to state 5
    VarDef                         shift and go to state 6

state 5

    (1) ProgDef -> PROGRAM ID SEMICOLON SubProg . ENDPOINT

    ENDPOINT        shift and go to state 8


state 6

    (2) SubProg -> VarDef . function_definition compound_statement
    (89) function_definition -> . function_heading SEMICOLON function_block
    (90) function_definition -> . empty
    (91) function_heading -> . FUNCTION funcName COLON return_type
    (92) function_heading -> . FUNCTION funcName parameter_list COLON return_type
    (88) empty -> .

    FUNCTION        shift and go to state 12
    BEGIN           reduce using rule 88 (empty -> .)

    function_definition            shift and go to state 9
    function_heading               shift and go to state 10
    empty                          shift and go to state 11

state 7

    (3) VarDef -> VAR . VarDefList SEMICOLON
    (4) VarDefList -> . VarDefList SEMICOLON VarDefState
    (5) VarDefList -> . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    TYPE            shift and go to state 18
    ID              shift and go to state 19

    VarDefList                     shift and go to state 13
    VarDefState                    shift and go to state 14
    VarList                        shift and go to state 15
    ArrayDefState                  shift and go to state 16
    Variable                       shift and go to state 17

state 8

    (1) ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT .

    $end            reduce using rule 1 (ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT .)


state 9

    (2) SubProg -> VarDef function_definition . compound_statement
    (64) compound_statement -> . BEGIN StateList END

    BEGIN           shift and go to state 21

    compound_statement             shift and go to state 20

state 10

    (89) function_definition -> function_heading . SEMICOLON function_block

    SEMICOLON       shift and go to state 22


state 11

    (90) function_definition -> empty .

    BEGIN           reduce using rule 90 (function_definition -> empty .)


state 12

    (91) function_heading -> FUNCTION . funcName COLON return_type
    (92) function_heading -> FUNCTION . funcName parameter_list COLON return_type
    (94) funcName -> . ID

    ID              shift and go to state 24

    funcName                       shift and go to state 23

state 13

    (3) VarDef -> VAR VarDefList . SEMICOLON
    (4) VarDefList -> VarDefList . SEMICOLON VarDefState

    SEMICOLON       shift and go to state 25


state 14

    (5) VarDefList -> VarDefState .

    SEMICOLON       reduce using rule 5 (VarDefList -> VarDefState .)
    RPAREN          reduce using rule 5 (VarDefList -> VarDefState .)


state 15

    (6) VarDefState -> VarList . COLON Type
    (8) VarList -> VarList . COMMA Variable

    COLON           shift and go to state 26
    COMMA           shift and go to state 27


state 16

    (7) VarDefState -> ArrayDefState .

    SEMICOLON       reduce using rule 7 (VarDefState -> ArrayDefState .)
    RPAREN          reduce using rule 7 (VarDefState -> ArrayDefState .)


state 17

    (9) VarList -> Variable .

    COLON           reduce using rule 9 (VarList -> Variable .)
    COMMA           reduce using rule 9 (VarList -> Variable .)


state 18

    (10) ArrayDefState -> TYPE . arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (11) arrayName -> . ID

    ID              shift and go to state 29

    arrayName                      shift and go to state 28

state 19

    (19) Variable -> ID .

    COLON           reduce using rule 19 (Variable -> ID .)
    COMMA           reduce using rule 19 (Variable -> ID .)
    ASSIGNMENT      reduce using rule 19 (Variable -> ID .)
    LT              reduce using rule 19 (Variable -> ID .)
    LE              reduce using rule 19 (Variable -> ID .)
    GT              reduce using rule 19 (Variable -> ID .)
    GE              reduce using rule 19 (Variable -> ID .)
    EQ              reduce using rule 19 (Variable -> ID .)
    NE              reduce using rule 19 (Variable -> ID .)
    PLUS            reduce using rule 19 (Variable -> ID .)
    MINUS           reduce using rule 19 (Variable -> ID .)
    TIMES           reduce using rule 19 (Variable -> ID .)
    DIVIDE          reduce using rule 19 (Variable -> ID .)
    THEN            reduce using rule 19 (Variable -> ID .)
    AND             reduce using rule 19 (Variable -> ID .)
    OR              reduce using rule 19 (Variable -> ID .)
    DO              reduce using rule 19 (Variable -> ID .)
    OF              reduce using rule 19 (Variable -> ID .)
    RPAREN          reduce using rule 19 (Variable -> ID .)
    END             reduce using rule 19 (Variable -> ID .)
    SEMICOLON       reduce using rule 19 (Variable -> ID .)
    ELSE            reduce using rule 19 (Variable -> ID .)
    TO              reduce using rule 19 (Variable -> ID .)
    DOWNTO          reduce using rule 19 (Variable -> ID .)


state 20

    (2) SubProg -> VarDef function_definition compound_statement .

    ENDPOINT        reduce using rule 2 (SubProg -> VarDef function_definition compound_statement .)


state 21

    (64) compound_statement -> BEGIN . StateList END
    (22) StateList -> . StateList SEMICOLON Statement
    (23) StateList -> . Statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (66) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    FOR             shift and go to state 53
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 55
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    StateList                      shift and go to state 30
    Statement                      shift and go to state 31
    open_statement                 shift and go to state 32
    closed_statement               shift and go to state 33
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    Variable                       shift and go to state 54

state 22

    (89) function_definition -> function_heading SEMICOLON . function_block
    (96) function_block -> . compound_statement
    (64) compound_statement -> . BEGIN StateList END

    BEGIN           shift and go to state 21

    function_block                 shift and go to state 59
    compound_statement             shift and go to state 60

state 23

    (91) function_heading -> FUNCTION funcName . COLON return_type
    (92) function_heading -> FUNCTION funcName . parameter_list COLON return_type
    (93) parameter_list -> . LPAREN VarDefList RPAREN

    COLON           shift and go to state 61
    LPAREN          shift and go to state 63

    parameter_list                 shift and go to state 62

state 24

    (94) funcName -> ID .

    COLON           reduce using rule 94 (funcName -> ID .)
    LPAREN          reduce using rule 94 (funcName -> ID .)


state 25

    (3) VarDef -> VAR VarDefList SEMICOLON .
    (4) VarDefList -> VarDefList SEMICOLON . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    FUNCTION        reduce using rule 3 (VarDef -> VAR VarDefList SEMICOLON .)
    BEGIN           reduce using rule 3 (VarDef -> VAR VarDefList SEMICOLON .)
    TYPE            shift and go to state 18
    ID              shift and go to state 19

    VarDefState                    shift and go to state 64
    VarList                        shift and go to state 15
    ArrayDefState                  shift and go to state 16
    Variable                       shift and go to state 17

state 26

    (6) VarDefState -> VarList COLON . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 66
    REAL            shift and go to state 67
    BOOLEAN         shift and go to state 68
    ID              shift and go to state 29

    Type                           shift and go to state 65
    arrayName                      shift and go to state 69

state 27

    (8) VarList -> VarList COMMA . Variable
    (19) Variable -> . ID

    ID              shift and go to state 19

    Variable                       shift and go to state 70

state 28

    (10) ArrayDefState -> TYPE arrayName . EQ ARRAY LBRAC index_list RBRAC OF Type

    EQ              shift and go to state 71


state 29

    (11) arrayName -> ID .

    EQ              reduce using rule 11 (arrayName -> ID .)
    SEMICOLON       reduce using rule 11 (arrayName -> ID .)
    RPAREN          reduce using rule 11 (arrayName -> ID .)


state 30

    (64) compound_statement -> BEGIN StateList . END
    (22) StateList -> StateList . SEMICOLON Statement

    END             shift and go to state 72
    SEMICOLON       shift and go to state 73


state 31

    (23) StateList -> Statement .

    END             reduce using rule 23 (StateList -> Statement .)
    SEMICOLON       reduce using rule 23 (StateList -> Statement .)


state 32

    (24) Statement -> open_statement .

    END             reduce using rule 24 (Statement -> open_statement .)
    SEMICOLON       reduce using rule 24 (Statement -> open_statement .)


state 33

    (25) Statement -> closed_statement .

    END             reduce using rule 25 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 25 (Statement -> closed_statement .)


state 34

    (26) open_statement -> label . COLON non_labeled_open_statement
    (28) closed_statement -> label . COLON non_labeled_closed_statement

    COLON           shift and go to state 74


state 35

    (27) open_statement -> non_labeled_open_statement .

    END             reduce using rule 27 (open_statement -> non_labeled_open_statement .)
    SEMICOLON       reduce using rule 27 (open_statement -> non_labeled_open_statement .)


state 36

    (29) closed_statement -> non_labeled_closed_statement .

    END             reduce using rule 29 (closed_statement -> non_labeled_closed_statement .)
    SEMICOLON       reduce using rule 29 (closed_statement -> non_labeled_closed_statement .)
    ELSE            reduce using rule 29 (closed_statement -> non_labeled_closed_statement .)


state 37

    (66) label -> DIGSEQ .

    COLON           reduce using rule 66 (label -> DIGSEQ .)
    END             reduce using rule 66 (label -> DIGSEQ .)
    SEMICOLON       reduce using rule 66 (label -> DIGSEQ .)
    ELSE            reduce using rule 66 (label -> DIGSEQ .)


state 38

    (30) non_labeled_open_statement -> open_if_statement .

    END             reduce using rule 30 (non_labeled_open_statement -> open_if_statement .)
    SEMICOLON       reduce using rule 30 (non_labeled_open_statement -> open_if_statement .)


state 39

    (31) non_labeled_open_statement -> open_while_statement .

    END             reduce using rule 31 (non_labeled_open_statement -> open_while_statement .)
    SEMICOLON       reduce using rule 31 (non_labeled_open_statement -> open_while_statement .)


state 40

    (32) non_labeled_open_statement -> open_for_statement .

    END             reduce using rule 32 (non_labeled_open_statement -> open_for_statement .)
    SEMICOLON       reduce using rule 32 (non_labeled_open_statement -> open_for_statement .)


state 41

    (33) non_labeled_closed_statement -> assignment_statement .

    END             reduce using rule 33 (non_labeled_closed_statement -> assignment_statement .)
    SEMICOLON       reduce using rule 33 (non_labeled_closed_statement -> assignment_statement .)
    ELSE            reduce using rule 33 (non_labeled_closed_statement -> assignment_statement .)


state 42

    (34) non_labeled_closed_statement -> compound_statement .

    END             reduce using rule 34 (non_labeled_closed_statement -> compound_statement .)
    SEMICOLON       reduce using rule 34 (non_labeled_closed_statement -> compound_statement .)
    ELSE            reduce using rule 34 (non_labeled_closed_statement -> compound_statement .)


state 43

    (35) non_labeled_closed_statement -> closed_if_statement .

    END             reduce using rule 35 (non_labeled_closed_statement -> closed_if_statement .)
    SEMICOLON       reduce using rule 35 (non_labeled_closed_statement -> closed_if_statement .)
    ELSE            reduce using rule 35 (non_labeled_closed_statement -> closed_if_statement .)


state 44

    (36) non_labeled_closed_statement -> closed_while_statement .

    END             reduce using rule 36 (non_labeled_closed_statement -> closed_while_statement .)
    SEMICOLON       reduce using rule 36 (non_labeled_closed_statement -> closed_while_statement .)
    ELSE            reduce using rule 36 (non_labeled_closed_statement -> closed_while_statement .)


state 45

    (37) non_labeled_closed_statement -> closed_for_statement .

    END             reduce using rule 37 (non_labeled_closed_statement -> closed_for_statement .)
    SEMICOLON       reduce using rule 37 (non_labeled_closed_statement -> closed_for_statement .)
    ELSE            reduce using rule 37 (non_labeled_closed_statement -> closed_for_statement .)


state 46

    (38) non_labeled_closed_statement -> goto_statement .

    END             reduce using rule 38 (non_labeled_closed_statement -> goto_statement .)
    SEMICOLON       reduce using rule 38 (non_labeled_closed_statement -> goto_statement .)
    ELSE            reduce using rule 38 (non_labeled_closed_statement -> goto_statement .)


state 47

    (39) non_labeled_closed_statement -> empty .

    END             reduce using rule 39 (non_labeled_closed_statement -> empty .)
    SEMICOLON       reduce using rule 39 (non_labeled_closed_statement -> empty .)
    ELSE            reduce using rule 39 (non_labeled_closed_statement -> empty .)


state 48

    (40) non_labeled_closed_statement -> case_statement .

    END             reduce using rule 40 (non_labeled_closed_statement -> case_statement .)
    SEMICOLON       reduce using rule 40 (non_labeled_closed_statement -> case_statement .)
    ELSE            reduce using rule 40 (non_labeled_closed_statement -> case_statement .)


state 49

    (41) non_labeled_closed_statement -> continue_statement .

    END             reduce using rule 41 (non_labeled_closed_statement -> continue_statement .)
    SEMICOLON       reduce using rule 41 (non_labeled_closed_statement -> continue_statement .)
    ELSE            reduce using rule 41 (non_labeled_closed_statement -> continue_statement .)


state 50

    (43) non_labeled_closed_statement -> break_statement .

    END             reduce using rule 43 (non_labeled_closed_statement -> break_statement .)
    SEMICOLON       reduce using rule 43 (non_labeled_closed_statement -> break_statement .)
    ELSE            reduce using rule 43 (non_labeled_closed_statement -> break_statement .)


state 51

    (52) open_if_statement -> IF . BoolExpr THEN Statement
    (53) open_if_statement -> IF . BoolExpr THEN closed_statement ELSE open_statement
    (54) closed_if_statement -> IF . BoolExpr THEN closed_statement ELSE closed_statement
    (77) BoolExpr -> . Expr LT Expr
    (78) BoolExpr -> . Expr LE Expr
    (79) BoolExpr -> . Expr GT Expr
    (80) BoolExpr -> . Expr GE Expr
    (81) BoolExpr -> . Expr EQ Expr
    (82) BoolExpr -> . Expr NE Expr
    (83) BoolExpr -> . BoolExpr AND BoolExpr
    (84) BoolExpr -> . BoolExpr OR BoolExpr
    (85) BoolExpr -> . NOT BoolExpr
    (86) BoolExpr -> . LPAREN BoolExpr RPAREN
    (87) BoolExpr -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    NOT             shift and go to state 77
    LPAREN          shift and go to state 78
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    BoolExpr                       shift and go to state 75
    Expr                           shift and go to state 76
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 52

    (55) open_while_statement -> WHILE . BoolExpr DO open_statement
    (56) closed_while_statement -> WHILE . BoolExpr DO closed_statement
    (77) BoolExpr -> . Expr LT Expr
    (78) BoolExpr -> . Expr LE Expr
    (79) BoolExpr -> . Expr GT Expr
    (80) BoolExpr -> . Expr GE Expr
    (81) BoolExpr -> . Expr EQ Expr
    (82) BoolExpr -> . Expr NE Expr
    (83) BoolExpr -> . BoolExpr AND BoolExpr
    (84) BoolExpr -> . BoolExpr OR BoolExpr
    (85) BoolExpr -> . NOT BoolExpr
    (86) BoolExpr -> . LPAREN BoolExpr RPAREN
    (87) BoolExpr -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    NOT             shift and go to state 77
    LPAREN          shift and go to state 78
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    BoolExpr                       shift and go to state 84
    Expr                           shift and go to state 76
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 53

    (57) open_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (58) closed_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (19) Variable -> . ID

    ID              shift and go to state 19

    Variable                       shift and go to state 85

state 54

    (63) assignment_statement -> Variable . ASSIGNMENT Expr

    ASSIGNMENT      shift and go to state 86


state 55

    (65) goto_statement -> GOTO . label
    (66) label -> . DIGSEQ

    DIGSEQ          shift and go to state 37

    label                          shift and go to state 87

state 56

    (45) case_statement -> CASE . case_index OF case_element_list END
    (46) case_statement -> CASE . case_index OF case_element_list SEMICOLON END
    (47) case_index -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    case_index                     shift and go to state 88
    Expr                           shift and go to state 89
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 57

    (42) continue_statement -> CONTINUE .

    END             reduce using rule 42 (continue_statement -> CONTINUE .)
    SEMICOLON       reduce using rule 42 (continue_statement -> CONTINUE .)
    ELSE            reduce using rule 42 (continue_statement -> CONTINUE .)


state 58

    (44) break_statement -> BREAK .

    END             reduce using rule 44 (break_statement -> BREAK .)
    SEMICOLON       reduce using rule 44 (break_statement -> BREAK .)
    ELSE            reduce using rule 44 (break_statement -> BREAK .)


state 59

    (89) function_definition -> function_heading SEMICOLON function_block .

    BEGIN           reduce using rule 89 (function_definition -> function_heading SEMICOLON function_block .)


state 60

    (96) function_block -> compound_statement .

    BEGIN           reduce using rule 96 (function_block -> compound_statement .)


state 61

    (91) function_heading -> FUNCTION funcName COLON . return_type
    (95) return_type -> . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 66
    REAL            shift and go to state 67
    BOOLEAN         shift and go to state 68
    ID              shift and go to state 29

    return_type                    shift and go to state 91
    Type                           shift and go to state 92
    arrayName                      shift and go to state 69

state 62

    (92) function_heading -> FUNCTION funcName parameter_list . COLON return_type

    COLON           shift and go to state 93


state 63

    (93) parameter_list -> LPAREN . VarDefList RPAREN
    (4) VarDefList -> . VarDefList SEMICOLON VarDefState
    (5) VarDefList -> . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    TYPE            shift and go to state 18
    ID              shift and go to state 19

    VarDefList                     shift and go to state 94
    VarDefState                    shift and go to state 14
    VarList                        shift and go to state 15
    ArrayDefState                  shift and go to state 16
    Variable                       shift and go to state 17

state 64

    (4) VarDefList -> VarDefList SEMICOLON VarDefState .

    SEMICOLON       reduce using rule 4 (VarDefList -> VarDefList SEMICOLON VarDefState .)
    RPAREN          reduce using rule 4 (VarDefList -> VarDefList SEMICOLON VarDefState .)


state 65

    (6) VarDefState -> VarList COLON Type .

    SEMICOLON       reduce using rule 6 (VarDefState -> VarList COLON Type .)
    RPAREN          reduce using rule 6 (VarDefState -> VarList COLON Type .)


state 66

    (15) Type -> INTEGER .

    SEMICOLON       reduce using rule 15 (Type -> INTEGER .)
    RPAREN          reduce using rule 15 (Type -> INTEGER .)


state 67

    (16) Type -> REAL .

    SEMICOLON       reduce using rule 16 (Type -> REAL .)
    RPAREN          reduce using rule 16 (Type -> REAL .)


state 68

    (17) Type -> BOOLEAN .

    SEMICOLON       reduce using rule 17 (Type -> BOOLEAN .)
    RPAREN          reduce using rule 17 (Type -> BOOLEAN .)


state 69

    (18) Type -> arrayName .

    SEMICOLON       reduce using rule 18 (Type -> arrayName .)
    RPAREN          reduce using rule 18 (Type -> arrayName .)


state 70

    (8) VarList -> VarList COMMA Variable .

    COLON           reduce using rule 8 (VarList -> VarList COMMA Variable .)
    COMMA           reduce using rule 8 (VarList -> VarList COMMA Variable .)


state 71

    (10) ArrayDefState -> TYPE arrayName EQ . ARRAY LBRAC index_list RBRAC OF Type

    ARRAY           shift and go to state 95


state 72

    (64) compound_statement -> BEGIN StateList END .

    ENDPOINT        reduce using rule 64 (compound_statement -> BEGIN StateList END .)
    END             reduce using rule 64 (compound_statement -> BEGIN StateList END .)
    SEMICOLON       reduce using rule 64 (compound_statement -> BEGIN StateList END .)
    BEGIN           reduce using rule 64 (compound_statement -> BEGIN StateList END .)
    ELSE            reduce using rule 64 (compound_statement -> BEGIN StateList END .)


state 73

    (22) StateList -> StateList SEMICOLON . Statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (66) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    FOR             shift and go to state 53
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 55
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    Statement                      shift and go to state 96
    open_statement                 shift and go to state 32
    closed_statement               shift and go to state 33
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    Variable                       shift and go to state 54

state 74

    (26) open_statement -> label COLON . non_labeled_open_statement
    (28) closed_statement -> label COLON . non_labeled_closed_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (19) Variable -> . ID

    IF              shift and go to state 51
    WHILE           shift and go to state 52
    FOR             shift and go to state 53
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 55
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    ELSE            reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    non_labeled_open_statement     shift and go to state 97
    non_labeled_closed_statement   shift and go to state 98
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    Variable                       shift and go to state 54

state 75

    (52) open_if_statement -> IF BoolExpr . THEN Statement
    (53) open_if_statement -> IF BoolExpr . THEN closed_statement ELSE open_statement
    (54) closed_if_statement -> IF BoolExpr . THEN closed_statement ELSE closed_statement
    (83) BoolExpr -> BoolExpr . AND BoolExpr
    (84) BoolExpr -> BoolExpr . OR BoolExpr

    THEN            shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101


state 76

    (77) BoolExpr -> Expr . LT Expr
    (78) BoolExpr -> Expr . LE Expr
    (79) BoolExpr -> Expr . GT Expr
    (80) BoolExpr -> Expr . GE Expr
    (81) BoolExpr -> Expr . EQ Expr
    (82) BoolExpr -> Expr . NE Expr
    (87) BoolExpr -> Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    LT              shift and go to state 102
    LE              shift and go to state 103
    GT              shift and go to state 104
    GE              shift and go to state 105
    EQ              shift and go to state 106
    NE              shift and go to state 107
    THEN            reduce using rule 87 (BoolExpr -> Expr .)
    AND             reduce using rule 87 (BoolExpr -> Expr .)
    OR              reduce using rule 87 (BoolExpr -> Expr .)
    DO              reduce using rule 87 (BoolExpr -> Expr .)
    RPAREN          reduce using rule 87 (BoolExpr -> Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 77

    (85) BoolExpr -> NOT . BoolExpr
    (77) BoolExpr -> . Expr LT Expr
    (78) BoolExpr -> . Expr LE Expr
    (79) BoolExpr -> . Expr GT Expr
    (80) BoolExpr -> . Expr GE Expr
    (81) BoolExpr -> . Expr EQ Expr
    (82) BoolExpr -> . Expr NE Expr
    (83) BoolExpr -> . BoolExpr AND BoolExpr
    (84) BoolExpr -> . BoolExpr OR BoolExpr
    (85) BoolExpr -> . NOT BoolExpr
    (86) BoolExpr -> . LPAREN BoolExpr RPAREN
    (87) BoolExpr -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    NOT             shift and go to state 77
    LPAREN          shift and go to state 78
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    BoolExpr                       shift and go to state 112
    Expr                           shift and go to state 76
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 78

    (86) BoolExpr -> LPAREN . BoolExpr RPAREN
    (71) Expr -> LPAREN . Expr RPAREN
    (77) BoolExpr -> . Expr LT Expr
    (78) BoolExpr -> . Expr LE Expr
    (79) BoolExpr -> . Expr GT Expr
    (80) BoolExpr -> . Expr GE Expr
    (81) BoolExpr -> . Expr EQ Expr
    (82) BoolExpr -> . Expr NE Expr
    (83) BoolExpr -> . BoolExpr AND BoolExpr
    (84) BoolExpr -> . BoolExpr OR BoolExpr
    (85) BoolExpr -> . NOT BoolExpr
    (86) BoolExpr -> . LPAREN BoolExpr RPAREN
    (87) BoolExpr -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    NOT             shift and go to state 77
    LPAREN          shift and go to state 78
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    BoolExpr                       shift and go to state 113
    Expr                           shift and go to state 114
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 79

    (72) Expr -> MINUS . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 115
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 80

    (73) Expr -> Variable .

    LT              reduce using rule 73 (Expr -> Variable .)
    LE              reduce using rule 73 (Expr -> Variable .)
    GT              reduce using rule 73 (Expr -> Variable .)
    GE              reduce using rule 73 (Expr -> Variable .)
    EQ              reduce using rule 73 (Expr -> Variable .)
    NE              reduce using rule 73 (Expr -> Variable .)
    PLUS            reduce using rule 73 (Expr -> Variable .)
    MINUS           reduce using rule 73 (Expr -> Variable .)
    TIMES           reduce using rule 73 (Expr -> Variable .)
    DIVIDE          reduce using rule 73 (Expr -> Variable .)
    THEN            reduce using rule 73 (Expr -> Variable .)
    AND             reduce using rule 73 (Expr -> Variable .)
    OR              reduce using rule 73 (Expr -> Variable .)
    DO              reduce using rule 73 (Expr -> Variable .)
    OF              reduce using rule 73 (Expr -> Variable .)
    RPAREN          reduce using rule 73 (Expr -> Variable .)
    END             reduce using rule 73 (Expr -> Variable .)
    SEMICOLON       reduce using rule 73 (Expr -> Variable .)
    ELSE            reduce using rule 73 (Expr -> Variable .)
    TO              reduce using rule 73 (Expr -> Variable .)
    DOWNTO          reduce using rule 73 (Expr -> Variable .)


state 81

    (74) Expr -> const .

    LT              reduce using rule 74 (Expr -> const .)
    LE              reduce using rule 74 (Expr -> const .)
    GT              reduce using rule 74 (Expr -> const .)
    GE              reduce using rule 74 (Expr -> const .)
    EQ              reduce using rule 74 (Expr -> const .)
    NE              reduce using rule 74 (Expr -> const .)
    PLUS            reduce using rule 74 (Expr -> const .)
    MINUS           reduce using rule 74 (Expr -> const .)
    TIMES           reduce using rule 74 (Expr -> const .)
    DIVIDE          reduce using rule 74 (Expr -> const .)
    THEN            reduce using rule 74 (Expr -> const .)
    AND             reduce using rule 74 (Expr -> const .)
    OR              reduce using rule 74 (Expr -> const .)
    DO              reduce using rule 74 (Expr -> const .)
    OF              reduce using rule 74 (Expr -> const .)
    RPAREN          reduce using rule 74 (Expr -> const .)
    END             reduce using rule 74 (Expr -> const .)
    SEMICOLON       reduce using rule 74 (Expr -> const .)
    ELSE            reduce using rule 74 (Expr -> const .)
    TO              reduce using rule 74 (Expr -> const .)
    DOWNTO          reduce using rule 74 (Expr -> const .)


state 82

    (75) const -> INT_NUMBER .

    LT              reduce using rule 75 (const -> INT_NUMBER .)
    LE              reduce using rule 75 (const -> INT_NUMBER .)
    GT              reduce using rule 75 (const -> INT_NUMBER .)
    GE              reduce using rule 75 (const -> INT_NUMBER .)
    EQ              reduce using rule 75 (const -> INT_NUMBER .)
    NE              reduce using rule 75 (const -> INT_NUMBER .)
    PLUS            reduce using rule 75 (const -> INT_NUMBER .)
    MINUS           reduce using rule 75 (const -> INT_NUMBER .)
    TIMES           reduce using rule 75 (const -> INT_NUMBER .)
    DIVIDE          reduce using rule 75 (const -> INT_NUMBER .)
    THEN            reduce using rule 75 (const -> INT_NUMBER .)
    AND             reduce using rule 75 (const -> INT_NUMBER .)
    OR              reduce using rule 75 (const -> INT_NUMBER .)
    DO              reduce using rule 75 (const -> INT_NUMBER .)
    OF              reduce using rule 75 (const -> INT_NUMBER .)
    RPAREN          reduce using rule 75 (const -> INT_NUMBER .)
    END             reduce using rule 75 (const -> INT_NUMBER .)
    SEMICOLON       reduce using rule 75 (const -> INT_NUMBER .)
    ELSE            reduce using rule 75 (const -> INT_NUMBER .)
    TO              reduce using rule 75 (const -> INT_NUMBER .)
    DOWNTO          reduce using rule 75 (const -> INT_NUMBER .)
    COLON           reduce using rule 75 (const -> INT_NUMBER .)
    DOTDOT          reduce using rule 75 (const -> INT_NUMBER .)
    RBRAC           reduce using rule 75 (const -> INT_NUMBER .)
    COMMA           reduce using rule 75 (const -> INT_NUMBER .)


state 83

    (76) const -> REAL_NUMBER .

    LT              reduce using rule 76 (const -> REAL_NUMBER .)
    LE              reduce using rule 76 (const -> REAL_NUMBER .)
    GT              reduce using rule 76 (const -> REAL_NUMBER .)
    GE              reduce using rule 76 (const -> REAL_NUMBER .)
    EQ              reduce using rule 76 (const -> REAL_NUMBER .)
    NE              reduce using rule 76 (const -> REAL_NUMBER .)
    PLUS            reduce using rule 76 (const -> REAL_NUMBER .)
    MINUS           reduce using rule 76 (const -> REAL_NUMBER .)
    TIMES           reduce using rule 76 (const -> REAL_NUMBER .)
    DIVIDE          reduce using rule 76 (const -> REAL_NUMBER .)
    THEN            reduce using rule 76 (const -> REAL_NUMBER .)
    AND             reduce using rule 76 (const -> REAL_NUMBER .)
    OR              reduce using rule 76 (const -> REAL_NUMBER .)
    DO              reduce using rule 76 (const -> REAL_NUMBER .)
    OF              reduce using rule 76 (const -> REAL_NUMBER .)
    RPAREN          reduce using rule 76 (const -> REAL_NUMBER .)
    END             reduce using rule 76 (const -> REAL_NUMBER .)
    SEMICOLON       reduce using rule 76 (const -> REAL_NUMBER .)
    ELSE            reduce using rule 76 (const -> REAL_NUMBER .)
    TO              reduce using rule 76 (const -> REAL_NUMBER .)
    DOWNTO          reduce using rule 76 (const -> REAL_NUMBER .)
    COLON           reduce using rule 76 (const -> REAL_NUMBER .)
    DOTDOT          reduce using rule 76 (const -> REAL_NUMBER .)
    RBRAC           reduce using rule 76 (const -> REAL_NUMBER .)
    COMMA           reduce using rule 76 (const -> REAL_NUMBER .)


state 84

    (55) open_while_statement -> WHILE BoolExpr . DO open_statement
    (56) closed_while_statement -> WHILE BoolExpr . DO closed_statement
    (83) BoolExpr -> BoolExpr . AND BoolExpr
    (84) BoolExpr -> BoolExpr . OR BoolExpr

    DO              shift and go to state 116
    AND             shift and go to state 100
    OR              shift and go to state 101


state 85

    (57) open_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO open_statement
    (58) closed_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO closed_statement

    ASSIGNMENT      shift and go to state 117


state 86

    (63) assignment_statement -> Variable ASSIGNMENT . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Variable                       shift and go to state 80
    Expr                           shift and go to state 118
    const                          shift and go to state 81

state 87

    (65) goto_statement -> GOTO label .

    END             reduce using rule 65 (goto_statement -> GOTO label .)
    SEMICOLON       reduce using rule 65 (goto_statement -> GOTO label .)
    ELSE            reduce using rule 65 (goto_statement -> GOTO label .)


state 88

    (45) case_statement -> CASE case_index . OF case_element_list END
    (46) case_statement -> CASE case_index . OF case_element_list SEMICOLON END

    OF              shift and go to state 119


state 89

    (47) case_index -> Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    OF              reduce using rule 47 (case_index -> Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 90

    (71) Expr -> LPAREN . Expr RPAREN
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 120
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 91

    (91) function_heading -> FUNCTION funcName COLON return_type .

    SEMICOLON       reduce using rule 91 (function_heading -> FUNCTION funcName COLON return_type .)


state 92

    (95) return_type -> Type .

    SEMICOLON       reduce using rule 95 (return_type -> Type .)


state 93

    (92) function_heading -> FUNCTION funcName parameter_list COLON . return_type
    (95) return_type -> . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 66
    REAL            shift and go to state 67
    BOOLEAN         shift and go to state 68
    ID              shift and go to state 29

    return_type                    shift and go to state 121
    Type                           shift and go to state 92
    arrayName                      shift and go to state 69

state 94

    (93) parameter_list -> LPAREN VarDefList . RPAREN
    (4) VarDefList -> VarDefList . SEMICOLON VarDefState

    RPAREN          shift and go to state 122
    SEMICOLON       shift and go to state 123


state 95

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY . LBRAC index_list RBRAC OF Type

    LBRAC           shift and go to state 124


state 96

    (22) StateList -> StateList SEMICOLON Statement .

    END             reduce using rule 22 (StateList -> StateList SEMICOLON Statement .)
    SEMICOLON       reduce using rule 22 (StateList -> StateList SEMICOLON Statement .)


state 97

    (26) open_statement -> label COLON non_labeled_open_statement .

    END             reduce using rule 26 (open_statement -> label COLON non_labeled_open_statement .)
    SEMICOLON       reduce using rule 26 (open_statement -> label COLON non_labeled_open_statement .)


state 98

    (28) closed_statement -> label COLON non_labeled_closed_statement .

    END             reduce using rule 28 (closed_statement -> label COLON non_labeled_closed_statement .)
    SEMICOLON       reduce using rule 28 (closed_statement -> label COLON non_labeled_closed_statement .)
    ELSE            reduce using rule 28 (closed_statement -> label COLON non_labeled_closed_statement .)


state 99

    (52) open_if_statement -> IF BoolExpr THEN . Statement
    (53) open_if_statement -> IF BoolExpr THEN . closed_statement ELSE open_statement
    (54) closed_if_statement -> IF BoolExpr THEN . closed_statement ELSE closed_statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (66) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    BEGIN           shift and go to state 21
    IF              shift and go to state 125
    WHILE           shift and go to state 129
    FOR             shift and go to state 130
    GOTO            shift and go to state 55
    ELSE            reduce using rule 88 (empty -> .)
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    Statement                      shift and go to state 126
    closed_statement               shift and go to state 127
    open_statement                 shift and go to state 32
    label                          shift and go to state 128
    non_labeled_closed_statement   shift and go to state 36
    non_labeled_open_statement     shift and go to state 35
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    Variable                       shift and go to state 54

state 100

    (83) BoolExpr -> BoolExpr AND . BoolExpr
    (77) BoolExpr -> . Expr LT Expr
    (78) BoolExpr -> . Expr LE Expr
    (79) BoolExpr -> . Expr GT Expr
    (80) BoolExpr -> . Expr GE Expr
    (81) BoolExpr -> . Expr EQ Expr
    (82) BoolExpr -> . Expr NE Expr
    (83) BoolExpr -> . BoolExpr AND BoolExpr
    (84) BoolExpr -> . BoolExpr OR BoolExpr
    (85) BoolExpr -> . NOT BoolExpr
    (86) BoolExpr -> . LPAREN BoolExpr RPAREN
    (87) BoolExpr -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    NOT             shift and go to state 77
    LPAREN          shift and go to state 78
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    BoolExpr                       shift and go to state 131
    Expr                           shift and go to state 76
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 101

    (84) BoolExpr -> BoolExpr OR . BoolExpr
    (77) BoolExpr -> . Expr LT Expr
    (78) BoolExpr -> . Expr LE Expr
    (79) BoolExpr -> . Expr GT Expr
    (80) BoolExpr -> . Expr GE Expr
    (81) BoolExpr -> . Expr EQ Expr
    (82) BoolExpr -> . Expr NE Expr
    (83) BoolExpr -> . BoolExpr AND BoolExpr
    (84) BoolExpr -> . BoolExpr OR BoolExpr
    (85) BoolExpr -> . NOT BoolExpr
    (86) BoolExpr -> . LPAREN BoolExpr RPAREN
    (87) BoolExpr -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    NOT             shift and go to state 77
    LPAREN          shift and go to state 78
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    BoolExpr                       shift and go to state 132
    Expr                           shift and go to state 76
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 102

    (77) BoolExpr -> Expr LT . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 133
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 103

    (78) BoolExpr -> Expr LE . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 134
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 104

    (79) BoolExpr -> Expr GT . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 135
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 105

    (80) BoolExpr -> Expr GE . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 136
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 106

    (81) BoolExpr -> Expr EQ . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 137
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 107

    (82) BoolExpr -> Expr NE . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 138
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 108

    (67) Expr -> Expr PLUS . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 139
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 109

    (68) Expr -> Expr MINUS . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 140
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 110

    (69) Expr -> Expr TIMES . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 141
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 111

    (70) Expr -> Expr DIVIDE . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Expr                           shift and go to state 142
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 112

    (85) BoolExpr -> NOT BoolExpr .
    (83) BoolExpr -> BoolExpr . AND BoolExpr
    (84) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 85 (BoolExpr -> NOT BoolExpr .)
    DO              reduce using rule 85 (BoolExpr -> NOT BoolExpr .)
    RPAREN          reduce using rule 85 (BoolExpr -> NOT BoolExpr .)
    AND             shift and go to state 100
    OR              shift and go to state 101

  ! AND             [ reduce using rule 85 (BoolExpr -> NOT BoolExpr .) ]
  ! OR              [ reduce using rule 85 (BoolExpr -> NOT BoolExpr .) ]


state 113

    (86) BoolExpr -> LPAREN BoolExpr . RPAREN
    (83) BoolExpr -> BoolExpr . AND BoolExpr
    (84) BoolExpr -> BoolExpr . OR BoolExpr

    RPAREN          shift and go to state 143
    AND             shift and go to state 100
    OR              shift and go to state 101


state 114

    (71) Expr -> LPAREN Expr . RPAREN
    (77) BoolExpr -> Expr . LT Expr
    (78) BoolExpr -> Expr . LE Expr
    (79) BoolExpr -> Expr . GT Expr
    (80) BoolExpr -> Expr . GE Expr
    (81) BoolExpr -> Expr . EQ Expr
    (82) BoolExpr -> Expr . NE Expr
    (87) BoolExpr -> Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 144
    LT              shift and go to state 102
    LE              shift and go to state 103
    GT              shift and go to state 104
    GE              shift and go to state 105
    EQ              shift and go to state 106
    NE              shift and go to state 107
    AND             reduce using rule 87 (BoolExpr -> Expr .)
    OR              reduce using rule 87 (BoolExpr -> Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111

  ! RPAREN          [ reduce using rule 87 (BoolExpr -> Expr .) ]


state 115

    (72) Expr -> MINUS Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 72 (Expr -> MINUS Expr .)
    LE              reduce using rule 72 (Expr -> MINUS Expr .)
    GT              reduce using rule 72 (Expr -> MINUS Expr .)
    GE              reduce using rule 72 (Expr -> MINUS Expr .)
    EQ              reduce using rule 72 (Expr -> MINUS Expr .)
    NE              reduce using rule 72 (Expr -> MINUS Expr .)
    PLUS            reduce using rule 72 (Expr -> MINUS Expr .)
    MINUS           reduce using rule 72 (Expr -> MINUS Expr .)
    TIMES           reduce using rule 72 (Expr -> MINUS Expr .)
    DIVIDE          reduce using rule 72 (Expr -> MINUS Expr .)
    THEN            reduce using rule 72 (Expr -> MINUS Expr .)
    AND             reduce using rule 72 (Expr -> MINUS Expr .)
    OR              reduce using rule 72 (Expr -> MINUS Expr .)
    DO              reduce using rule 72 (Expr -> MINUS Expr .)
    OF              reduce using rule 72 (Expr -> MINUS Expr .)
    RPAREN          reduce using rule 72 (Expr -> MINUS Expr .)
    END             reduce using rule 72 (Expr -> MINUS Expr .)
    SEMICOLON       reduce using rule 72 (Expr -> MINUS Expr .)
    ELSE            reduce using rule 72 (Expr -> MINUS Expr .)
    TO              reduce using rule 72 (Expr -> MINUS Expr .)
    DOWNTO          reduce using rule 72 (Expr -> MINUS Expr .)

  ! PLUS            [ shift and go to state 108 ]
  ! MINUS           [ shift and go to state 109 ]
  ! TIMES           [ shift and go to state 110 ]
  ! DIVIDE          [ shift and go to state 111 ]


state 116

    (55) open_while_statement -> WHILE BoolExpr DO . open_statement
    (56) closed_while_statement -> WHILE BoolExpr DO . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (66) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    FOR             shift and go to state 53
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 55
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    ELSE            reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    open_statement                 shift and go to state 145
    closed_statement               shift and go to state 146
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    Variable                       shift and go to state 54

state 117

    (57) open_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO open_statement
    (58) closed_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO closed_statement
    (59) initial_value -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Variable                       shift and go to state 80
    initial_value                  shift and go to state 147
    Expr                           shift and go to state 148
    const                          shift and go to state 81

state 118

    (63) assignment_statement -> Variable ASSIGNMENT Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    END             reduce using rule 63 (assignment_statement -> Variable ASSIGNMENT Expr .)
    SEMICOLON       reduce using rule 63 (assignment_statement -> Variable ASSIGNMENT Expr .)
    ELSE            reduce using rule 63 (assignment_statement -> Variable ASSIGNMENT Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 119

    (45) case_statement -> CASE case_index OF . case_element_list END
    (46) case_statement -> CASE case_index OF . case_element_list SEMICOLON END
    (48) case_element_list -> . case_element_list SEMICOLON case_element
    (49) case_element_list -> . case_element
    (50) case_element -> . case_constant COLON Statement
    (51) case_constant -> . const
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    case_element_list              shift and go to state 149
    case_element                   shift and go to state 150
    case_constant                  shift and go to state 151
    const                          shift and go to state 152

state 120

    (71) Expr -> LPAREN Expr . RPAREN
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    RPAREN          shift and go to state 144
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 121

    (92) function_heading -> FUNCTION funcName parameter_list COLON return_type .

    SEMICOLON       reduce using rule 92 (function_heading -> FUNCTION funcName parameter_list COLON return_type .)


state 122

    (93) parameter_list -> LPAREN VarDefList RPAREN .

    COLON           reduce using rule 93 (parameter_list -> LPAREN VarDefList RPAREN .)


state 123

    (4) VarDefList -> VarDefList SEMICOLON . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    TYPE            shift and go to state 18
    ID              shift and go to state 19

    VarDefState                    shift and go to state 64
    VarList                        shift and go to state 15
    ArrayDefState                  shift and go to state 16
    Variable                       shift and go to state 17

state 124

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC . index_list RBRAC OF Type
    (12) index_list -> . index_list COMMA index
    (13) index_list -> . index
    (14) index -> . startIndex DOTDOT endIndex
    (20) startIndex -> . const
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    index_list                     shift and go to state 153
    index                          shift and go to state 154
    startIndex                     shift and go to state 155
    const                          shift and go to state 156

state 125

    (54) closed_if_statement -> IF . BoolExpr THEN closed_statement ELSE closed_statement
    (52) open_if_statement -> IF . BoolExpr THEN Statement
    (53) open_if_statement -> IF . BoolExpr THEN closed_statement ELSE open_statement
    (77) BoolExpr -> . Expr LT Expr
    (78) BoolExpr -> . Expr LE Expr
    (79) BoolExpr -> . Expr GT Expr
    (80) BoolExpr -> . Expr GE Expr
    (81) BoolExpr -> . Expr EQ Expr
    (82) BoolExpr -> . Expr NE Expr
    (83) BoolExpr -> . BoolExpr AND BoolExpr
    (84) BoolExpr -> . BoolExpr OR BoolExpr
    (85) BoolExpr -> . NOT BoolExpr
    (86) BoolExpr -> . LPAREN BoolExpr RPAREN
    (87) BoolExpr -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    NOT             shift and go to state 77
    LPAREN          shift and go to state 78
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    BoolExpr                       shift and go to state 157
    Expr                           shift and go to state 76
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 126

    (52) open_if_statement -> IF BoolExpr THEN Statement .

    END             reduce using rule 52 (open_if_statement -> IF BoolExpr THEN Statement .)
    SEMICOLON       reduce using rule 52 (open_if_statement -> IF BoolExpr THEN Statement .)


state 127

    (53) open_if_statement -> IF BoolExpr THEN closed_statement . ELSE open_statement
    (54) closed_if_statement -> IF BoolExpr THEN closed_statement . ELSE closed_statement
    (25) Statement -> closed_statement .

    ELSE            shift and go to state 158
    END             reduce using rule 25 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 25 (Statement -> closed_statement .)


state 128

    (28) closed_statement -> label . COLON non_labeled_closed_statement
    (26) open_statement -> label . COLON non_labeled_open_statement

    COLON           shift and go to state 159


state 129

    (56) closed_while_statement -> WHILE . BoolExpr DO closed_statement
    (55) open_while_statement -> WHILE . BoolExpr DO open_statement
    (77) BoolExpr -> . Expr LT Expr
    (78) BoolExpr -> . Expr LE Expr
    (79) BoolExpr -> . Expr GT Expr
    (80) BoolExpr -> . Expr GE Expr
    (81) BoolExpr -> . Expr EQ Expr
    (82) BoolExpr -> . Expr NE Expr
    (83) BoolExpr -> . BoolExpr AND BoolExpr
    (84) BoolExpr -> . BoolExpr OR BoolExpr
    (85) BoolExpr -> . NOT BoolExpr
    (86) BoolExpr -> . LPAREN BoolExpr RPAREN
    (87) BoolExpr -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    NOT             shift and go to state 77
    LPAREN          shift and go to state 78
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    BoolExpr                       shift and go to state 160
    Expr                           shift and go to state 76
    Variable                       shift and go to state 80
    const                          shift and go to state 81

state 130

    (58) closed_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (57) open_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    ID              shift and go to state 19

    Variable                       shift and go to state 161

state 131

    (83) BoolExpr -> BoolExpr AND BoolExpr .
    (83) BoolExpr -> BoolExpr . AND BoolExpr
    (84) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 83 (BoolExpr -> BoolExpr AND BoolExpr .)
    DO              reduce using rule 83 (BoolExpr -> BoolExpr AND BoolExpr .)
    RPAREN          reduce using rule 83 (BoolExpr -> BoolExpr AND BoolExpr .)
    AND             shift and go to state 100
    OR              shift and go to state 101

  ! AND             [ reduce using rule 83 (BoolExpr -> BoolExpr AND BoolExpr .) ]
  ! OR              [ reduce using rule 83 (BoolExpr -> BoolExpr AND BoolExpr .) ]


state 132

    (84) BoolExpr -> BoolExpr OR BoolExpr .
    (83) BoolExpr -> BoolExpr . AND BoolExpr
    (84) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 84 (BoolExpr -> BoolExpr OR BoolExpr .)
    DO              reduce using rule 84 (BoolExpr -> BoolExpr OR BoolExpr .)
    RPAREN          reduce using rule 84 (BoolExpr -> BoolExpr OR BoolExpr .)
    AND             shift and go to state 100
    OR              shift and go to state 101

  ! AND             [ reduce using rule 84 (BoolExpr -> BoolExpr OR BoolExpr .) ]
  ! OR              [ reduce using rule 84 (BoolExpr -> BoolExpr OR BoolExpr .) ]


state 133

    (77) BoolExpr -> Expr LT Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 77 (BoolExpr -> Expr LT Expr .)
    AND             reduce using rule 77 (BoolExpr -> Expr LT Expr .)
    OR              reduce using rule 77 (BoolExpr -> Expr LT Expr .)
    DO              reduce using rule 77 (BoolExpr -> Expr LT Expr .)
    RPAREN          reduce using rule 77 (BoolExpr -> Expr LT Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 134

    (78) BoolExpr -> Expr LE Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 78 (BoolExpr -> Expr LE Expr .)
    AND             reduce using rule 78 (BoolExpr -> Expr LE Expr .)
    OR              reduce using rule 78 (BoolExpr -> Expr LE Expr .)
    DO              reduce using rule 78 (BoolExpr -> Expr LE Expr .)
    RPAREN          reduce using rule 78 (BoolExpr -> Expr LE Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 135

    (79) BoolExpr -> Expr GT Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 79 (BoolExpr -> Expr GT Expr .)
    AND             reduce using rule 79 (BoolExpr -> Expr GT Expr .)
    OR              reduce using rule 79 (BoolExpr -> Expr GT Expr .)
    DO              reduce using rule 79 (BoolExpr -> Expr GT Expr .)
    RPAREN          reduce using rule 79 (BoolExpr -> Expr GT Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 136

    (80) BoolExpr -> Expr GE Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 80 (BoolExpr -> Expr GE Expr .)
    AND             reduce using rule 80 (BoolExpr -> Expr GE Expr .)
    OR              reduce using rule 80 (BoolExpr -> Expr GE Expr .)
    DO              reduce using rule 80 (BoolExpr -> Expr GE Expr .)
    RPAREN          reduce using rule 80 (BoolExpr -> Expr GE Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 137

    (81) BoolExpr -> Expr EQ Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 81 (BoolExpr -> Expr EQ Expr .)
    AND             reduce using rule 81 (BoolExpr -> Expr EQ Expr .)
    OR              reduce using rule 81 (BoolExpr -> Expr EQ Expr .)
    DO              reduce using rule 81 (BoolExpr -> Expr EQ Expr .)
    RPAREN          reduce using rule 81 (BoolExpr -> Expr EQ Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 138

    (82) BoolExpr -> Expr NE Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 82 (BoolExpr -> Expr NE Expr .)
    AND             reduce using rule 82 (BoolExpr -> Expr NE Expr .)
    OR              reduce using rule 82 (BoolExpr -> Expr NE Expr .)
    DO              reduce using rule 82 (BoolExpr -> Expr NE Expr .)
    RPAREN          reduce using rule 82 (BoolExpr -> Expr NE Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 139

    (67) Expr -> Expr PLUS Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 67 (Expr -> Expr PLUS Expr .)
    LE              reduce using rule 67 (Expr -> Expr PLUS Expr .)
    GT              reduce using rule 67 (Expr -> Expr PLUS Expr .)
    GE              reduce using rule 67 (Expr -> Expr PLUS Expr .)
    EQ              reduce using rule 67 (Expr -> Expr PLUS Expr .)
    NE              reduce using rule 67 (Expr -> Expr PLUS Expr .)
    PLUS            reduce using rule 67 (Expr -> Expr PLUS Expr .)
    MINUS           reduce using rule 67 (Expr -> Expr PLUS Expr .)
    THEN            reduce using rule 67 (Expr -> Expr PLUS Expr .)
    AND             reduce using rule 67 (Expr -> Expr PLUS Expr .)
    OR              reduce using rule 67 (Expr -> Expr PLUS Expr .)
    DO              reduce using rule 67 (Expr -> Expr PLUS Expr .)
    OF              reduce using rule 67 (Expr -> Expr PLUS Expr .)
    RPAREN          reduce using rule 67 (Expr -> Expr PLUS Expr .)
    END             reduce using rule 67 (Expr -> Expr PLUS Expr .)
    SEMICOLON       reduce using rule 67 (Expr -> Expr PLUS Expr .)
    ELSE            reduce using rule 67 (Expr -> Expr PLUS Expr .)
    TO              reduce using rule 67 (Expr -> Expr PLUS Expr .)
    DOWNTO          reduce using rule 67 (Expr -> Expr PLUS Expr .)
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111

  ! TIMES           [ reduce using rule 67 (Expr -> Expr PLUS Expr .) ]
  ! DIVIDE          [ reduce using rule 67 (Expr -> Expr PLUS Expr .) ]
  ! PLUS            [ shift and go to state 108 ]
  ! MINUS           [ shift and go to state 109 ]


state 140

    (68) Expr -> Expr MINUS Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 68 (Expr -> Expr MINUS Expr .)
    LE              reduce using rule 68 (Expr -> Expr MINUS Expr .)
    GT              reduce using rule 68 (Expr -> Expr MINUS Expr .)
    GE              reduce using rule 68 (Expr -> Expr MINUS Expr .)
    EQ              reduce using rule 68 (Expr -> Expr MINUS Expr .)
    NE              reduce using rule 68 (Expr -> Expr MINUS Expr .)
    PLUS            reduce using rule 68 (Expr -> Expr MINUS Expr .)
    MINUS           reduce using rule 68 (Expr -> Expr MINUS Expr .)
    THEN            reduce using rule 68 (Expr -> Expr MINUS Expr .)
    AND             reduce using rule 68 (Expr -> Expr MINUS Expr .)
    OR              reduce using rule 68 (Expr -> Expr MINUS Expr .)
    DO              reduce using rule 68 (Expr -> Expr MINUS Expr .)
    OF              reduce using rule 68 (Expr -> Expr MINUS Expr .)
    RPAREN          reduce using rule 68 (Expr -> Expr MINUS Expr .)
    END             reduce using rule 68 (Expr -> Expr MINUS Expr .)
    SEMICOLON       reduce using rule 68 (Expr -> Expr MINUS Expr .)
    ELSE            reduce using rule 68 (Expr -> Expr MINUS Expr .)
    TO              reduce using rule 68 (Expr -> Expr MINUS Expr .)
    DOWNTO          reduce using rule 68 (Expr -> Expr MINUS Expr .)
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111

  ! TIMES           [ reduce using rule 68 (Expr -> Expr MINUS Expr .) ]
  ! DIVIDE          [ reduce using rule 68 (Expr -> Expr MINUS Expr .) ]
  ! PLUS            [ shift and go to state 108 ]
  ! MINUS           [ shift and go to state 109 ]


state 141

    (69) Expr -> Expr TIMES Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 69 (Expr -> Expr TIMES Expr .)
    LE              reduce using rule 69 (Expr -> Expr TIMES Expr .)
    GT              reduce using rule 69 (Expr -> Expr TIMES Expr .)
    GE              reduce using rule 69 (Expr -> Expr TIMES Expr .)
    EQ              reduce using rule 69 (Expr -> Expr TIMES Expr .)
    NE              reduce using rule 69 (Expr -> Expr TIMES Expr .)
    PLUS            reduce using rule 69 (Expr -> Expr TIMES Expr .)
    MINUS           reduce using rule 69 (Expr -> Expr TIMES Expr .)
    TIMES           reduce using rule 69 (Expr -> Expr TIMES Expr .)
    DIVIDE          reduce using rule 69 (Expr -> Expr TIMES Expr .)
    THEN            reduce using rule 69 (Expr -> Expr TIMES Expr .)
    AND             reduce using rule 69 (Expr -> Expr TIMES Expr .)
    OR              reduce using rule 69 (Expr -> Expr TIMES Expr .)
    DO              reduce using rule 69 (Expr -> Expr TIMES Expr .)
    OF              reduce using rule 69 (Expr -> Expr TIMES Expr .)
    RPAREN          reduce using rule 69 (Expr -> Expr TIMES Expr .)
    END             reduce using rule 69 (Expr -> Expr TIMES Expr .)
    SEMICOLON       reduce using rule 69 (Expr -> Expr TIMES Expr .)
    ELSE            reduce using rule 69 (Expr -> Expr TIMES Expr .)
    TO              reduce using rule 69 (Expr -> Expr TIMES Expr .)
    DOWNTO          reduce using rule 69 (Expr -> Expr TIMES Expr .)

  ! PLUS            [ shift and go to state 108 ]
  ! MINUS           [ shift and go to state 109 ]
  ! TIMES           [ shift and go to state 110 ]
  ! DIVIDE          [ shift and go to state 111 ]


state 142

    (70) Expr -> Expr DIVIDE Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    LE              reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    GT              reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    GE              reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    EQ              reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    NE              reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    PLUS            reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    MINUS           reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    TIMES           reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    DIVIDE          reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    THEN            reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    AND             reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    OR              reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    DO              reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    OF              reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    RPAREN          reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    END             reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    SEMICOLON       reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    ELSE            reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    TO              reduce using rule 70 (Expr -> Expr DIVIDE Expr .)
    DOWNTO          reduce using rule 70 (Expr -> Expr DIVIDE Expr .)

  ! PLUS            [ shift and go to state 108 ]
  ! MINUS           [ shift and go to state 109 ]
  ! TIMES           [ shift and go to state 110 ]
  ! DIVIDE          [ shift and go to state 111 ]


state 143

    (86) BoolExpr -> LPAREN BoolExpr RPAREN .

    THEN            reduce using rule 86 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    AND             reduce using rule 86 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    OR              reduce using rule 86 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    DO              reduce using rule 86 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    RPAREN          reduce using rule 86 (BoolExpr -> LPAREN BoolExpr RPAREN .)


state 144

    (71) Expr -> LPAREN Expr RPAREN .

    LT              reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    LE              reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    GT              reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    GE              reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    EQ              reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    NE              reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    PLUS            reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    MINUS           reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    TIMES           reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    DIVIDE          reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    THEN            reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    AND             reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    OR              reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    DO              reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    OF              reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    RPAREN          reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    END             reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    SEMICOLON       reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    ELSE            reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    TO              reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)
    DOWNTO          reduce using rule 71 (Expr -> LPAREN Expr RPAREN .)


state 145

    (55) open_while_statement -> WHILE BoolExpr DO open_statement .

    END             reduce using rule 55 (open_while_statement -> WHILE BoolExpr DO open_statement .)
    SEMICOLON       reduce using rule 55 (open_while_statement -> WHILE BoolExpr DO open_statement .)


state 146

    (56) closed_while_statement -> WHILE BoolExpr DO closed_statement .

    END             reduce using rule 56 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)
    SEMICOLON       reduce using rule 56 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)
    ELSE            reduce using rule 56 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)


state 147

    (57) open_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO open_statement
    (58) closed_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO closed_statement
    (61) direction -> . TO
    (62) direction -> . DOWNTO

    TO              shift and go to state 163
    DOWNTO          shift and go to state 164

    direction                      shift and go to state 162

state 148

    (59) initial_value -> Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    TO              reduce using rule 59 (initial_value -> Expr .)
    DOWNTO          reduce using rule 59 (initial_value -> Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 149

    (45) case_statement -> CASE case_index OF case_element_list . END
    (46) case_statement -> CASE case_index OF case_element_list . SEMICOLON END
    (48) case_element_list -> case_element_list . SEMICOLON case_element

    END             shift and go to state 165
    SEMICOLON       shift and go to state 166


state 150

    (49) case_element_list -> case_element .

    END             reduce using rule 49 (case_element_list -> case_element .)
    SEMICOLON       reduce using rule 49 (case_element_list -> case_element .)


state 151

    (50) case_element -> case_constant . COLON Statement

    COLON           shift and go to state 167


state 152

    (51) case_constant -> const .

    COLON           reduce using rule 51 (case_constant -> const .)


state 153

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list . RBRAC OF Type
    (12) index_list -> index_list . COMMA index

    RBRAC           shift and go to state 168
    COMMA           shift and go to state 169


state 154

    (13) index_list -> index .

    RBRAC           reduce using rule 13 (index_list -> index .)
    COMMA           reduce using rule 13 (index_list -> index .)


state 155

    (14) index -> startIndex . DOTDOT endIndex

    DOTDOT          shift and go to state 170


state 156

    (20) startIndex -> const .

    DOTDOT          reduce using rule 20 (startIndex -> const .)


state 157

    (54) closed_if_statement -> IF BoolExpr . THEN closed_statement ELSE closed_statement
    (52) open_if_statement -> IF BoolExpr . THEN Statement
    (53) open_if_statement -> IF BoolExpr . THEN closed_statement ELSE open_statement
    (83) BoolExpr -> BoolExpr . AND BoolExpr
    (84) BoolExpr -> BoolExpr . OR BoolExpr

    THEN            shift and go to state 171
    AND             shift and go to state 100
    OR              shift and go to state 101


state 158

    (53) open_if_statement -> IF BoolExpr THEN closed_statement ELSE . open_statement
    (54) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (66) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    FOR             shift and go to state 53
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 55
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    ELSE            reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    closed_statement               shift and go to state 172
    open_statement                 shift and go to state 173
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    Variable                       shift and go to state 54

state 159

    (28) closed_statement -> label COLON . non_labeled_closed_statement
    (26) open_statement -> label COLON . non_labeled_open_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    BEGIN           shift and go to state 21
    IF              shift and go to state 125
    WHILE           shift and go to state 129
    FOR             shift and go to state 130
    GOTO            shift and go to state 55
    ELSE            reduce using rule 88 (empty -> .)
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    non_labeled_closed_statement   shift and go to state 98
    non_labeled_open_statement     shift and go to state 97
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    Variable                       shift and go to state 54

state 160

    (56) closed_while_statement -> WHILE BoolExpr . DO closed_statement
    (55) open_while_statement -> WHILE BoolExpr . DO open_statement
    (83) BoolExpr -> BoolExpr . AND BoolExpr
    (84) BoolExpr -> BoolExpr . OR BoolExpr

    DO              shift and go to state 174
    AND             shift and go to state 100
    OR              shift and go to state 101


state 161

    (58) closed_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO closed_statement
    (57) open_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO open_statement

    ASSIGNMENT      shift and go to state 175


state 162

    (57) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO open_statement
    (58) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO closed_statement
    (60) final_value -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Variable                       shift and go to state 80
    final_value                    shift and go to state 176
    Expr                           shift and go to state 177
    const                          shift and go to state 81

state 163

    (61) direction -> TO .

    LPAREN          reduce using rule 61 (direction -> TO .)
    MINUS           reduce using rule 61 (direction -> TO .)
    ID              reduce using rule 61 (direction -> TO .)
    INT_NUMBER      reduce using rule 61 (direction -> TO .)
    REAL_NUMBER     reduce using rule 61 (direction -> TO .)


state 164

    (62) direction -> DOWNTO .

    LPAREN          reduce using rule 62 (direction -> DOWNTO .)
    MINUS           reduce using rule 62 (direction -> DOWNTO .)
    ID              reduce using rule 62 (direction -> DOWNTO .)
    INT_NUMBER      reduce using rule 62 (direction -> DOWNTO .)
    REAL_NUMBER     reduce using rule 62 (direction -> DOWNTO .)


state 165

    (45) case_statement -> CASE case_index OF case_element_list END .

    END             reduce using rule 45 (case_statement -> CASE case_index OF case_element_list END .)
    SEMICOLON       reduce using rule 45 (case_statement -> CASE case_index OF case_element_list END .)
    ELSE            reduce using rule 45 (case_statement -> CASE case_index OF case_element_list END .)


state 166

    (46) case_statement -> CASE case_index OF case_element_list SEMICOLON . END
    (48) case_element_list -> case_element_list SEMICOLON . case_element
    (50) case_element -> . case_constant COLON Statement
    (51) case_constant -> . const
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    END             shift and go to state 178
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    case_element                   shift and go to state 179
    case_constant                  shift and go to state 151
    const                          shift and go to state 152

state 167

    (50) case_element -> case_constant COLON . Statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (66) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    FOR             shift and go to state 53
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 55
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    Statement                      shift and go to state 180
    open_statement                 shift and go to state 32
    closed_statement               shift and go to state 33
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    Variable                       shift and go to state 54

state 168

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC . OF Type

    OF              shift and go to state 181


state 169

    (12) index_list -> index_list COMMA . index
    (14) index -> . startIndex DOTDOT endIndex
    (20) startIndex -> . const
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    index                          shift and go to state 182
    startIndex                     shift and go to state 155
    const                          shift and go to state 156

state 170

    (14) index -> startIndex DOTDOT . endIndex
    (21) endIndex -> . const
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    endIndex                       shift and go to state 183
    const                          shift and go to state 184

state 171

    (54) closed_if_statement -> IF BoolExpr THEN . closed_statement ELSE closed_statement
    (52) open_if_statement -> IF BoolExpr THEN . Statement
    (53) open_if_statement -> IF BoolExpr THEN . closed_statement ELSE open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (66) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (19) Variable -> . ID
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement

    DIGSEQ          shift and go to state 37
    BEGIN           shift and go to state 21
    IF              shift and go to state 125
    WHILE           shift and go to state 129
    FOR             shift and go to state 130
    GOTO            shift and go to state 55
    ELSE            reduce using rule 88 (empty -> .)
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    closed_statement               shift and go to state 185
    Statement                      shift and go to state 126
    open_statement                 shift and go to state 32
    label                          shift and go to state 128
    non_labeled_closed_statement   shift and go to state 36
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    non_labeled_open_statement     shift and go to state 35
    Variable                       shift and go to state 54
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40

state 172

    (54) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .

    END             reduce using rule 54 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)
    SEMICOLON       reduce using rule 54 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)
    ELSE            reduce using rule 54 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)


state 173

    (53) open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .

    END             reduce using rule 53 (open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .)
    SEMICOLON       reduce using rule 53 (open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .)


state 174

    (56) closed_while_statement -> WHILE BoolExpr DO . closed_statement
    (55) open_while_statement -> WHILE BoolExpr DO . open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (66) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    BEGIN           shift and go to state 21
    IF              shift and go to state 125
    WHILE           shift and go to state 129
    FOR             shift and go to state 130
    GOTO            shift and go to state 55
    ELSE            reduce using rule 88 (empty -> .)
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    closed_statement               shift and go to state 146
    open_statement                 shift and go to state 145
    label                          shift and go to state 128
    non_labeled_closed_statement   shift and go to state 36
    non_labeled_open_statement     shift and go to state 35
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    Variable                       shift and go to state 54

state 175

    (58) closed_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO closed_statement
    (57) open_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO open_statement
    (59) initial_value -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Variable                       shift and go to state 80
    initial_value                  shift and go to state 186
    Expr                           shift and go to state 148
    const                          shift and go to state 81

state 176

    (57) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO open_statement
    (58) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO closed_statement

    DO              shift and go to state 187


state 177

    (60) final_value -> Expr .
    (67) Expr -> Expr . PLUS Expr
    (68) Expr -> Expr . MINUS Expr
    (69) Expr -> Expr . TIMES Expr
    (70) Expr -> Expr . DIVIDE Expr

    DO              reduce using rule 60 (final_value -> Expr .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 178

    (46) case_statement -> CASE case_index OF case_element_list SEMICOLON END .

    END             reduce using rule 46 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)
    SEMICOLON       reduce using rule 46 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)
    ELSE            reduce using rule 46 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)


state 179

    (48) case_element_list -> case_element_list SEMICOLON case_element .

    END             reduce using rule 48 (case_element_list -> case_element_list SEMICOLON case_element .)
    SEMICOLON       reduce using rule 48 (case_element_list -> case_element_list SEMICOLON case_element .)


state 180

    (50) case_element -> case_constant COLON Statement .

    END             reduce using rule 50 (case_element -> case_constant COLON Statement .)
    SEMICOLON       reduce using rule 50 (case_element -> case_constant COLON Statement .)


state 181

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 66
    REAL            shift and go to state 67
    BOOLEAN         shift and go to state 68
    ID              shift and go to state 29

    arrayName                      shift and go to state 69
    Type                           shift and go to state 188

state 182

    (12) index_list -> index_list COMMA index .

    RBRAC           reduce using rule 12 (index_list -> index_list COMMA index .)
    COMMA           reduce using rule 12 (index_list -> index_list COMMA index .)


state 183

    (14) index -> startIndex DOTDOT endIndex .

    RBRAC           reduce using rule 14 (index -> startIndex DOTDOT endIndex .)
    COMMA           reduce using rule 14 (index -> startIndex DOTDOT endIndex .)


state 184

    (21) endIndex -> const .

    RBRAC           reduce using rule 21 (endIndex -> const .)
    COMMA           reduce using rule 21 (endIndex -> const .)


state 185

    (54) closed_if_statement -> IF BoolExpr THEN closed_statement . ELSE closed_statement
    (53) open_if_statement -> IF BoolExpr THEN closed_statement . ELSE open_statement
    (25) Statement -> closed_statement .

    ELSE            shift and go to state 189
    END             reduce using rule 25 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 25 (Statement -> closed_statement .)


state 186

    (58) closed_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO closed_statement
    (57) open_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO open_statement
    (61) direction -> . TO
    (62) direction -> . DOWNTO

    TO              shift and go to state 163
    DOWNTO          shift and go to state 164

    direction                      shift and go to state 190

state 187

    (57) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . open_statement
    (58) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (66) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 51
    WHILE           shift and go to state 52
    FOR             shift and go to state 53
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 55
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    ELSE            reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    Variable                       shift and go to state 54
    open_statement                 shift and go to state 191
    closed_statement               shift and go to state 192
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50

state 188

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type .

    SEMICOLON       reduce using rule 10 (ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type .)
    RPAREN          reduce using rule 10 (ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type .)


state 189

    (54) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE . closed_statement
    (53) open_if_statement -> IF BoolExpr THEN closed_statement ELSE . open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (66) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    BEGIN           shift and go to state 21
    IF              shift and go to state 125
    WHILE           shift and go to state 129
    FOR             shift and go to state 130
    GOTO            shift and go to state 55
    ELSE            reduce using rule 88 (empty -> .)
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    closed_statement               shift and go to state 172
    open_statement                 shift and go to state 173
    label                          shift and go to state 128
    non_labeled_closed_statement   shift and go to state 36
    non_labeled_open_statement     shift and go to state 35
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    Variable                       shift and go to state 54

state 190

    (58) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO closed_statement
    (57) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO open_statement
    (60) final_value -> . Expr
    (67) Expr -> . Expr PLUS Expr
    (68) Expr -> . Expr MINUS Expr
    (69) Expr -> . Expr TIMES Expr
    (70) Expr -> . Expr DIVIDE Expr
    (71) Expr -> . LPAREN Expr RPAREN
    (72) Expr -> . MINUS Expr
    (73) Expr -> . Variable
    (74) Expr -> . const
    (19) Variable -> . ID
    (75) const -> . INT_NUMBER
    (76) const -> . REAL_NUMBER

    LPAREN          shift and go to state 90
    MINUS           shift and go to state 79
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 82
    REAL_NUMBER     shift and go to state 83

    Variable                       shift and go to state 80
    final_value                    shift and go to state 193
    Expr                           shift and go to state 177
    const                          shift and go to state 81

state 191

    (57) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .

    END             reduce using rule 57 (open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .)
    SEMICOLON       reduce using rule 57 (open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .)


state 192

    (58) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .

    END             reduce using rule 58 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)
    SEMICOLON       reduce using rule 58 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)
    ELSE            reduce using rule 58 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)


state 193

    (58) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO closed_statement
    (57) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO open_statement

    DO              shift and go to state 194


state 194

    (58) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . closed_statement
    (57) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (66) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (41) non_labeled_closed_statement -> . continue_statement
    (43) non_labeled_closed_statement -> . break_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (63) assignment_statement -> . Variable ASSIGNMENT Expr
    (64) compound_statement -> . BEGIN StateList END
    (54) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (56) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (58) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (65) goto_statement -> . GOTO label
    (88) empty -> .
    (45) case_statement -> . CASE case_index OF case_element_list END
    (46) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (42) continue_statement -> . CONTINUE
    (44) break_statement -> . BREAK
    (52) open_if_statement -> . IF BoolExpr THEN Statement
    (53) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (55) open_while_statement -> . WHILE BoolExpr DO open_statement
    (57) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    BEGIN           shift and go to state 21
    IF              shift and go to state 125
    WHILE           shift and go to state 129
    FOR             shift and go to state 130
    GOTO            shift and go to state 55
    ELSE            reduce using rule 88 (empty -> .)
    END             reduce using rule 88 (empty -> .)
    SEMICOLON       reduce using rule 88 (empty -> .)
    CASE            shift and go to state 56
    CONTINUE        shift and go to state 57
    BREAK           shift and go to state 58
    ID              shift and go to state 19

    Variable                       shift and go to state 54
    closed_statement               shift and go to state 192
    open_statement                 shift and go to state 191
    label                          shift and go to state 128
    non_labeled_closed_statement   shift and go to state 36
    non_labeled_open_statement     shift and go to state 35
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    continue_statement             shift and go to state 49
    break_statement                shift and go to state 50
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 112 resolved as shift
WARNING: shift/reduce conflict for OR in state 112 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 114 resolved as shift
WARNING: shift/reduce conflict for AND in state 131 resolved as shift
WARNING: shift/reduce conflict for OR in state 131 resolved as shift
WARNING: shift/reduce conflict for AND in state 132 resolved as shift
WARNING: shift/reduce conflict for OR in state 132 resolved as shift
