Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    LLAVEI
    LLAVED
    MOD
    FUNCTION
    RETURN
    CHAR
    STRING
    USES
    CONST

Grammar

Rule 0     S' -> ProgDef
Rule 1     ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT
Rule 2     SubProg -> VarDef compound_statement
Rule 3     VarDef -> VAR VarDefList SEMICOLON
Rule 4     VarDefList -> VarDefList SEMICOLON VarDefState
Rule 5     VarDefList -> VarDefState
Rule 6     VarDefState -> VarList COLON Type
Rule 7     VarDefState -> ArrayDefState
Rule 8     VarList -> VarList COMMA Variable
Rule 9     VarList -> Variable
Rule 10    ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
Rule 11    arrayName -> ID
Rule 12    index_list -> index_list COMMA index
Rule 13    index_list -> index
Rule 14    index -> startIndex DOTDOT endIndex
Rule 15    Type -> INTEGER
Rule 16    Type -> REAL
Rule 17    Type -> BOOLEAN
Rule 18    Type -> arrayName
Rule 19    Variable -> ID
Rule 20    startIndex -> const
Rule 21    endIndex -> const
Rule 22    StateList -> StateList SEMICOLON Statement
Rule 23    StateList -> Statement
Rule 24    Statement -> open_statement
Rule 25    Statement -> closed_statement
Rule 26    open_statement -> label COLON non_labeled_open_statement
Rule 27    open_statement -> non_labeled_open_statement
Rule 28    closed_statement -> label COLON non_labeled_closed_statement
Rule 29    closed_statement -> non_labeled_closed_statement
Rule 30    non_labeled_open_statement -> open_if_statement
Rule 31    non_labeled_open_statement -> open_while_statement
Rule 32    non_labeled_open_statement -> open_for_statement
Rule 33    non_labeled_closed_statement -> assignment_statement
Rule 34    non_labeled_closed_statement -> compound_statement
Rule 35    non_labeled_closed_statement -> closed_if_statement
Rule 36    non_labeled_closed_statement -> closed_while_statement
Rule 37    non_labeled_closed_statement -> closed_for_statement
Rule 38    non_labeled_closed_statement -> goto_statement
Rule 39    non_labeled_closed_statement -> empty
Rule 40    non_labeled_closed_statement -> case_statement
Rule 41    case_statement -> CASE case_index OF case_element_list END
Rule 42    case_statement -> CASE case_index OF case_element_list SEMICOLON END
Rule 43    case_index -> Expr
Rule 44    case_element_list -> case_element_list SEMICOLON case_element
Rule 45    case_element_list -> case_element
Rule 46    case_element -> case_constant COLON Statement
Rule 47    case_constant -> const
Rule 48    open_if_statement -> IF BoolExpr THEN Statement
Rule 49    open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement
Rule 50    closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement
Rule 51    open_while_statement -> WHILE BoolExpr DO open_statement
Rule 52    closed_while_statement -> WHILE BoolExpr DO closed_statement
Rule 53    open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
Rule 54    closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
Rule 55    initial_value -> Expr
Rule 56    final_value -> Expr
Rule 57    direction -> TO
Rule 58    direction -> DOWNTO
Rule 59    assignment_statement -> Variable ASSIGNMENT Expr
Rule 60    compound_statement -> BEGIN StateList END
Rule 61    goto_statement -> GOTO label
Rule 62    label -> DIGSEQ
Rule 63    Expr -> Expr PLUS Expr
Rule 64    Expr -> Expr MINUS Expr
Rule 65    Expr -> Expr TIMES Expr
Rule 66    Expr -> Expr DIVIDE Expr
Rule 67    Expr -> LPAREN Expr RPAREN
Rule 68    Expr -> MINUS Expr
Rule 69    Expr -> Variable
Rule 70    Expr -> const
Rule 71    const -> INT_NUMBER
Rule 72    const -> REAL_NUMBER
Rule 73    BoolExpr -> Expr LT Expr
Rule 74    BoolExpr -> Expr LE Expr
Rule 75    BoolExpr -> Expr GT Expr
Rule 76    BoolExpr -> Expr GE Expr
Rule 77    BoolExpr -> Expr EQ Expr
Rule 78    BoolExpr -> Expr NE Expr
Rule 79    BoolExpr -> BoolExpr AND BoolExpr
Rule 80    BoolExpr -> BoolExpr OR BoolExpr
Rule 81    BoolExpr -> NOT BoolExpr
Rule 82    BoolExpr -> LPAREN BoolExpr RPAREN
Rule 83    BoolExpr -> Expr
Rule 84    empty -> <empty>

Terminals, with rules where they appear

AND                  : 79
ARRAY                : 10
ASSIGNMENT           : 53 54 59
BEGIN                : 60
BOOLEAN              : 17
CASE                 : 41 42
CHAR                 : 
COLON                : 6 26 28 46
COMMA                : 8 12
CONST                : 
DIGSEQ               : 62
DIVIDE               : 66
DO                   : 51 52 53 54
DOTDOT               : 14
DOWNTO               : 58
ELSE                 : 49 50
END                  : 41 42 60
ENDPOINT             : 1
EQ                   : 10 77
FOR                  : 53 54
FUNCTION             : 
GE                   : 76
GOTO                 : 61
GT                   : 75
ID                   : 1 11 19
IF                   : 48 49 50
INTEGER              : 15
INT_NUMBER           : 71
LBRAC                : 10
LE                   : 74
LLAVED               : 
LLAVEI               : 
LPAREN               : 67 82
LT                   : 73
MINUS                : 64 68
MOD                  : 
NE                   : 78
NOT                  : 81
OF                   : 10 41 42
OR                   : 80
PLUS                 : 63
PROGRAM              : 1
RBRAC                : 10
REAL                 : 16
REAL_NUMBER          : 72
RETURN               : 
RPAREN               : 67 82
SEMICOLON            : 1 3 4 22 42 44
STRING               : 
THEN                 : 48 49 50
TIMES                : 65
TO                   : 57
TYPE                 : 10
USES                 : 
VAR                  : 3
WHILE                : 51 52
error                : 

Nonterminals, with rules where they appear

ArrayDefState        : 7
BoolExpr             : 48 49 50 51 52 79 79 80 80 81 82
Expr                 : 43 55 56 59 63 63 64 64 65 65 66 66 67 68 73 73 74 74 75 75 76 76 77 77 78 78 83
ProgDef              : 0
StateList            : 22 60
Statement            : 22 23 46 48
SubProg              : 1
Type                 : 6 10
VarDef               : 2
VarDefList           : 3 4
VarDefState          : 4 5
VarList              : 6 8
Variable             : 8 9 53 54 59 69
arrayName            : 10 18
assignment_statement : 33
case_constant        : 46
case_element         : 44 45
case_element_list    : 41 42 44
case_index           : 41 42
case_statement       : 40
closed_for_statement : 37
closed_if_statement  : 35
closed_statement     : 25 49 50 50 52 54
closed_while_statement : 36
compound_statement   : 2 34
const                : 20 21 47 70
direction            : 53 54
empty                : 39
endIndex             : 14
final_value          : 53 54
goto_statement       : 38
index                : 12 13
index_list           : 10 12
initial_value        : 53 54
label                : 26 28 61
non_labeled_closed_statement : 28 29
non_labeled_open_statement : 26 27
open_for_statement   : 32
open_if_statement    : 30
open_statement       : 24 49 51 53
open_while_statement : 31
startIndex           : 14

Parsing method: LALR

state 0

    (0) S' -> . ProgDef
    (1) ProgDef -> . PROGRAM ID SEMICOLON SubProg ENDPOINT

    PROGRAM         shift and go to state 2

    ProgDef                        shift and go to state 1

state 1

    (0) S' -> ProgDef .



state 2

    (1) ProgDef -> PROGRAM . ID SEMICOLON SubProg ENDPOINT

    ID              shift and go to state 3


state 3

    (1) ProgDef -> PROGRAM ID . SEMICOLON SubProg ENDPOINT

    SEMICOLON       shift and go to state 4


state 4

    (1) ProgDef -> PROGRAM ID SEMICOLON . SubProg ENDPOINT
    (2) SubProg -> . VarDef compound_statement
    (3) VarDef -> . VAR VarDefList SEMICOLON

    VAR             shift and go to state 7

    SubProg                        shift and go to state 5
    VarDef                         shift and go to state 6

state 5

    (1) ProgDef -> PROGRAM ID SEMICOLON SubProg . ENDPOINT

    ENDPOINT        shift and go to state 8


state 6

    (2) SubProg -> VarDef . compound_statement
    (60) compound_statement -> . BEGIN StateList END

    BEGIN           shift and go to state 10

    compound_statement             shift and go to state 9

state 7

    (3) VarDef -> VAR . VarDefList SEMICOLON
    (4) VarDefList -> . VarDefList SEMICOLON VarDefState
    (5) VarDefList -> . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    TYPE            shift and go to state 16
    ID              shift and go to state 17

    VarDefList                     shift and go to state 11
    VarDefState                    shift and go to state 12
    VarList                        shift and go to state 13
    ArrayDefState                  shift and go to state 14
    Variable                       shift and go to state 15

state 8

    (1) ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT .

    $end            reduce using rule 1 (ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT .)


state 9

    (2) SubProg -> VarDef compound_statement .

    ENDPOINT        reduce using rule 2 (SubProg -> VarDef compound_statement .)


state 10

    (60) compound_statement -> BEGIN . StateList END
    (22) StateList -> . StateList SEMICOLON Statement
    (23) StateList -> . Statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 10
    GOTO            shift and go to state 41
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    StateList                      shift and go to state 18
    Statement                      shift and go to state 19
    open_statement                 shift and go to state 20
    closed_statement               shift and go to state 21
    label                          shift and go to state 22
    non_labeled_open_statement     shift and go to state 23
    non_labeled_closed_statement   shift and go to state 24
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    Variable                       shift and go to state 40

state 11

    (3) VarDef -> VAR VarDefList . SEMICOLON
    (4) VarDefList -> VarDefList . SEMICOLON VarDefState

    SEMICOLON       shift and go to state 43


state 12

    (5) VarDefList -> VarDefState .

    SEMICOLON       reduce using rule 5 (VarDefList -> VarDefState .)


state 13

    (6) VarDefState -> VarList . COLON Type
    (8) VarList -> VarList . COMMA Variable

    COLON           shift and go to state 44
    COMMA           shift and go to state 45


state 14

    (7) VarDefState -> ArrayDefState .

    SEMICOLON       reduce using rule 7 (VarDefState -> ArrayDefState .)


state 15

    (9) VarList -> Variable .

    COLON           reduce using rule 9 (VarList -> Variable .)
    COMMA           reduce using rule 9 (VarList -> Variable .)


state 16

    (10) ArrayDefState -> TYPE . arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (11) arrayName -> . ID

    ID              shift and go to state 47

    arrayName                      shift and go to state 46

state 17

    (19) Variable -> ID .

    COLON           reduce using rule 19 (Variable -> ID .)
    COMMA           reduce using rule 19 (Variable -> ID .)
    ASSIGNMENT      reduce using rule 19 (Variable -> ID .)
    LT              reduce using rule 19 (Variable -> ID .)
    LE              reduce using rule 19 (Variable -> ID .)
    GT              reduce using rule 19 (Variable -> ID .)
    GE              reduce using rule 19 (Variable -> ID .)
    EQ              reduce using rule 19 (Variable -> ID .)
    NE              reduce using rule 19 (Variable -> ID .)
    PLUS            reduce using rule 19 (Variable -> ID .)
    MINUS           reduce using rule 19 (Variable -> ID .)
    TIMES           reduce using rule 19 (Variable -> ID .)
    DIVIDE          reduce using rule 19 (Variable -> ID .)
    THEN            reduce using rule 19 (Variable -> ID .)
    AND             reduce using rule 19 (Variable -> ID .)
    OR              reduce using rule 19 (Variable -> ID .)
    DO              reduce using rule 19 (Variable -> ID .)
    OF              reduce using rule 19 (Variable -> ID .)
    RPAREN          reduce using rule 19 (Variable -> ID .)
    END             reduce using rule 19 (Variable -> ID .)
    SEMICOLON       reduce using rule 19 (Variable -> ID .)
    ELSE            reduce using rule 19 (Variable -> ID .)
    TO              reduce using rule 19 (Variable -> ID .)
    DOWNTO          reduce using rule 19 (Variable -> ID .)


state 18

    (60) compound_statement -> BEGIN StateList . END
    (22) StateList -> StateList . SEMICOLON Statement

    END             shift and go to state 48
    SEMICOLON       shift and go to state 49


state 19

    (23) StateList -> Statement .

    END             reduce using rule 23 (StateList -> Statement .)
    SEMICOLON       reduce using rule 23 (StateList -> Statement .)


state 20

    (24) Statement -> open_statement .

    END             reduce using rule 24 (Statement -> open_statement .)
    SEMICOLON       reduce using rule 24 (Statement -> open_statement .)


state 21

    (25) Statement -> closed_statement .

    END             reduce using rule 25 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 25 (Statement -> closed_statement .)


state 22

    (26) open_statement -> label . COLON non_labeled_open_statement
    (28) closed_statement -> label . COLON non_labeled_closed_statement

    COLON           shift and go to state 50


state 23

    (27) open_statement -> non_labeled_open_statement .

    END             reduce using rule 27 (open_statement -> non_labeled_open_statement .)
    SEMICOLON       reduce using rule 27 (open_statement -> non_labeled_open_statement .)


state 24

    (29) closed_statement -> non_labeled_closed_statement .

    END             reduce using rule 29 (closed_statement -> non_labeled_closed_statement .)
    SEMICOLON       reduce using rule 29 (closed_statement -> non_labeled_closed_statement .)
    ELSE            reduce using rule 29 (closed_statement -> non_labeled_closed_statement .)


state 25

    (62) label -> DIGSEQ .

    COLON           reduce using rule 62 (label -> DIGSEQ .)
    END             reduce using rule 62 (label -> DIGSEQ .)
    SEMICOLON       reduce using rule 62 (label -> DIGSEQ .)
    ELSE            reduce using rule 62 (label -> DIGSEQ .)


state 26

    (30) non_labeled_open_statement -> open_if_statement .

    END             reduce using rule 30 (non_labeled_open_statement -> open_if_statement .)
    SEMICOLON       reduce using rule 30 (non_labeled_open_statement -> open_if_statement .)


state 27

    (31) non_labeled_open_statement -> open_while_statement .

    END             reduce using rule 31 (non_labeled_open_statement -> open_while_statement .)
    SEMICOLON       reduce using rule 31 (non_labeled_open_statement -> open_while_statement .)


state 28

    (32) non_labeled_open_statement -> open_for_statement .

    END             reduce using rule 32 (non_labeled_open_statement -> open_for_statement .)
    SEMICOLON       reduce using rule 32 (non_labeled_open_statement -> open_for_statement .)


state 29

    (33) non_labeled_closed_statement -> assignment_statement .

    END             reduce using rule 33 (non_labeled_closed_statement -> assignment_statement .)
    SEMICOLON       reduce using rule 33 (non_labeled_closed_statement -> assignment_statement .)
    ELSE            reduce using rule 33 (non_labeled_closed_statement -> assignment_statement .)


state 30

    (34) non_labeled_closed_statement -> compound_statement .

    END             reduce using rule 34 (non_labeled_closed_statement -> compound_statement .)
    SEMICOLON       reduce using rule 34 (non_labeled_closed_statement -> compound_statement .)
    ELSE            reduce using rule 34 (non_labeled_closed_statement -> compound_statement .)


state 31

    (35) non_labeled_closed_statement -> closed_if_statement .

    END             reduce using rule 35 (non_labeled_closed_statement -> closed_if_statement .)
    SEMICOLON       reduce using rule 35 (non_labeled_closed_statement -> closed_if_statement .)
    ELSE            reduce using rule 35 (non_labeled_closed_statement -> closed_if_statement .)


state 32

    (36) non_labeled_closed_statement -> closed_while_statement .

    END             reduce using rule 36 (non_labeled_closed_statement -> closed_while_statement .)
    SEMICOLON       reduce using rule 36 (non_labeled_closed_statement -> closed_while_statement .)
    ELSE            reduce using rule 36 (non_labeled_closed_statement -> closed_while_statement .)


state 33

    (37) non_labeled_closed_statement -> closed_for_statement .

    END             reduce using rule 37 (non_labeled_closed_statement -> closed_for_statement .)
    SEMICOLON       reduce using rule 37 (non_labeled_closed_statement -> closed_for_statement .)
    ELSE            reduce using rule 37 (non_labeled_closed_statement -> closed_for_statement .)


state 34

    (38) non_labeled_closed_statement -> goto_statement .

    END             reduce using rule 38 (non_labeled_closed_statement -> goto_statement .)
    SEMICOLON       reduce using rule 38 (non_labeled_closed_statement -> goto_statement .)
    ELSE            reduce using rule 38 (non_labeled_closed_statement -> goto_statement .)


state 35

    (39) non_labeled_closed_statement -> empty .

    END             reduce using rule 39 (non_labeled_closed_statement -> empty .)
    SEMICOLON       reduce using rule 39 (non_labeled_closed_statement -> empty .)
    ELSE            reduce using rule 39 (non_labeled_closed_statement -> empty .)


state 36

    (40) non_labeled_closed_statement -> case_statement .

    END             reduce using rule 40 (non_labeled_closed_statement -> case_statement .)
    SEMICOLON       reduce using rule 40 (non_labeled_closed_statement -> case_statement .)
    ELSE            reduce using rule 40 (non_labeled_closed_statement -> case_statement .)


state 37

    (48) open_if_statement -> IF . BoolExpr THEN Statement
    (49) open_if_statement -> IF . BoolExpr THEN closed_statement ELSE open_statement
    (50) closed_if_statement -> IF . BoolExpr THEN closed_statement ELSE closed_statement
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 53
    LPAREN          shift and go to state 54
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    BoolExpr                       shift and go to state 51
    Expr                           shift and go to state 52
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 38

    (51) open_while_statement -> WHILE . BoolExpr DO open_statement
    (52) closed_while_statement -> WHILE . BoolExpr DO closed_statement
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 53
    LPAREN          shift and go to state 54
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    BoolExpr                       shift and go to state 60
    Expr                           shift and go to state 52
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 39

    (53) open_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (54) closed_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (19) Variable -> . ID

    ID              shift and go to state 17

    Variable                       shift and go to state 61

state 40

    (59) assignment_statement -> Variable . ASSIGNMENT Expr

    ASSIGNMENT      shift and go to state 62


state 41

    (61) goto_statement -> GOTO . label
    (62) label -> . DIGSEQ

    DIGSEQ          shift and go to state 25

    label                          shift and go to state 63

state 42

    (41) case_statement -> CASE . case_index OF case_element_list END
    (42) case_statement -> CASE . case_index OF case_element_list SEMICOLON END
    (43) case_index -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    case_index                     shift and go to state 64
    Expr                           shift and go to state 65
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 43

    (3) VarDef -> VAR VarDefList SEMICOLON .
    (4) VarDefList -> VarDefList SEMICOLON . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    BEGIN           reduce using rule 3 (VarDef -> VAR VarDefList SEMICOLON .)
    TYPE            shift and go to state 16
    ID              shift and go to state 17

    VarDefState                    shift and go to state 67
    VarList                        shift and go to state 13
    ArrayDefState                  shift and go to state 14
    Variable                       shift and go to state 15

state 44

    (6) VarDefState -> VarList COLON . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 69
    REAL            shift and go to state 70
    BOOLEAN         shift and go to state 71
    ID              shift and go to state 47

    Type                           shift and go to state 68
    arrayName                      shift and go to state 72

state 45

    (8) VarList -> VarList COMMA . Variable
    (19) Variable -> . ID

    ID              shift and go to state 17

    Variable                       shift and go to state 73

state 46

    (10) ArrayDefState -> TYPE arrayName . EQ ARRAY LBRAC index_list RBRAC OF Type

    EQ              shift and go to state 74


state 47

    (11) arrayName -> ID .

    EQ              reduce using rule 11 (arrayName -> ID .)
    SEMICOLON       reduce using rule 11 (arrayName -> ID .)


state 48

    (60) compound_statement -> BEGIN StateList END .

    ENDPOINT        reduce using rule 60 (compound_statement -> BEGIN StateList END .)
    END             reduce using rule 60 (compound_statement -> BEGIN StateList END .)
    SEMICOLON       reduce using rule 60 (compound_statement -> BEGIN StateList END .)
    ELSE            reduce using rule 60 (compound_statement -> BEGIN StateList END .)


state 49

    (22) StateList -> StateList SEMICOLON . Statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 10
    GOTO            shift and go to state 41
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    Statement                      shift and go to state 75
    open_statement                 shift and go to state 20
    closed_statement               shift and go to state 21
    label                          shift and go to state 22
    non_labeled_open_statement     shift and go to state 23
    non_labeled_closed_statement   shift and go to state 24
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    Variable                       shift and go to state 40

state 50

    (26) open_statement -> label COLON . non_labeled_open_statement
    (28) closed_statement -> label COLON . non_labeled_closed_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 10
    GOTO            shift and go to state 41
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    ELSE            reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    non_labeled_open_statement     shift and go to state 76
    non_labeled_closed_statement   shift and go to state 77
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    Variable                       shift and go to state 40

state 51

    (48) open_if_statement -> IF BoolExpr . THEN Statement
    (49) open_if_statement -> IF BoolExpr . THEN closed_statement ELSE open_statement
    (50) closed_if_statement -> IF BoolExpr . THEN closed_statement ELSE closed_statement
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

    THEN            shift and go to state 78
    AND             shift and go to state 79
    OR              shift and go to state 80


state 52

    (73) BoolExpr -> Expr . LT Expr
    (74) BoolExpr -> Expr . LE Expr
    (75) BoolExpr -> Expr . GT Expr
    (76) BoolExpr -> Expr . GE Expr
    (77) BoolExpr -> Expr . EQ Expr
    (78) BoolExpr -> Expr . NE Expr
    (83) BoolExpr -> Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              shift and go to state 81
    LE              shift and go to state 82
    GT              shift and go to state 83
    GE              shift and go to state 84
    EQ              shift and go to state 85
    NE              shift and go to state 86
    THEN            reduce using rule 83 (BoolExpr -> Expr .)
    AND             reduce using rule 83 (BoolExpr -> Expr .)
    OR              reduce using rule 83 (BoolExpr -> Expr .)
    DO              reduce using rule 83 (BoolExpr -> Expr .)
    RPAREN          reduce using rule 83 (BoolExpr -> Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 53

    (81) BoolExpr -> NOT . BoolExpr
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 53
    LPAREN          shift and go to state 54
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    BoolExpr                       shift and go to state 91
    Expr                           shift and go to state 52
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 54

    (82) BoolExpr -> LPAREN . BoolExpr RPAREN
    (67) Expr -> LPAREN . Expr RPAREN
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 53
    LPAREN          shift and go to state 54
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    BoolExpr                       shift and go to state 92
    Expr                           shift and go to state 93
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 55

    (68) Expr -> MINUS . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 94
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 56

    (69) Expr -> Variable .

    LT              reduce using rule 69 (Expr -> Variable .)
    LE              reduce using rule 69 (Expr -> Variable .)
    GT              reduce using rule 69 (Expr -> Variable .)
    GE              reduce using rule 69 (Expr -> Variable .)
    EQ              reduce using rule 69 (Expr -> Variable .)
    NE              reduce using rule 69 (Expr -> Variable .)
    PLUS            reduce using rule 69 (Expr -> Variable .)
    MINUS           reduce using rule 69 (Expr -> Variable .)
    TIMES           reduce using rule 69 (Expr -> Variable .)
    DIVIDE          reduce using rule 69 (Expr -> Variable .)
    THEN            reduce using rule 69 (Expr -> Variable .)
    AND             reduce using rule 69 (Expr -> Variable .)
    OR              reduce using rule 69 (Expr -> Variable .)
    DO              reduce using rule 69 (Expr -> Variable .)
    OF              reduce using rule 69 (Expr -> Variable .)
    RPAREN          reduce using rule 69 (Expr -> Variable .)
    END             reduce using rule 69 (Expr -> Variable .)
    SEMICOLON       reduce using rule 69 (Expr -> Variable .)
    ELSE            reduce using rule 69 (Expr -> Variable .)
    TO              reduce using rule 69 (Expr -> Variable .)
    DOWNTO          reduce using rule 69 (Expr -> Variable .)


state 57

    (70) Expr -> const .

    LT              reduce using rule 70 (Expr -> const .)
    LE              reduce using rule 70 (Expr -> const .)
    GT              reduce using rule 70 (Expr -> const .)
    GE              reduce using rule 70 (Expr -> const .)
    EQ              reduce using rule 70 (Expr -> const .)
    NE              reduce using rule 70 (Expr -> const .)
    PLUS            reduce using rule 70 (Expr -> const .)
    MINUS           reduce using rule 70 (Expr -> const .)
    TIMES           reduce using rule 70 (Expr -> const .)
    DIVIDE          reduce using rule 70 (Expr -> const .)
    THEN            reduce using rule 70 (Expr -> const .)
    AND             reduce using rule 70 (Expr -> const .)
    OR              reduce using rule 70 (Expr -> const .)
    DO              reduce using rule 70 (Expr -> const .)
    OF              reduce using rule 70 (Expr -> const .)
    RPAREN          reduce using rule 70 (Expr -> const .)
    END             reduce using rule 70 (Expr -> const .)
    SEMICOLON       reduce using rule 70 (Expr -> const .)
    ELSE            reduce using rule 70 (Expr -> const .)
    TO              reduce using rule 70 (Expr -> const .)
    DOWNTO          reduce using rule 70 (Expr -> const .)


state 58

    (71) const -> INT_NUMBER .

    LT              reduce using rule 71 (const -> INT_NUMBER .)
    LE              reduce using rule 71 (const -> INT_NUMBER .)
    GT              reduce using rule 71 (const -> INT_NUMBER .)
    GE              reduce using rule 71 (const -> INT_NUMBER .)
    EQ              reduce using rule 71 (const -> INT_NUMBER .)
    NE              reduce using rule 71 (const -> INT_NUMBER .)
    PLUS            reduce using rule 71 (const -> INT_NUMBER .)
    MINUS           reduce using rule 71 (const -> INT_NUMBER .)
    TIMES           reduce using rule 71 (const -> INT_NUMBER .)
    DIVIDE          reduce using rule 71 (const -> INT_NUMBER .)
    THEN            reduce using rule 71 (const -> INT_NUMBER .)
    AND             reduce using rule 71 (const -> INT_NUMBER .)
    OR              reduce using rule 71 (const -> INT_NUMBER .)
    DO              reduce using rule 71 (const -> INT_NUMBER .)
    OF              reduce using rule 71 (const -> INT_NUMBER .)
    RPAREN          reduce using rule 71 (const -> INT_NUMBER .)
    END             reduce using rule 71 (const -> INT_NUMBER .)
    SEMICOLON       reduce using rule 71 (const -> INT_NUMBER .)
    ELSE            reduce using rule 71 (const -> INT_NUMBER .)
    TO              reduce using rule 71 (const -> INT_NUMBER .)
    DOWNTO          reduce using rule 71 (const -> INT_NUMBER .)
    COLON           reduce using rule 71 (const -> INT_NUMBER .)
    DOTDOT          reduce using rule 71 (const -> INT_NUMBER .)
    RBRAC           reduce using rule 71 (const -> INT_NUMBER .)
    COMMA           reduce using rule 71 (const -> INT_NUMBER .)


state 59

    (72) const -> REAL_NUMBER .

    LT              reduce using rule 72 (const -> REAL_NUMBER .)
    LE              reduce using rule 72 (const -> REAL_NUMBER .)
    GT              reduce using rule 72 (const -> REAL_NUMBER .)
    GE              reduce using rule 72 (const -> REAL_NUMBER .)
    EQ              reduce using rule 72 (const -> REAL_NUMBER .)
    NE              reduce using rule 72 (const -> REAL_NUMBER .)
    PLUS            reduce using rule 72 (const -> REAL_NUMBER .)
    MINUS           reduce using rule 72 (const -> REAL_NUMBER .)
    TIMES           reduce using rule 72 (const -> REAL_NUMBER .)
    DIVIDE          reduce using rule 72 (const -> REAL_NUMBER .)
    THEN            reduce using rule 72 (const -> REAL_NUMBER .)
    AND             reduce using rule 72 (const -> REAL_NUMBER .)
    OR              reduce using rule 72 (const -> REAL_NUMBER .)
    DO              reduce using rule 72 (const -> REAL_NUMBER .)
    OF              reduce using rule 72 (const -> REAL_NUMBER .)
    RPAREN          reduce using rule 72 (const -> REAL_NUMBER .)
    END             reduce using rule 72 (const -> REAL_NUMBER .)
    SEMICOLON       reduce using rule 72 (const -> REAL_NUMBER .)
    ELSE            reduce using rule 72 (const -> REAL_NUMBER .)
    TO              reduce using rule 72 (const -> REAL_NUMBER .)
    DOWNTO          reduce using rule 72 (const -> REAL_NUMBER .)
    COLON           reduce using rule 72 (const -> REAL_NUMBER .)
    DOTDOT          reduce using rule 72 (const -> REAL_NUMBER .)
    RBRAC           reduce using rule 72 (const -> REAL_NUMBER .)
    COMMA           reduce using rule 72 (const -> REAL_NUMBER .)


state 60

    (51) open_while_statement -> WHILE BoolExpr . DO open_statement
    (52) closed_while_statement -> WHILE BoolExpr . DO closed_statement
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

    DO              shift and go to state 95
    AND             shift and go to state 79
    OR              shift and go to state 80


state 61

    (53) open_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO open_statement
    (54) closed_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO closed_statement

    ASSIGNMENT      shift and go to state 96


state 62

    (59) assignment_statement -> Variable ASSIGNMENT . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Variable                       shift and go to state 56
    Expr                           shift and go to state 97
    const                          shift and go to state 57

state 63

    (61) goto_statement -> GOTO label .

    END             reduce using rule 61 (goto_statement -> GOTO label .)
    SEMICOLON       reduce using rule 61 (goto_statement -> GOTO label .)
    ELSE            reduce using rule 61 (goto_statement -> GOTO label .)


state 64

    (41) case_statement -> CASE case_index . OF case_element_list END
    (42) case_statement -> CASE case_index . OF case_element_list SEMICOLON END

    OF              shift and go to state 98


state 65

    (43) case_index -> Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    OF              reduce using rule 43 (case_index -> Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 66

    (67) Expr -> LPAREN . Expr RPAREN
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 99
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 67

    (4) VarDefList -> VarDefList SEMICOLON VarDefState .

    SEMICOLON       reduce using rule 4 (VarDefList -> VarDefList SEMICOLON VarDefState .)


state 68

    (6) VarDefState -> VarList COLON Type .

    SEMICOLON       reduce using rule 6 (VarDefState -> VarList COLON Type .)


state 69

    (15) Type -> INTEGER .

    SEMICOLON       reduce using rule 15 (Type -> INTEGER .)


state 70

    (16) Type -> REAL .

    SEMICOLON       reduce using rule 16 (Type -> REAL .)


state 71

    (17) Type -> BOOLEAN .

    SEMICOLON       reduce using rule 17 (Type -> BOOLEAN .)


state 72

    (18) Type -> arrayName .

    SEMICOLON       reduce using rule 18 (Type -> arrayName .)


state 73

    (8) VarList -> VarList COMMA Variable .

    COLON           reduce using rule 8 (VarList -> VarList COMMA Variable .)
    COMMA           reduce using rule 8 (VarList -> VarList COMMA Variable .)


state 74

    (10) ArrayDefState -> TYPE arrayName EQ . ARRAY LBRAC index_list RBRAC OF Type

    ARRAY           shift and go to state 100


state 75

    (22) StateList -> StateList SEMICOLON Statement .

    END             reduce using rule 22 (StateList -> StateList SEMICOLON Statement .)
    SEMICOLON       reduce using rule 22 (StateList -> StateList SEMICOLON Statement .)


state 76

    (26) open_statement -> label COLON non_labeled_open_statement .

    END             reduce using rule 26 (open_statement -> label COLON non_labeled_open_statement .)
    SEMICOLON       reduce using rule 26 (open_statement -> label COLON non_labeled_open_statement .)


state 77

    (28) closed_statement -> label COLON non_labeled_closed_statement .

    END             reduce using rule 28 (closed_statement -> label COLON non_labeled_closed_statement .)
    SEMICOLON       reduce using rule 28 (closed_statement -> label COLON non_labeled_closed_statement .)
    ELSE            reduce using rule 28 (closed_statement -> label COLON non_labeled_closed_statement .)


state 78

    (48) open_if_statement -> IF BoolExpr THEN . Statement
    (49) open_if_statement -> IF BoolExpr THEN . closed_statement ELSE open_statement
    (50) closed_if_statement -> IF BoolExpr THEN . closed_statement ELSE closed_statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (62) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    BEGIN           shift and go to state 10
    IF              shift and go to state 101
    WHILE           shift and go to state 105
    FOR             shift and go to state 106
    GOTO            shift and go to state 41
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    Statement                      shift and go to state 102
    closed_statement               shift and go to state 103
    open_statement                 shift and go to state 20
    label                          shift and go to state 104
    non_labeled_closed_statement   shift and go to state 24
    non_labeled_open_statement     shift and go to state 23
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
    Variable                       shift and go to state 40

state 79

    (79) BoolExpr -> BoolExpr AND . BoolExpr
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 53
    LPAREN          shift and go to state 54
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    BoolExpr                       shift and go to state 107
    Expr                           shift and go to state 52
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 80

    (80) BoolExpr -> BoolExpr OR . BoolExpr
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 53
    LPAREN          shift and go to state 54
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    BoolExpr                       shift and go to state 108
    Expr                           shift and go to state 52
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 81

    (73) BoolExpr -> Expr LT . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 109
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 82

    (74) BoolExpr -> Expr LE . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 110
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 83

    (75) BoolExpr -> Expr GT . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 111
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 84

    (76) BoolExpr -> Expr GE . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 112
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 85

    (77) BoolExpr -> Expr EQ . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 113
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 86

    (78) BoolExpr -> Expr NE . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 114
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 87

    (63) Expr -> Expr PLUS . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 115
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 88

    (64) Expr -> Expr MINUS . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 116
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 89

    (65) Expr -> Expr TIMES . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 117
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 90

    (66) Expr -> Expr DIVIDE . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Expr                           shift and go to state 118
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 91

    (81) BoolExpr -> NOT BoolExpr .
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 81 (BoolExpr -> NOT BoolExpr .)
    DO              reduce using rule 81 (BoolExpr -> NOT BoolExpr .)
    RPAREN          reduce using rule 81 (BoolExpr -> NOT BoolExpr .)
    AND             shift and go to state 79
    OR              shift and go to state 80

  ! AND             [ reduce using rule 81 (BoolExpr -> NOT BoolExpr .) ]
  ! OR              [ reduce using rule 81 (BoolExpr -> NOT BoolExpr .) ]


state 92

    (82) BoolExpr -> LPAREN BoolExpr . RPAREN
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

    RPAREN          shift and go to state 119
    AND             shift and go to state 79
    OR              shift and go to state 80


state 93

    (67) Expr -> LPAREN Expr . RPAREN
    (73) BoolExpr -> Expr . LT Expr
    (74) BoolExpr -> Expr . LE Expr
    (75) BoolExpr -> Expr . GT Expr
    (76) BoolExpr -> Expr . GE Expr
    (77) BoolExpr -> Expr . EQ Expr
    (78) BoolExpr -> Expr . NE Expr
    (83) BoolExpr -> Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 120
    LT              shift and go to state 81
    LE              shift and go to state 82
    GT              shift and go to state 83
    GE              shift and go to state 84
    EQ              shift and go to state 85
    NE              shift and go to state 86
    AND             reduce using rule 83 (BoolExpr -> Expr .)
    OR              reduce using rule 83 (BoolExpr -> Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90

  ! RPAREN          [ reduce using rule 83 (BoolExpr -> Expr .) ]


state 94

    (68) Expr -> MINUS Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 68 (Expr -> MINUS Expr .)
    LE              reduce using rule 68 (Expr -> MINUS Expr .)
    GT              reduce using rule 68 (Expr -> MINUS Expr .)
    GE              reduce using rule 68 (Expr -> MINUS Expr .)
    EQ              reduce using rule 68 (Expr -> MINUS Expr .)
    NE              reduce using rule 68 (Expr -> MINUS Expr .)
    PLUS            reduce using rule 68 (Expr -> MINUS Expr .)
    MINUS           reduce using rule 68 (Expr -> MINUS Expr .)
    TIMES           reduce using rule 68 (Expr -> MINUS Expr .)
    DIVIDE          reduce using rule 68 (Expr -> MINUS Expr .)
    THEN            reduce using rule 68 (Expr -> MINUS Expr .)
    AND             reduce using rule 68 (Expr -> MINUS Expr .)
    OR              reduce using rule 68 (Expr -> MINUS Expr .)
    DO              reduce using rule 68 (Expr -> MINUS Expr .)
    OF              reduce using rule 68 (Expr -> MINUS Expr .)
    RPAREN          reduce using rule 68 (Expr -> MINUS Expr .)
    END             reduce using rule 68 (Expr -> MINUS Expr .)
    SEMICOLON       reduce using rule 68 (Expr -> MINUS Expr .)
    ELSE            reduce using rule 68 (Expr -> MINUS Expr .)
    TO              reduce using rule 68 (Expr -> MINUS Expr .)
    DOWNTO          reduce using rule 68 (Expr -> MINUS Expr .)

  ! PLUS            [ shift and go to state 87 ]
  ! MINUS           [ shift and go to state 88 ]
  ! TIMES           [ shift and go to state 89 ]
  ! DIVIDE          [ shift and go to state 90 ]


state 95

    (51) open_while_statement -> WHILE BoolExpr DO . open_statement
    (52) closed_while_statement -> WHILE BoolExpr DO . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 10
    GOTO            shift and go to state 41
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    ELSE            reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    open_statement                 shift and go to state 121
    closed_statement               shift and go to state 122
    label                          shift and go to state 22
    non_labeled_open_statement     shift and go to state 23
    non_labeled_closed_statement   shift and go to state 24
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    Variable                       shift and go to state 40

state 96

    (53) open_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO open_statement
    (54) closed_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO closed_statement
    (55) initial_value -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Variable                       shift and go to state 56
    initial_value                  shift and go to state 123
    Expr                           shift and go to state 124
    const                          shift and go to state 57

state 97

    (59) assignment_statement -> Variable ASSIGNMENT Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    END             reduce using rule 59 (assignment_statement -> Variable ASSIGNMENT Expr .)
    SEMICOLON       reduce using rule 59 (assignment_statement -> Variable ASSIGNMENT Expr .)
    ELSE            reduce using rule 59 (assignment_statement -> Variable ASSIGNMENT Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 98

    (41) case_statement -> CASE case_index OF . case_element_list END
    (42) case_statement -> CASE case_index OF . case_element_list SEMICOLON END
    (44) case_element_list -> . case_element_list SEMICOLON case_element
    (45) case_element_list -> . case_element
    (46) case_element -> . case_constant COLON Statement
    (47) case_constant -> . const
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    case_element_list              shift and go to state 125
    case_element                   shift and go to state 126
    case_constant                  shift and go to state 127
    const                          shift and go to state 128

state 99

    (67) Expr -> LPAREN Expr . RPAREN
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    RPAREN          shift and go to state 120
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 100

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY . LBRAC index_list RBRAC OF Type

    LBRAC           shift and go to state 129


state 101

    (50) closed_if_statement -> IF . BoolExpr THEN closed_statement ELSE closed_statement
    (48) open_if_statement -> IF . BoolExpr THEN Statement
    (49) open_if_statement -> IF . BoolExpr THEN closed_statement ELSE open_statement
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 53
    LPAREN          shift and go to state 54
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    BoolExpr                       shift and go to state 130
    Expr                           shift and go to state 52
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 102

    (48) open_if_statement -> IF BoolExpr THEN Statement .

    END             reduce using rule 48 (open_if_statement -> IF BoolExpr THEN Statement .)
    SEMICOLON       reduce using rule 48 (open_if_statement -> IF BoolExpr THEN Statement .)


state 103

    (49) open_if_statement -> IF BoolExpr THEN closed_statement . ELSE open_statement
    (50) closed_if_statement -> IF BoolExpr THEN closed_statement . ELSE closed_statement
    (25) Statement -> closed_statement .

    ELSE            shift and go to state 131
    END             reduce using rule 25 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 25 (Statement -> closed_statement .)


state 104

    (28) closed_statement -> label . COLON non_labeled_closed_statement
    (26) open_statement -> label . COLON non_labeled_open_statement

    COLON           shift and go to state 132


state 105

    (52) closed_while_statement -> WHILE . BoolExpr DO closed_statement
    (51) open_while_statement -> WHILE . BoolExpr DO open_statement
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 53
    LPAREN          shift and go to state 54
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    BoolExpr                       shift and go to state 133
    Expr                           shift and go to state 52
    Variable                       shift and go to state 56
    const                          shift and go to state 57

state 106

    (54) closed_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (53) open_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    ID              shift and go to state 17

    Variable                       shift and go to state 134

state 107

    (79) BoolExpr -> BoolExpr AND BoolExpr .
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 79 (BoolExpr -> BoolExpr AND BoolExpr .)
    DO              reduce using rule 79 (BoolExpr -> BoolExpr AND BoolExpr .)
    RPAREN          reduce using rule 79 (BoolExpr -> BoolExpr AND BoolExpr .)
    AND             shift and go to state 79
    OR              shift and go to state 80

  ! AND             [ reduce using rule 79 (BoolExpr -> BoolExpr AND BoolExpr .) ]
  ! OR              [ reduce using rule 79 (BoolExpr -> BoolExpr AND BoolExpr .) ]


state 108

    (80) BoolExpr -> BoolExpr OR BoolExpr .
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 80 (BoolExpr -> BoolExpr OR BoolExpr .)
    DO              reduce using rule 80 (BoolExpr -> BoolExpr OR BoolExpr .)
    RPAREN          reduce using rule 80 (BoolExpr -> BoolExpr OR BoolExpr .)
    AND             shift and go to state 79
    OR              shift and go to state 80

  ! AND             [ reduce using rule 80 (BoolExpr -> BoolExpr OR BoolExpr .) ]
  ! OR              [ reduce using rule 80 (BoolExpr -> BoolExpr OR BoolExpr .) ]


state 109

    (73) BoolExpr -> Expr LT Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 73 (BoolExpr -> Expr LT Expr .)
    AND             reduce using rule 73 (BoolExpr -> Expr LT Expr .)
    OR              reduce using rule 73 (BoolExpr -> Expr LT Expr .)
    DO              reduce using rule 73 (BoolExpr -> Expr LT Expr .)
    RPAREN          reduce using rule 73 (BoolExpr -> Expr LT Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 110

    (74) BoolExpr -> Expr LE Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 74 (BoolExpr -> Expr LE Expr .)
    AND             reduce using rule 74 (BoolExpr -> Expr LE Expr .)
    OR              reduce using rule 74 (BoolExpr -> Expr LE Expr .)
    DO              reduce using rule 74 (BoolExpr -> Expr LE Expr .)
    RPAREN          reduce using rule 74 (BoolExpr -> Expr LE Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 111

    (75) BoolExpr -> Expr GT Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 75 (BoolExpr -> Expr GT Expr .)
    AND             reduce using rule 75 (BoolExpr -> Expr GT Expr .)
    OR              reduce using rule 75 (BoolExpr -> Expr GT Expr .)
    DO              reduce using rule 75 (BoolExpr -> Expr GT Expr .)
    RPAREN          reduce using rule 75 (BoolExpr -> Expr GT Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 112

    (76) BoolExpr -> Expr GE Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 76 (BoolExpr -> Expr GE Expr .)
    AND             reduce using rule 76 (BoolExpr -> Expr GE Expr .)
    OR              reduce using rule 76 (BoolExpr -> Expr GE Expr .)
    DO              reduce using rule 76 (BoolExpr -> Expr GE Expr .)
    RPAREN          reduce using rule 76 (BoolExpr -> Expr GE Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 113

    (77) BoolExpr -> Expr EQ Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 77 (BoolExpr -> Expr EQ Expr .)
    AND             reduce using rule 77 (BoolExpr -> Expr EQ Expr .)
    OR              reduce using rule 77 (BoolExpr -> Expr EQ Expr .)
    DO              reduce using rule 77 (BoolExpr -> Expr EQ Expr .)
    RPAREN          reduce using rule 77 (BoolExpr -> Expr EQ Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 114

    (78) BoolExpr -> Expr NE Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 78 (BoolExpr -> Expr NE Expr .)
    AND             reduce using rule 78 (BoolExpr -> Expr NE Expr .)
    OR              reduce using rule 78 (BoolExpr -> Expr NE Expr .)
    DO              reduce using rule 78 (BoolExpr -> Expr NE Expr .)
    RPAREN          reduce using rule 78 (BoolExpr -> Expr NE Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 115

    (63) Expr -> Expr PLUS Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    LE              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    GT              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    GE              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    EQ              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    NE              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    PLUS            reduce using rule 63 (Expr -> Expr PLUS Expr .)
    MINUS           reduce using rule 63 (Expr -> Expr PLUS Expr .)
    THEN            reduce using rule 63 (Expr -> Expr PLUS Expr .)
    AND             reduce using rule 63 (Expr -> Expr PLUS Expr .)
    OR              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    DO              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    OF              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    RPAREN          reduce using rule 63 (Expr -> Expr PLUS Expr .)
    END             reduce using rule 63 (Expr -> Expr PLUS Expr .)
    SEMICOLON       reduce using rule 63 (Expr -> Expr PLUS Expr .)
    ELSE            reduce using rule 63 (Expr -> Expr PLUS Expr .)
    TO              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    DOWNTO          reduce using rule 63 (Expr -> Expr PLUS Expr .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90

  ! TIMES           [ reduce using rule 63 (Expr -> Expr PLUS Expr .) ]
  ! DIVIDE          [ reduce using rule 63 (Expr -> Expr PLUS Expr .) ]
  ! PLUS            [ shift and go to state 87 ]
  ! MINUS           [ shift and go to state 88 ]


state 116

    (64) Expr -> Expr MINUS Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    LE              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    GT              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    GE              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    EQ              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    NE              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    PLUS            reduce using rule 64 (Expr -> Expr MINUS Expr .)
    MINUS           reduce using rule 64 (Expr -> Expr MINUS Expr .)
    THEN            reduce using rule 64 (Expr -> Expr MINUS Expr .)
    AND             reduce using rule 64 (Expr -> Expr MINUS Expr .)
    OR              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    DO              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    OF              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    RPAREN          reduce using rule 64 (Expr -> Expr MINUS Expr .)
    END             reduce using rule 64 (Expr -> Expr MINUS Expr .)
    SEMICOLON       reduce using rule 64 (Expr -> Expr MINUS Expr .)
    ELSE            reduce using rule 64 (Expr -> Expr MINUS Expr .)
    TO              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    DOWNTO          reduce using rule 64 (Expr -> Expr MINUS Expr .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90

  ! TIMES           [ reduce using rule 64 (Expr -> Expr MINUS Expr .) ]
  ! DIVIDE          [ reduce using rule 64 (Expr -> Expr MINUS Expr .) ]
  ! PLUS            [ shift and go to state 87 ]
  ! MINUS           [ shift and go to state 88 ]


state 117

    (65) Expr -> Expr TIMES Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    LE              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    GT              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    GE              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    EQ              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    NE              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    PLUS            reduce using rule 65 (Expr -> Expr TIMES Expr .)
    MINUS           reduce using rule 65 (Expr -> Expr TIMES Expr .)
    TIMES           reduce using rule 65 (Expr -> Expr TIMES Expr .)
    DIVIDE          reduce using rule 65 (Expr -> Expr TIMES Expr .)
    THEN            reduce using rule 65 (Expr -> Expr TIMES Expr .)
    AND             reduce using rule 65 (Expr -> Expr TIMES Expr .)
    OR              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    DO              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    OF              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    RPAREN          reduce using rule 65 (Expr -> Expr TIMES Expr .)
    END             reduce using rule 65 (Expr -> Expr TIMES Expr .)
    SEMICOLON       reduce using rule 65 (Expr -> Expr TIMES Expr .)
    ELSE            reduce using rule 65 (Expr -> Expr TIMES Expr .)
    TO              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    DOWNTO          reduce using rule 65 (Expr -> Expr TIMES Expr .)

  ! PLUS            [ shift and go to state 87 ]
  ! MINUS           [ shift and go to state 88 ]
  ! TIMES           [ shift and go to state 89 ]
  ! DIVIDE          [ shift and go to state 90 ]


state 118

    (66) Expr -> Expr DIVIDE Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    LE              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    GT              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    GE              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    EQ              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    NE              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    PLUS            reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    MINUS           reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    TIMES           reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    DIVIDE          reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    THEN            reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    AND             reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    OR              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    DO              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    OF              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    RPAREN          reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    END             reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    SEMICOLON       reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    ELSE            reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    TO              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    DOWNTO          reduce using rule 66 (Expr -> Expr DIVIDE Expr .)

  ! PLUS            [ shift and go to state 87 ]
  ! MINUS           [ shift and go to state 88 ]
  ! TIMES           [ shift and go to state 89 ]
  ! DIVIDE          [ shift and go to state 90 ]


state 119

    (82) BoolExpr -> LPAREN BoolExpr RPAREN .

    THEN            reduce using rule 82 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    AND             reduce using rule 82 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    OR              reduce using rule 82 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    DO              reduce using rule 82 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    RPAREN          reduce using rule 82 (BoolExpr -> LPAREN BoolExpr RPAREN .)


state 120

    (67) Expr -> LPAREN Expr RPAREN .

    LT              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    LE              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    GT              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    GE              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    EQ              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    NE              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    PLUS            reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    MINUS           reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    TIMES           reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    DIVIDE          reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    THEN            reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    AND             reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    OR              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    DO              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    OF              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    RPAREN          reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    END             reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    SEMICOLON       reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    ELSE            reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    TO              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    DOWNTO          reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)


state 121

    (51) open_while_statement -> WHILE BoolExpr DO open_statement .

    END             reduce using rule 51 (open_while_statement -> WHILE BoolExpr DO open_statement .)
    SEMICOLON       reduce using rule 51 (open_while_statement -> WHILE BoolExpr DO open_statement .)


state 122

    (52) closed_while_statement -> WHILE BoolExpr DO closed_statement .

    END             reduce using rule 52 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)
    SEMICOLON       reduce using rule 52 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)
    ELSE            reduce using rule 52 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)


state 123

    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO open_statement
    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO closed_statement
    (57) direction -> . TO
    (58) direction -> . DOWNTO

    TO              shift and go to state 136
    DOWNTO          shift and go to state 137

    direction                      shift and go to state 135

state 124

    (55) initial_value -> Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    TO              reduce using rule 55 (initial_value -> Expr .)
    DOWNTO          reduce using rule 55 (initial_value -> Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 125

    (41) case_statement -> CASE case_index OF case_element_list . END
    (42) case_statement -> CASE case_index OF case_element_list . SEMICOLON END
    (44) case_element_list -> case_element_list . SEMICOLON case_element

    END             shift and go to state 138
    SEMICOLON       shift and go to state 139


state 126

    (45) case_element_list -> case_element .

    END             reduce using rule 45 (case_element_list -> case_element .)
    SEMICOLON       reduce using rule 45 (case_element_list -> case_element .)


state 127

    (46) case_element -> case_constant . COLON Statement

    COLON           shift and go to state 140


state 128

    (47) case_constant -> const .

    COLON           reduce using rule 47 (case_constant -> const .)


state 129

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC . index_list RBRAC OF Type
    (12) index_list -> . index_list COMMA index
    (13) index_list -> . index
    (14) index -> . startIndex DOTDOT endIndex
    (20) startIndex -> . const
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    index_list                     shift and go to state 141
    index                          shift and go to state 142
    startIndex                     shift and go to state 143
    const                          shift and go to state 144

state 130

    (50) closed_if_statement -> IF BoolExpr . THEN closed_statement ELSE closed_statement
    (48) open_if_statement -> IF BoolExpr . THEN Statement
    (49) open_if_statement -> IF BoolExpr . THEN closed_statement ELSE open_statement
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

    THEN            shift and go to state 145
    AND             shift and go to state 79
    OR              shift and go to state 80


state 131

    (49) open_if_statement -> IF BoolExpr THEN closed_statement ELSE . open_statement
    (50) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 10
    GOTO            shift and go to state 41
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    ELSE            reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    closed_statement               shift and go to state 146
    open_statement                 shift and go to state 147
    label                          shift and go to state 22
    non_labeled_open_statement     shift and go to state 23
    non_labeled_closed_statement   shift and go to state 24
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    Variable                       shift and go to state 40

state 132

    (28) closed_statement -> label COLON . non_labeled_closed_statement
    (26) open_statement -> label COLON . non_labeled_open_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    BEGIN           shift and go to state 10
    IF              shift and go to state 101
    WHILE           shift and go to state 105
    FOR             shift and go to state 106
    GOTO            shift and go to state 41
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    non_labeled_closed_statement   shift and go to state 77
    non_labeled_open_statement     shift and go to state 76
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
    Variable                       shift and go to state 40

state 133

    (52) closed_while_statement -> WHILE BoolExpr . DO closed_statement
    (51) open_while_statement -> WHILE BoolExpr . DO open_statement
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

    DO              shift and go to state 148
    AND             shift and go to state 79
    OR              shift and go to state 80


state 134

    (54) closed_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO closed_statement
    (53) open_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO open_statement

    ASSIGNMENT      shift and go to state 149


state 135

    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO open_statement
    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO closed_statement
    (56) final_value -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Variable                       shift and go to state 56
    final_value                    shift and go to state 150
    Expr                           shift and go to state 151
    const                          shift and go to state 57

state 136

    (57) direction -> TO .

    LPAREN          reduce using rule 57 (direction -> TO .)
    MINUS           reduce using rule 57 (direction -> TO .)
    ID              reduce using rule 57 (direction -> TO .)
    INT_NUMBER      reduce using rule 57 (direction -> TO .)
    REAL_NUMBER     reduce using rule 57 (direction -> TO .)


state 137

    (58) direction -> DOWNTO .

    LPAREN          reduce using rule 58 (direction -> DOWNTO .)
    MINUS           reduce using rule 58 (direction -> DOWNTO .)
    ID              reduce using rule 58 (direction -> DOWNTO .)
    INT_NUMBER      reduce using rule 58 (direction -> DOWNTO .)
    REAL_NUMBER     reduce using rule 58 (direction -> DOWNTO .)


state 138

    (41) case_statement -> CASE case_index OF case_element_list END .

    END             reduce using rule 41 (case_statement -> CASE case_index OF case_element_list END .)
    SEMICOLON       reduce using rule 41 (case_statement -> CASE case_index OF case_element_list END .)
    ELSE            reduce using rule 41 (case_statement -> CASE case_index OF case_element_list END .)


state 139

    (42) case_statement -> CASE case_index OF case_element_list SEMICOLON . END
    (44) case_element_list -> case_element_list SEMICOLON . case_element
    (46) case_element -> . case_constant COLON Statement
    (47) case_constant -> . const
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    END             shift and go to state 152
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    case_element                   shift and go to state 153
    case_constant                  shift and go to state 127
    const                          shift and go to state 128

state 140

    (46) case_element -> case_constant COLON . Statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 10
    GOTO            shift and go to state 41
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    Statement                      shift and go to state 154
    open_statement                 shift and go to state 20
    closed_statement               shift and go to state 21
    label                          shift and go to state 22
    non_labeled_open_statement     shift and go to state 23
    non_labeled_closed_statement   shift and go to state 24
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    Variable                       shift and go to state 40

state 141

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list . RBRAC OF Type
    (12) index_list -> index_list . COMMA index

    RBRAC           shift and go to state 155
    COMMA           shift and go to state 156


state 142

    (13) index_list -> index .

    RBRAC           reduce using rule 13 (index_list -> index .)
    COMMA           reduce using rule 13 (index_list -> index .)


state 143

    (14) index -> startIndex . DOTDOT endIndex

    DOTDOT          shift and go to state 157


state 144

    (20) startIndex -> const .

    DOTDOT          reduce using rule 20 (startIndex -> const .)


state 145

    (50) closed_if_statement -> IF BoolExpr THEN . closed_statement ELSE closed_statement
    (48) open_if_statement -> IF BoolExpr THEN . Statement
    (49) open_if_statement -> IF BoolExpr THEN . closed_statement ELSE open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (62) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (19) Variable -> . ID
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement

    DIGSEQ          shift and go to state 25
    BEGIN           shift and go to state 10
    IF              shift and go to state 101
    WHILE           shift and go to state 105
    FOR             shift and go to state 106
    GOTO            shift and go to state 41
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    closed_statement               shift and go to state 158
    Statement                      shift and go to state 102
    open_statement                 shift and go to state 20
    label                          shift and go to state 104
    non_labeled_closed_statement   shift and go to state 24
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    non_labeled_open_statement     shift and go to state 23
    Variable                       shift and go to state 40
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28

state 146

    (50) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .

    END             reduce using rule 50 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)
    SEMICOLON       reduce using rule 50 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)
    ELSE            reduce using rule 50 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)


state 147

    (49) open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .

    END             reduce using rule 49 (open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .)
    SEMICOLON       reduce using rule 49 (open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .)


state 148

    (52) closed_while_statement -> WHILE BoolExpr DO . closed_statement
    (51) open_while_statement -> WHILE BoolExpr DO . open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (62) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    BEGIN           shift and go to state 10
    IF              shift and go to state 101
    WHILE           shift and go to state 105
    FOR             shift and go to state 106
    GOTO            shift and go to state 41
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    closed_statement               shift and go to state 122
    open_statement                 shift and go to state 121
    label                          shift and go to state 104
    non_labeled_closed_statement   shift and go to state 24
    non_labeled_open_statement     shift and go to state 23
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
    Variable                       shift and go to state 40

state 149

    (54) closed_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO closed_statement
    (53) open_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO open_statement
    (55) initial_value -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Variable                       shift and go to state 56
    initial_value                  shift and go to state 159
    Expr                           shift and go to state 124
    const                          shift and go to state 57

state 150

    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO open_statement
    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO closed_statement

    DO              shift and go to state 160


state 151

    (56) final_value -> Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    DO              reduce using rule 56 (final_value -> Expr .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 152

    (42) case_statement -> CASE case_index OF case_element_list SEMICOLON END .

    END             reduce using rule 42 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)
    SEMICOLON       reduce using rule 42 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)
    ELSE            reduce using rule 42 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)


state 153

    (44) case_element_list -> case_element_list SEMICOLON case_element .

    END             reduce using rule 44 (case_element_list -> case_element_list SEMICOLON case_element .)
    SEMICOLON       reduce using rule 44 (case_element_list -> case_element_list SEMICOLON case_element .)


state 154

    (46) case_element -> case_constant COLON Statement .

    END             reduce using rule 46 (case_element -> case_constant COLON Statement .)
    SEMICOLON       reduce using rule 46 (case_element -> case_constant COLON Statement .)


state 155

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC . OF Type

    OF              shift and go to state 161


state 156

    (12) index_list -> index_list COMMA . index
    (14) index -> . startIndex DOTDOT endIndex
    (20) startIndex -> . const
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    index                          shift and go to state 162
    startIndex                     shift and go to state 143
    const                          shift and go to state 144

state 157

    (14) index -> startIndex DOTDOT . endIndex
    (21) endIndex -> . const
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    endIndex                       shift and go to state 163
    const                          shift and go to state 164

state 158

    (50) closed_if_statement -> IF BoolExpr THEN closed_statement . ELSE closed_statement
    (49) open_if_statement -> IF BoolExpr THEN closed_statement . ELSE open_statement
    (25) Statement -> closed_statement .

    ELSE            shift and go to state 165
    END             reduce using rule 25 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 25 (Statement -> closed_statement .)


state 159

    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO closed_statement
    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO open_statement
    (57) direction -> . TO
    (58) direction -> . DOWNTO

    TO              shift and go to state 136
    DOWNTO          shift and go to state 137

    direction                      shift and go to state 166

state 160

    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . open_statement
    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 10
    GOTO            shift and go to state 41
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    ELSE            reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    Variable                       shift and go to state 40
    open_statement                 shift and go to state 167
    closed_statement               shift and go to state 168
    label                          shift and go to state 22
    non_labeled_open_statement     shift and go to state 23
    non_labeled_closed_statement   shift and go to state 24
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36

state 161

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 69
    REAL            shift and go to state 70
    BOOLEAN         shift and go to state 71
    ID              shift and go to state 47

    arrayName                      shift and go to state 72
    Type                           shift and go to state 169

state 162

    (12) index_list -> index_list COMMA index .

    RBRAC           reduce using rule 12 (index_list -> index_list COMMA index .)
    COMMA           reduce using rule 12 (index_list -> index_list COMMA index .)


state 163

    (14) index -> startIndex DOTDOT endIndex .

    RBRAC           reduce using rule 14 (index -> startIndex DOTDOT endIndex .)
    COMMA           reduce using rule 14 (index -> startIndex DOTDOT endIndex .)


state 164

    (21) endIndex -> const .

    RBRAC           reduce using rule 21 (endIndex -> const .)
    COMMA           reduce using rule 21 (endIndex -> const .)


state 165

    (50) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE . closed_statement
    (49) open_if_statement -> IF BoolExpr THEN closed_statement ELSE . open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (62) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    BEGIN           shift and go to state 10
    IF              shift and go to state 101
    WHILE           shift and go to state 105
    FOR             shift and go to state 106
    GOTO            shift and go to state 41
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    closed_statement               shift and go to state 146
    open_statement                 shift and go to state 147
    label                          shift and go to state 104
    non_labeled_closed_statement   shift and go to state 24
    non_labeled_open_statement     shift and go to state 23
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
    Variable                       shift and go to state 40

state 166

    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO closed_statement
    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO open_statement
    (56) final_value -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 66
    MINUS           shift and go to state 55
    ID              shift and go to state 17
    INT_NUMBER      shift and go to state 58
    REAL_NUMBER     shift and go to state 59

    Variable                       shift and go to state 56
    final_value                    shift and go to state 170
    Expr                           shift and go to state 151
    const                          shift and go to state 57

state 167

    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .

    END             reduce using rule 53 (open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .)
    SEMICOLON       reduce using rule 53 (open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .)


state 168

    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .

    END             reduce using rule 54 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)
    SEMICOLON       reduce using rule 54 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)
    ELSE            reduce using rule 54 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)


state 169

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type .

    SEMICOLON       reduce using rule 10 (ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type .)


state 170

    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO closed_statement
    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO open_statement

    DO              shift and go to state 171


state 171

    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . closed_statement
    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (62) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    BEGIN           shift and go to state 10
    IF              shift and go to state 101
    WHILE           shift and go to state 105
    FOR             shift and go to state 106
    GOTO            shift and go to state 41
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 42
    ID              shift and go to state 17

    Variable                       shift and go to state 40
    closed_statement               shift and go to state 168
    open_statement                 shift and go to state 167
    label                          shift and go to state 104
    non_labeled_closed_statement   shift and go to state 24
    non_labeled_open_statement     shift and go to state 23
    assignment_statement           shift and go to state 29
    compound_statement             shift and go to state 30
    closed_if_statement            shift and go to state 31
    closed_while_statement         shift and go to state 32
    closed_for_statement           shift and go to state 33
    goto_statement                 shift and go to state 34
    empty                          shift and go to state 35
    case_statement                 shift and go to state 36
    open_if_statement              shift and go to state 26
    open_while_statement           shift and go to state 27
    open_for_statement             shift and go to state 28
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 91 resolved as shift
WARNING: shift/reduce conflict for OR in state 91 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 93 resolved as shift
WARNING: shift/reduce conflict for AND in state 107 resolved as shift
WARNING: shift/reduce conflict for OR in state 107 resolved as shift
WARNING: shift/reduce conflict for AND in state 108 resolved as shift
WARNING: shift/reduce conflict for OR in state 108 resolved as shift
