Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    LLAVEI
    LLAVED
    MOD
    RETURN
    CHAR
    STRING
    USES
    CONST

Grammar

Rule 0     S' -> ProgDef
Rule 1     ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT
Rule 2     SubProg -> VarDef function_definition compound_statement
Rule 3     VarDef -> VAR VarDefList SEMICOLON
Rule 4     VarDefList -> VarDefList SEMICOLON VarDefState
Rule 5     VarDefList -> VarDefState
Rule 6     VarDefState -> VarList COLON Type
Rule 7     VarDefState -> ArrayDefState
Rule 8     VarList -> VarList COMMA Variable
Rule 9     VarList -> Variable
Rule 10    ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
Rule 11    arrayName -> ID
Rule 12    index_list -> index_list COMMA index
Rule 13    index_list -> index
Rule 14    index -> startIndex DOTDOT endIndex
Rule 15    Type -> INTEGER
Rule 16    Type -> REAL
Rule 17    Type -> BOOLEAN
Rule 18    Type -> arrayName
Rule 19    Variable -> ID
Rule 20    startIndex -> const
Rule 21    endIndex -> const
Rule 22    StateList -> StateList SEMICOLON Statement
Rule 23    StateList -> Statement
Rule 24    Statement -> open_statement
Rule 25    Statement -> closed_statement
Rule 26    open_statement -> label COLON non_labeled_open_statement
Rule 27    open_statement -> non_labeled_open_statement
Rule 28    closed_statement -> label COLON non_labeled_closed_statement
Rule 29    closed_statement -> non_labeled_closed_statement
Rule 30    non_labeled_open_statement -> open_if_statement
Rule 31    non_labeled_open_statement -> open_while_statement
Rule 32    non_labeled_open_statement -> open_for_statement
Rule 33    non_labeled_closed_statement -> assignment_statement
Rule 34    non_labeled_closed_statement -> compound_statement
Rule 35    non_labeled_closed_statement -> closed_if_statement
Rule 36    non_labeled_closed_statement -> closed_while_statement
Rule 37    non_labeled_closed_statement -> closed_for_statement
Rule 38    non_labeled_closed_statement -> goto_statement
Rule 39    non_labeled_closed_statement -> empty
Rule 40    non_labeled_closed_statement -> case_statement
Rule 41    case_statement -> CASE case_index OF case_element_list END
Rule 42    case_statement -> CASE case_index OF case_element_list SEMICOLON END
Rule 43    case_index -> Expr
Rule 44    case_element_list -> case_element_list SEMICOLON case_element
Rule 45    case_element_list -> case_element
Rule 46    case_element -> case_constant COLON Statement
Rule 47    case_constant -> const
Rule 48    open_if_statement -> IF BoolExpr THEN Statement
Rule 49    open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement
Rule 50    closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement
Rule 51    open_while_statement -> WHILE BoolExpr DO open_statement
Rule 52    closed_while_statement -> WHILE BoolExpr DO closed_statement
Rule 53    open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
Rule 54    closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
Rule 55    initial_value -> Expr
Rule 56    final_value -> Expr
Rule 57    direction -> TO
Rule 58    direction -> DOWNTO
Rule 59    assignment_statement -> Variable ASSIGNMENT Expr
Rule 60    compound_statement -> BEGIN StateList END
Rule 61    goto_statement -> GOTO label
Rule 62    label -> DIGSEQ
Rule 63    Expr -> Expr PLUS Expr
Rule 64    Expr -> Expr MINUS Expr
Rule 65    Expr -> Expr TIMES Expr
Rule 66    Expr -> Expr DIVIDE Expr
Rule 67    Expr -> LPAREN Expr RPAREN
Rule 68    Expr -> MINUS Expr
Rule 69    Expr -> Variable
Rule 70    Expr -> const
Rule 71    const -> INT_NUMBER
Rule 72    const -> REAL_NUMBER
Rule 73    BoolExpr -> Expr LT Expr
Rule 74    BoolExpr -> Expr LE Expr
Rule 75    BoolExpr -> Expr GT Expr
Rule 76    BoolExpr -> Expr GE Expr
Rule 77    BoolExpr -> Expr EQ Expr
Rule 78    BoolExpr -> Expr NE Expr
Rule 79    BoolExpr -> BoolExpr AND BoolExpr
Rule 80    BoolExpr -> BoolExpr OR BoolExpr
Rule 81    BoolExpr -> NOT BoolExpr
Rule 82    BoolExpr -> LPAREN BoolExpr RPAREN
Rule 83    BoolExpr -> Expr
Rule 84    empty -> <empty>
Rule 85    function_definition -> function_heading SEMICOLON function_block
Rule 86    function_definition -> empty
Rule 87    function_heading -> FUNCTION funcName COLON return_type
Rule 88    function_heading -> FUNCTION funcName parameter_list COLON return_type
Rule 89    parameter_list -> LPAREN VarDefList RPAREN
Rule 90    funcName -> ID
Rule 91    return_type -> Type
Rule 92    function_block -> compound_statement

Terminals, with rules where they appear

AND                  : 79
ARRAY                : 10
ASSIGNMENT           : 53 54 59
BEGIN                : 60
BOOLEAN              : 17
CASE                 : 41 42
CHAR                 : 
COLON                : 6 26 28 46 87 88
COMMA                : 8 12
CONST                : 
DIGSEQ               : 62
DIVIDE               : 66
DO                   : 51 52 53 54
DOTDOT               : 14
DOWNTO               : 58
ELSE                 : 49 50
END                  : 41 42 60
ENDPOINT             : 1
EQ                   : 10 77
FOR                  : 53 54
FUNCTION             : 87 88
GE                   : 76
GOTO                 : 61
GT                   : 75
ID                   : 1 11 19 90
IF                   : 48 49 50
INTEGER              : 15
INT_NUMBER           : 71
LBRAC                : 10
LE                   : 74
LLAVED               : 
LLAVEI               : 
LPAREN               : 67 82 89
LT                   : 73
MINUS                : 64 68
MOD                  : 
NE                   : 78
NOT                  : 81
OF                   : 10 41 42
OR                   : 80
PLUS                 : 63
PROGRAM              : 1
RBRAC                : 10
REAL                 : 16
REAL_NUMBER          : 72
RETURN               : 
RPAREN               : 67 82 89
SEMICOLON            : 1 3 4 22 42 44 85
STRING               : 
THEN                 : 48 49 50
TIMES                : 65
TO                   : 57
TYPE                 : 10
USES                 : 
VAR                  : 3
WHILE                : 51 52
error                : 

Nonterminals, with rules where they appear

ArrayDefState        : 7
BoolExpr             : 48 49 50 51 52 79 79 80 80 81 82
Expr                 : 43 55 56 59 63 63 64 64 65 65 66 66 67 68 73 73 74 74 75 75 76 76 77 77 78 78 83
ProgDef              : 0
StateList            : 22 60
Statement            : 22 23 46 48
SubProg              : 1
Type                 : 6 10 91
VarDef               : 2
VarDefList           : 3 4 89
VarDefState          : 4 5
VarList              : 6 8
Variable             : 8 9 53 54 59 69
arrayName            : 10 18
assignment_statement : 33
case_constant        : 46
case_element         : 44 45
case_element_list    : 41 42 44
case_index           : 41 42
case_statement       : 40
closed_for_statement : 37
closed_if_statement  : 35
closed_statement     : 25 49 50 50 52 54
closed_while_statement : 36
compound_statement   : 2 34 92
const                : 20 21 47 70
direction            : 53 54
empty                : 39 86
endIndex             : 14
final_value          : 53 54
funcName             : 87 88
function_block       : 85
function_definition  : 2
function_heading     : 85
goto_statement       : 38
index                : 12 13
index_list           : 10 12
initial_value        : 53 54
label                : 26 28 61
non_labeled_closed_statement : 28 29
non_labeled_open_statement : 26 27
open_for_statement   : 32
open_if_statement    : 30
open_statement       : 24 49 51 53
open_while_statement : 31
parameter_list       : 88
return_type          : 87 88
startIndex           : 14

Parsing method: LALR

state 0

    (0) S' -> . ProgDef
    (1) ProgDef -> . PROGRAM ID SEMICOLON SubProg ENDPOINT

    PROGRAM         shift and go to state 2

    ProgDef                        shift and go to state 1

state 1

    (0) S' -> ProgDef .



state 2

    (1) ProgDef -> PROGRAM . ID SEMICOLON SubProg ENDPOINT

    ID              shift and go to state 3


state 3

    (1) ProgDef -> PROGRAM ID . SEMICOLON SubProg ENDPOINT

    SEMICOLON       shift and go to state 4


state 4

    (1) ProgDef -> PROGRAM ID SEMICOLON . SubProg ENDPOINT
    (2) SubProg -> . VarDef function_definition compound_statement
    (3) VarDef -> . VAR VarDefList SEMICOLON

    VAR             shift and go to state 7

    SubProg                        shift and go to state 5
    VarDef                         shift and go to state 6

state 5

    (1) ProgDef -> PROGRAM ID SEMICOLON SubProg . ENDPOINT

    ENDPOINT        shift and go to state 8


state 6

    (2) SubProg -> VarDef . function_definition compound_statement
    (85) function_definition -> . function_heading SEMICOLON function_block
    (86) function_definition -> . empty
    (87) function_heading -> . FUNCTION funcName COLON return_type
    (88) function_heading -> . FUNCTION funcName parameter_list COLON return_type
    (84) empty -> .

    FUNCTION        shift and go to state 12
    BEGIN           reduce using rule 84 (empty -> .)

    function_definition            shift and go to state 9
    function_heading               shift and go to state 10
    empty                          shift and go to state 11

state 7

    (3) VarDef -> VAR . VarDefList SEMICOLON
    (4) VarDefList -> . VarDefList SEMICOLON VarDefState
    (5) VarDefList -> . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    TYPE            shift and go to state 18
    ID              shift and go to state 19

    VarDefList                     shift and go to state 13
    VarDefState                    shift and go to state 14
    VarList                        shift and go to state 15
    ArrayDefState                  shift and go to state 16
    Variable                       shift and go to state 17

state 8

    (1) ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT .

    $end            reduce using rule 1 (ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT .)


state 9

    (2) SubProg -> VarDef function_definition . compound_statement
    (60) compound_statement -> . BEGIN StateList END

    BEGIN           shift and go to state 21

    compound_statement             shift and go to state 20

state 10

    (85) function_definition -> function_heading . SEMICOLON function_block

    SEMICOLON       shift and go to state 22


state 11

    (86) function_definition -> empty .

    BEGIN           reduce using rule 86 (function_definition -> empty .)


state 12

    (87) function_heading -> FUNCTION . funcName COLON return_type
    (88) function_heading -> FUNCTION . funcName parameter_list COLON return_type
    (90) funcName -> . ID

    ID              shift and go to state 24

    funcName                       shift and go to state 23

state 13

    (3) VarDef -> VAR VarDefList . SEMICOLON
    (4) VarDefList -> VarDefList . SEMICOLON VarDefState

    SEMICOLON       shift and go to state 25


state 14

    (5) VarDefList -> VarDefState .

    SEMICOLON       reduce using rule 5 (VarDefList -> VarDefState .)
    RPAREN          reduce using rule 5 (VarDefList -> VarDefState .)


state 15

    (6) VarDefState -> VarList . COLON Type
    (8) VarList -> VarList . COMMA Variable

    COLON           shift and go to state 26
    COMMA           shift and go to state 27


state 16

    (7) VarDefState -> ArrayDefState .

    SEMICOLON       reduce using rule 7 (VarDefState -> ArrayDefState .)
    RPAREN          reduce using rule 7 (VarDefState -> ArrayDefState .)


state 17

    (9) VarList -> Variable .

    COLON           reduce using rule 9 (VarList -> Variable .)
    COMMA           reduce using rule 9 (VarList -> Variable .)


state 18

    (10) ArrayDefState -> TYPE . arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (11) arrayName -> . ID

    ID              shift and go to state 29

    arrayName                      shift and go to state 28

state 19

    (19) Variable -> ID .

    COLON           reduce using rule 19 (Variable -> ID .)
    COMMA           reduce using rule 19 (Variable -> ID .)
    ASSIGNMENT      reduce using rule 19 (Variable -> ID .)
    LT              reduce using rule 19 (Variable -> ID .)
    LE              reduce using rule 19 (Variable -> ID .)
    GT              reduce using rule 19 (Variable -> ID .)
    GE              reduce using rule 19 (Variable -> ID .)
    EQ              reduce using rule 19 (Variable -> ID .)
    NE              reduce using rule 19 (Variable -> ID .)
    PLUS            reduce using rule 19 (Variable -> ID .)
    MINUS           reduce using rule 19 (Variable -> ID .)
    TIMES           reduce using rule 19 (Variable -> ID .)
    DIVIDE          reduce using rule 19 (Variable -> ID .)
    THEN            reduce using rule 19 (Variable -> ID .)
    AND             reduce using rule 19 (Variable -> ID .)
    OR              reduce using rule 19 (Variable -> ID .)
    DO              reduce using rule 19 (Variable -> ID .)
    OF              reduce using rule 19 (Variable -> ID .)
    RPAREN          reduce using rule 19 (Variable -> ID .)
    END             reduce using rule 19 (Variable -> ID .)
    SEMICOLON       reduce using rule 19 (Variable -> ID .)
    ELSE            reduce using rule 19 (Variable -> ID .)
    TO              reduce using rule 19 (Variable -> ID .)
    DOWNTO          reduce using rule 19 (Variable -> ID .)


state 20

    (2) SubProg -> VarDef function_definition compound_statement .

    ENDPOINT        reduce using rule 2 (SubProg -> VarDef function_definition compound_statement .)


state 21

    (60) compound_statement -> BEGIN . StateList END
    (22) StateList -> . StateList SEMICOLON Statement
    (23) StateList -> . Statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 53
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    StateList                      shift and go to state 30
    Statement                      shift and go to state 31
    open_statement                 shift and go to state 32
    closed_statement               shift and go to state 33
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    Variable                       shift and go to state 52

state 22

    (85) function_definition -> function_heading SEMICOLON . function_block
    (92) function_block -> . compound_statement
    (60) compound_statement -> . BEGIN StateList END

    BEGIN           shift and go to state 21

    function_block                 shift and go to state 55
    compound_statement             shift and go to state 56

state 23

    (87) function_heading -> FUNCTION funcName . COLON return_type
    (88) function_heading -> FUNCTION funcName . parameter_list COLON return_type
    (89) parameter_list -> . LPAREN VarDefList RPAREN

    COLON           shift and go to state 57
    LPAREN          shift and go to state 59

    parameter_list                 shift and go to state 58

state 24

    (90) funcName -> ID .

    COLON           reduce using rule 90 (funcName -> ID .)
    LPAREN          reduce using rule 90 (funcName -> ID .)


state 25

    (3) VarDef -> VAR VarDefList SEMICOLON .
    (4) VarDefList -> VarDefList SEMICOLON . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    FUNCTION        reduce using rule 3 (VarDef -> VAR VarDefList SEMICOLON .)
    BEGIN           reduce using rule 3 (VarDef -> VAR VarDefList SEMICOLON .)
    TYPE            shift and go to state 18
    ID              shift and go to state 19

    VarDefState                    shift and go to state 60
    VarList                        shift and go to state 15
    ArrayDefState                  shift and go to state 16
    Variable                       shift and go to state 17

state 26

    (6) VarDefState -> VarList COLON . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 62
    REAL            shift and go to state 63
    BOOLEAN         shift and go to state 64
    ID              shift and go to state 29

    Type                           shift and go to state 61
    arrayName                      shift and go to state 65

state 27

    (8) VarList -> VarList COMMA . Variable
    (19) Variable -> . ID

    ID              shift and go to state 19

    Variable                       shift and go to state 66

state 28

    (10) ArrayDefState -> TYPE arrayName . EQ ARRAY LBRAC index_list RBRAC OF Type

    EQ              shift and go to state 67


state 29

    (11) arrayName -> ID .

    EQ              reduce using rule 11 (arrayName -> ID .)
    SEMICOLON       reduce using rule 11 (arrayName -> ID .)
    RPAREN          reduce using rule 11 (arrayName -> ID .)


state 30

    (60) compound_statement -> BEGIN StateList . END
    (22) StateList -> StateList . SEMICOLON Statement

    END             shift and go to state 68
    SEMICOLON       shift and go to state 69


state 31

    (23) StateList -> Statement .

    END             reduce using rule 23 (StateList -> Statement .)
    SEMICOLON       reduce using rule 23 (StateList -> Statement .)


state 32

    (24) Statement -> open_statement .

    END             reduce using rule 24 (Statement -> open_statement .)
    SEMICOLON       reduce using rule 24 (Statement -> open_statement .)


state 33

    (25) Statement -> closed_statement .

    END             reduce using rule 25 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 25 (Statement -> closed_statement .)


state 34

    (26) open_statement -> label . COLON non_labeled_open_statement
    (28) closed_statement -> label . COLON non_labeled_closed_statement

    COLON           shift and go to state 70


state 35

    (27) open_statement -> non_labeled_open_statement .

    END             reduce using rule 27 (open_statement -> non_labeled_open_statement .)
    SEMICOLON       reduce using rule 27 (open_statement -> non_labeled_open_statement .)


state 36

    (29) closed_statement -> non_labeled_closed_statement .

    END             reduce using rule 29 (closed_statement -> non_labeled_closed_statement .)
    SEMICOLON       reduce using rule 29 (closed_statement -> non_labeled_closed_statement .)
    ELSE            reduce using rule 29 (closed_statement -> non_labeled_closed_statement .)


state 37

    (62) label -> DIGSEQ .

    COLON           reduce using rule 62 (label -> DIGSEQ .)
    END             reduce using rule 62 (label -> DIGSEQ .)
    SEMICOLON       reduce using rule 62 (label -> DIGSEQ .)
    ELSE            reduce using rule 62 (label -> DIGSEQ .)


state 38

    (30) non_labeled_open_statement -> open_if_statement .

    END             reduce using rule 30 (non_labeled_open_statement -> open_if_statement .)
    SEMICOLON       reduce using rule 30 (non_labeled_open_statement -> open_if_statement .)


state 39

    (31) non_labeled_open_statement -> open_while_statement .

    END             reduce using rule 31 (non_labeled_open_statement -> open_while_statement .)
    SEMICOLON       reduce using rule 31 (non_labeled_open_statement -> open_while_statement .)


state 40

    (32) non_labeled_open_statement -> open_for_statement .

    END             reduce using rule 32 (non_labeled_open_statement -> open_for_statement .)
    SEMICOLON       reduce using rule 32 (non_labeled_open_statement -> open_for_statement .)


state 41

    (33) non_labeled_closed_statement -> assignment_statement .

    END             reduce using rule 33 (non_labeled_closed_statement -> assignment_statement .)
    SEMICOLON       reduce using rule 33 (non_labeled_closed_statement -> assignment_statement .)
    ELSE            reduce using rule 33 (non_labeled_closed_statement -> assignment_statement .)


state 42

    (34) non_labeled_closed_statement -> compound_statement .

    END             reduce using rule 34 (non_labeled_closed_statement -> compound_statement .)
    SEMICOLON       reduce using rule 34 (non_labeled_closed_statement -> compound_statement .)
    ELSE            reduce using rule 34 (non_labeled_closed_statement -> compound_statement .)


state 43

    (35) non_labeled_closed_statement -> closed_if_statement .

    END             reduce using rule 35 (non_labeled_closed_statement -> closed_if_statement .)
    SEMICOLON       reduce using rule 35 (non_labeled_closed_statement -> closed_if_statement .)
    ELSE            reduce using rule 35 (non_labeled_closed_statement -> closed_if_statement .)


state 44

    (36) non_labeled_closed_statement -> closed_while_statement .

    END             reduce using rule 36 (non_labeled_closed_statement -> closed_while_statement .)
    SEMICOLON       reduce using rule 36 (non_labeled_closed_statement -> closed_while_statement .)
    ELSE            reduce using rule 36 (non_labeled_closed_statement -> closed_while_statement .)


state 45

    (37) non_labeled_closed_statement -> closed_for_statement .

    END             reduce using rule 37 (non_labeled_closed_statement -> closed_for_statement .)
    SEMICOLON       reduce using rule 37 (non_labeled_closed_statement -> closed_for_statement .)
    ELSE            reduce using rule 37 (non_labeled_closed_statement -> closed_for_statement .)


state 46

    (38) non_labeled_closed_statement -> goto_statement .

    END             reduce using rule 38 (non_labeled_closed_statement -> goto_statement .)
    SEMICOLON       reduce using rule 38 (non_labeled_closed_statement -> goto_statement .)
    ELSE            reduce using rule 38 (non_labeled_closed_statement -> goto_statement .)


state 47

    (39) non_labeled_closed_statement -> empty .

    END             reduce using rule 39 (non_labeled_closed_statement -> empty .)
    SEMICOLON       reduce using rule 39 (non_labeled_closed_statement -> empty .)
    ELSE            reduce using rule 39 (non_labeled_closed_statement -> empty .)


state 48

    (40) non_labeled_closed_statement -> case_statement .

    END             reduce using rule 40 (non_labeled_closed_statement -> case_statement .)
    SEMICOLON       reduce using rule 40 (non_labeled_closed_statement -> case_statement .)
    ELSE            reduce using rule 40 (non_labeled_closed_statement -> case_statement .)


state 49

    (48) open_if_statement -> IF . BoolExpr THEN Statement
    (49) open_if_statement -> IF . BoolExpr THEN closed_statement ELSE open_statement
    (50) closed_if_statement -> IF . BoolExpr THEN closed_statement ELSE closed_statement
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 73
    LPAREN          shift and go to state 74
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    BoolExpr                       shift and go to state 71
    Expr                           shift and go to state 72
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 50

    (51) open_while_statement -> WHILE . BoolExpr DO open_statement
    (52) closed_while_statement -> WHILE . BoolExpr DO closed_statement
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 73
    LPAREN          shift and go to state 74
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    BoolExpr                       shift and go to state 80
    Expr                           shift and go to state 72
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 51

    (53) open_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (54) closed_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (19) Variable -> . ID

    ID              shift and go to state 19

    Variable                       shift and go to state 81

state 52

    (59) assignment_statement -> Variable . ASSIGNMENT Expr

    ASSIGNMENT      shift and go to state 82


state 53

    (61) goto_statement -> GOTO . label
    (62) label -> . DIGSEQ

    DIGSEQ          shift and go to state 37

    label                          shift and go to state 83

state 54

    (41) case_statement -> CASE . case_index OF case_element_list END
    (42) case_statement -> CASE . case_index OF case_element_list SEMICOLON END
    (43) case_index -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    case_index                     shift and go to state 84
    Expr                           shift and go to state 85
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 55

    (85) function_definition -> function_heading SEMICOLON function_block .

    BEGIN           reduce using rule 85 (function_definition -> function_heading SEMICOLON function_block .)


state 56

    (92) function_block -> compound_statement .

    BEGIN           reduce using rule 92 (function_block -> compound_statement .)


state 57

    (87) function_heading -> FUNCTION funcName COLON . return_type
    (91) return_type -> . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 62
    REAL            shift and go to state 63
    BOOLEAN         shift and go to state 64
    ID              shift and go to state 29

    return_type                    shift and go to state 87
    Type                           shift and go to state 88
    arrayName                      shift and go to state 65

state 58

    (88) function_heading -> FUNCTION funcName parameter_list . COLON return_type

    COLON           shift and go to state 89


state 59

    (89) parameter_list -> LPAREN . VarDefList RPAREN
    (4) VarDefList -> . VarDefList SEMICOLON VarDefState
    (5) VarDefList -> . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    TYPE            shift and go to state 18
    ID              shift and go to state 19

    VarDefList                     shift and go to state 90
    VarDefState                    shift and go to state 14
    VarList                        shift and go to state 15
    ArrayDefState                  shift and go to state 16
    Variable                       shift and go to state 17

state 60

    (4) VarDefList -> VarDefList SEMICOLON VarDefState .

    SEMICOLON       reduce using rule 4 (VarDefList -> VarDefList SEMICOLON VarDefState .)
    RPAREN          reduce using rule 4 (VarDefList -> VarDefList SEMICOLON VarDefState .)


state 61

    (6) VarDefState -> VarList COLON Type .

    SEMICOLON       reduce using rule 6 (VarDefState -> VarList COLON Type .)
    RPAREN          reduce using rule 6 (VarDefState -> VarList COLON Type .)


state 62

    (15) Type -> INTEGER .

    SEMICOLON       reduce using rule 15 (Type -> INTEGER .)
    RPAREN          reduce using rule 15 (Type -> INTEGER .)


state 63

    (16) Type -> REAL .

    SEMICOLON       reduce using rule 16 (Type -> REAL .)
    RPAREN          reduce using rule 16 (Type -> REAL .)


state 64

    (17) Type -> BOOLEAN .

    SEMICOLON       reduce using rule 17 (Type -> BOOLEAN .)
    RPAREN          reduce using rule 17 (Type -> BOOLEAN .)


state 65

    (18) Type -> arrayName .

    SEMICOLON       reduce using rule 18 (Type -> arrayName .)
    RPAREN          reduce using rule 18 (Type -> arrayName .)


state 66

    (8) VarList -> VarList COMMA Variable .

    COLON           reduce using rule 8 (VarList -> VarList COMMA Variable .)
    COMMA           reduce using rule 8 (VarList -> VarList COMMA Variable .)


state 67

    (10) ArrayDefState -> TYPE arrayName EQ . ARRAY LBRAC index_list RBRAC OF Type

    ARRAY           shift and go to state 91


state 68

    (60) compound_statement -> BEGIN StateList END .

    ENDPOINT        reduce using rule 60 (compound_statement -> BEGIN StateList END .)
    END             reduce using rule 60 (compound_statement -> BEGIN StateList END .)
    SEMICOLON       reduce using rule 60 (compound_statement -> BEGIN StateList END .)
    BEGIN           reduce using rule 60 (compound_statement -> BEGIN StateList END .)
    ELSE            reduce using rule 60 (compound_statement -> BEGIN StateList END .)


state 69

    (22) StateList -> StateList SEMICOLON . Statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 53
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    Statement                      shift and go to state 92
    open_statement                 shift and go to state 32
    closed_statement               shift and go to state 33
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    Variable                       shift and go to state 52

state 70

    (26) open_statement -> label COLON . non_labeled_open_statement
    (28) closed_statement -> label COLON . non_labeled_closed_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 53
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    ELSE            reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    non_labeled_open_statement     shift and go to state 93
    non_labeled_closed_statement   shift and go to state 94
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    Variable                       shift and go to state 52

state 71

    (48) open_if_statement -> IF BoolExpr . THEN Statement
    (49) open_if_statement -> IF BoolExpr . THEN closed_statement ELSE open_statement
    (50) closed_if_statement -> IF BoolExpr . THEN closed_statement ELSE closed_statement
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

    THEN            shift and go to state 95
    AND             shift and go to state 96
    OR              shift and go to state 97


state 72

    (73) BoolExpr -> Expr . LT Expr
    (74) BoolExpr -> Expr . LE Expr
    (75) BoolExpr -> Expr . GT Expr
    (76) BoolExpr -> Expr . GE Expr
    (77) BoolExpr -> Expr . EQ Expr
    (78) BoolExpr -> Expr . NE Expr
    (83) BoolExpr -> Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              shift and go to state 98
    LE              shift and go to state 99
    GT              shift and go to state 100
    GE              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    THEN            reduce using rule 83 (BoolExpr -> Expr .)
    AND             reduce using rule 83 (BoolExpr -> Expr .)
    OR              reduce using rule 83 (BoolExpr -> Expr .)
    DO              reduce using rule 83 (BoolExpr -> Expr .)
    RPAREN          reduce using rule 83 (BoolExpr -> Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 73

    (81) BoolExpr -> NOT . BoolExpr
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 73
    LPAREN          shift and go to state 74
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    BoolExpr                       shift and go to state 108
    Expr                           shift and go to state 72
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 74

    (82) BoolExpr -> LPAREN . BoolExpr RPAREN
    (67) Expr -> LPAREN . Expr RPAREN
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 73
    LPAREN          shift and go to state 74
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    BoolExpr                       shift and go to state 109
    Expr                           shift and go to state 110
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 75

    (68) Expr -> MINUS . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 111
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 76

    (69) Expr -> Variable .

    LT              reduce using rule 69 (Expr -> Variable .)
    LE              reduce using rule 69 (Expr -> Variable .)
    GT              reduce using rule 69 (Expr -> Variable .)
    GE              reduce using rule 69 (Expr -> Variable .)
    EQ              reduce using rule 69 (Expr -> Variable .)
    NE              reduce using rule 69 (Expr -> Variable .)
    PLUS            reduce using rule 69 (Expr -> Variable .)
    MINUS           reduce using rule 69 (Expr -> Variable .)
    TIMES           reduce using rule 69 (Expr -> Variable .)
    DIVIDE          reduce using rule 69 (Expr -> Variable .)
    THEN            reduce using rule 69 (Expr -> Variable .)
    AND             reduce using rule 69 (Expr -> Variable .)
    OR              reduce using rule 69 (Expr -> Variable .)
    DO              reduce using rule 69 (Expr -> Variable .)
    OF              reduce using rule 69 (Expr -> Variable .)
    RPAREN          reduce using rule 69 (Expr -> Variable .)
    END             reduce using rule 69 (Expr -> Variable .)
    SEMICOLON       reduce using rule 69 (Expr -> Variable .)
    ELSE            reduce using rule 69 (Expr -> Variable .)
    TO              reduce using rule 69 (Expr -> Variable .)
    DOWNTO          reduce using rule 69 (Expr -> Variable .)


state 77

    (70) Expr -> const .

    LT              reduce using rule 70 (Expr -> const .)
    LE              reduce using rule 70 (Expr -> const .)
    GT              reduce using rule 70 (Expr -> const .)
    GE              reduce using rule 70 (Expr -> const .)
    EQ              reduce using rule 70 (Expr -> const .)
    NE              reduce using rule 70 (Expr -> const .)
    PLUS            reduce using rule 70 (Expr -> const .)
    MINUS           reduce using rule 70 (Expr -> const .)
    TIMES           reduce using rule 70 (Expr -> const .)
    DIVIDE          reduce using rule 70 (Expr -> const .)
    THEN            reduce using rule 70 (Expr -> const .)
    AND             reduce using rule 70 (Expr -> const .)
    OR              reduce using rule 70 (Expr -> const .)
    DO              reduce using rule 70 (Expr -> const .)
    OF              reduce using rule 70 (Expr -> const .)
    RPAREN          reduce using rule 70 (Expr -> const .)
    END             reduce using rule 70 (Expr -> const .)
    SEMICOLON       reduce using rule 70 (Expr -> const .)
    ELSE            reduce using rule 70 (Expr -> const .)
    TO              reduce using rule 70 (Expr -> const .)
    DOWNTO          reduce using rule 70 (Expr -> const .)


state 78

    (71) const -> INT_NUMBER .

    LT              reduce using rule 71 (const -> INT_NUMBER .)
    LE              reduce using rule 71 (const -> INT_NUMBER .)
    GT              reduce using rule 71 (const -> INT_NUMBER .)
    GE              reduce using rule 71 (const -> INT_NUMBER .)
    EQ              reduce using rule 71 (const -> INT_NUMBER .)
    NE              reduce using rule 71 (const -> INT_NUMBER .)
    PLUS            reduce using rule 71 (const -> INT_NUMBER .)
    MINUS           reduce using rule 71 (const -> INT_NUMBER .)
    TIMES           reduce using rule 71 (const -> INT_NUMBER .)
    DIVIDE          reduce using rule 71 (const -> INT_NUMBER .)
    THEN            reduce using rule 71 (const -> INT_NUMBER .)
    AND             reduce using rule 71 (const -> INT_NUMBER .)
    OR              reduce using rule 71 (const -> INT_NUMBER .)
    DO              reduce using rule 71 (const -> INT_NUMBER .)
    OF              reduce using rule 71 (const -> INT_NUMBER .)
    RPAREN          reduce using rule 71 (const -> INT_NUMBER .)
    END             reduce using rule 71 (const -> INT_NUMBER .)
    SEMICOLON       reduce using rule 71 (const -> INT_NUMBER .)
    ELSE            reduce using rule 71 (const -> INT_NUMBER .)
    TO              reduce using rule 71 (const -> INT_NUMBER .)
    DOWNTO          reduce using rule 71 (const -> INT_NUMBER .)
    COLON           reduce using rule 71 (const -> INT_NUMBER .)
    DOTDOT          reduce using rule 71 (const -> INT_NUMBER .)
    RBRAC           reduce using rule 71 (const -> INT_NUMBER .)
    COMMA           reduce using rule 71 (const -> INT_NUMBER .)


state 79

    (72) const -> REAL_NUMBER .

    LT              reduce using rule 72 (const -> REAL_NUMBER .)
    LE              reduce using rule 72 (const -> REAL_NUMBER .)
    GT              reduce using rule 72 (const -> REAL_NUMBER .)
    GE              reduce using rule 72 (const -> REAL_NUMBER .)
    EQ              reduce using rule 72 (const -> REAL_NUMBER .)
    NE              reduce using rule 72 (const -> REAL_NUMBER .)
    PLUS            reduce using rule 72 (const -> REAL_NUMBER .)
    MINUS           reduce using rule 72 (const -> REAL_NUMBER .)
    TIMES           reduce using rule 72 (const -> REAL_NUMBER .)
    DIVIDE          reduce using rule 72 (const -> REAL_NUMBER .)
    THEN            reduce using rule 72 (const -> REAL_NUMBER .)
    AND             reduce using rule 72 (const -> REAL_NUMBER .)
    OR              reduce using rule 72 (const -> REAL_NUMBER .)
    DO              reduce using rule 72 (const -> REAL_NUMBER .)
    OF              reduce using rule 72 (const -> REAL_NUMBER .)
    RPAREN          reduce using rule 72 (const -> REAL_NUMBER .)
    END             reduce using rule 72 (const -> REAL_NUMBER .)
    SEMICOLON       reduce using rule 72 (const -> REAL_NUMBER .)
    ELSE            reduce using rule 72 (const -> REAL_NUMBER .)
    TO              reduce using rule 72 (const -> REAL_NUMBER .)
    DOWNTO          reduce using rule 72 (const -> REAL_NUMBER .)
    COLON           reduce using rule 72 (const -> REAL_NUMBER .)
    DOTDOT          reduce using rule 72 (const -> REAL_NUMBER .)
    RBRAC           reduce using rule 72 (const -> REAL_NUMBER .)
    COMMA           reduce using rule 72 (const -> REAL_NUMBER .)


state 80

    (51) open_while_statement -> WHILE BoolExpr . DO open_statement
    (52) closed_while_statement -> WHILE BoolExpr . DO closed_statement
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

    DO              shift and go to state 112
    AND             shift and go to state 96
    OR              shift and go to state 97


state 81

    (53) open_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO open_statement
    (54) closed_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO closed_statement

    ASSIGNMENT      shift and go to state 113


state 82

    (59) assignment_statement -> Variable ASSIGNMENT . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Variable                       shift and go to state 76
    Expr                           shift and go to state 114
    const                          shift and go to state 77

state 83

    (61) goto_statement -> GOTO label .

    END             reduce using rule 61 (goto_statement -> GOTO label .)
    SEMICOLON       reduce using rule 61 (goto_statement -> GOTO label .)
    ELSE            reduce using rule 61 (goto_statement -> GOTO label .)


state 84

    (41) case_statement -> CASE case_index . OF case_element_list END
    (42) case_statement -> CASE case_index . OF case_element_list SEMICOLON END

    OF              shift and go to state 115


state 85

    (43) case_index -> Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    OF              reduce using rule 43 (case_index -> Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 86

    (67) Expr -> LPAREN . Expr RPAREN
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 116
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 87

    (87) function_heading -> FUNCTION funcName COLON return_type .

    SEMICOLON       reduce using rule 87 (function_heading -> FUNCTION funcName COLON return_type .)


state 88

    (91) return_type -> Type .

    SEMICOLON       reduce using rule 91 (return_type -> Type .)


state 89

    (88) function_heading -> FUNCTION funcName parameter_list COLON . return_type
    (91) return_type -> . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 62
    REAL            shift and go to state 63
    BOOLEAN         shift and go to state 64
    ID              shift and go to state 29

    return_type                    shift and go to state 117
    Type                           shift and go to state 88
    arrayName                      shift and go to state 65

state 90

    (89) parameter_list -> LPAREN VarDefList . RPAREN
    (4) VarDefList -> VarDefList . SEMICOLON VarDefState

    RPAREN          shift and go to state 118
    SEMICOLON       shift and go to state 119


state 91

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY . LBRAC index_list RBRAC OF Type

    LBRAC           shift and go to state 120


state 92

    (22) StateList -> StateList SEMICOLON Statement .

    END             reduce using rule 22 (StateList -> StateList SEMICOLON Statement .)
    SEMICOLON       reduce using rule 22 (StateList -> StateList SEMICOLON Statement .)


state 93

    (26) open_statement -> label COLON non_labeled_open_statement .

    END             reduce using rule 26 (open_statement -> label COLON non_labeled_open_statement .)
    SEMICOLON       reduce using rule 26 (open_statement -> label COLON non_labeled_open_statement .)


state 94

    (28) closed_statement -> label COLON non_labeled_closed_statement .

    END             reduce using rule 28 (closed_statement -> label COLON non_labeled_closed_statement .)
    SEMICOLON       reduce using rule 28 (closed_statement -> label COLON non_labeled_closed_statement .)
    ELSE            reduce using rule 28 (closed_statement -> label COLON non_labeled_closed_statement .)


state 95

    (48) open_if_statement -> IF BoolExpr THEN . Statement
    (49) open_if_statement -> IF BoolExpr THEN . closed_statement ELSE open_statement
    (50) closed_if_statement -> IF BoolExpr THEN . closed_statement ELSE closed_statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (62) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    BEGIN           shift and go to state 21
    IF              shift and go to state 121
    WHILE           shift and go to state 125
    FOR             shift and go to state 126
    GOTO            shift and go to state 53
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    Statement                      shift and go to state 122
    closed_statement               shift and go to state 123
    open_statement                 shift and go to state 32
    label                          shift and go to state 124
    non_labeled_closed_statement   shift and go to state 36
    non_labeled_open_statement     shift and go to state 35
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    Variable                       shift and go to state 52

state 96

    (79) BoolExpr -> BoolExpr AND . BoolExpr
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 73
    LPAREN          shift and go to state 74
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    BoolExpr                       shift and go to state 127
    Expr                           shift and go to state 72
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 97

    (80) BoolExpr -> BoolExpr OR . BoolExpr
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 73
    LPAREN          shift and go to state 74
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    BoolExpr                       shift and go to state 128
    Expr                           shift and go to state 72
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 98

    (73) BoolExpr -> Expr LT . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 129
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 99

    (74) BoolExpr -> Expr LE . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 130
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 100

    (75) BoolExpr -> Expr GT . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 131
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 101

    (76) BoolExpr -> Expr GE . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 132
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 102

    (77) BoolExpr -> Expr EQ . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 133
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 103

    (78) BoolExpr -> Expr NE . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 134
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 104

    (63) Expr -> Expr PLUS . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 135
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 105

    (64) Expr -> Expr MINUS . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 136
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 106

    (65) Expr -> Expr TIMES . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 137
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 107

    (66) Expr -> Expr DIVIDE . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Expr                           shift and go to state 138
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 108

    (81) BoolExpr -> NOT BoolExpr .
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 81 (BoolExpr -> NOT BoolExpr .)
    DO              reduce using rule 81 (BoolExpr -> NOT BoolExpr .)
    RPAREN          reduce using rule 81 (BoolExpr -> NOT BoolExpr .)
    AND             shift and go to state 96
    OR              shift and go to state 97

  ! AND             [ reduce using rule 81 (BoolExpr -> NOT BoolExpr .) ]
  ! OR              [ reduce using rule 81 (BoolExpr -> NOT BoolExpr .) ]


state 109

    (82) BoolExpr -> LPAREN BoolExpr . RPAREN
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

    RPAREN          shift and go to state 139
    AND             shift and go to state 96
    OR              shift and go to state 97


state 110

    (67) Expr -> LPAREN Expr . RPAREN
    (73) BoolExpr -> Expr . LT Expr
    (74) BoolExpr -> Expr . LE Expr
    (75) BoolExpr -> Expr . GT Expr
    (76) BoolExpr -> Expr . GE Expr
    (77) BoolExpr -> Expr . EQ Expr
    (78) BoolExpr -> Expr . NE Expr
    (83) BoolExpr -> Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 140
    LT              shift and go to state 98
    LE              shift and go to state 99
    GT              shift and go to state 100
    GE              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    AND             reduce using rule 83 (BoolExpr -> Expr .)
    OR              reduce using rule 83 (BoolExpr -> Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107

  ! RPAREN          [ reduce using rule 83 (BoolExpr -> Expr .) ]


state 111

    (68) Expr -> MINUS Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 68 (Expr -> MINUS Expr .)
    LE              reduce using rule 68 (Expr -> MINUS Expr .)
    GT              reduce using rule 68 (Expr -> MINUS Expr .)
    GE              reduce using rule 68 (Expr -> MINUS Expr .)
    EQ              reduce using rule 68 (Expr -> MINUS Expr .)
    NE              reduce using rule 68 (Expr -> MINUS Expr .)
    PLUS            reduce using rule 68 (Expr -> MINUS Expr .)
    MINUS           reduce using rule 68 (Expr -> MINUS Expr .)
    TIMES           reduce using rule 68 (Expr -> MINUS Expr .)
    DIVIDE          reduce using rule 68 (Expr -> MINUS Expr .)
    THEN            reduce using rule 68 (Expr -> MINUS Expr .)
    AND             reduce using rule 68 (Expr -> MINUS Expr .)
    OR              reduce using rule 68 (Expr -> MINUS Expr .)
    DO              reduce using rule 68 (Expr -> MINUS Expr .)
    OF              reduce using rule 68 (Expr -> MINUS Expr .)
    RPAREN          reduce using rule 68 (Expr -> MINUS Expr .)
    END             reduce using rule 68 (Expr -> MINUS Expr .)
    SEMICOLON       reduce using rule 68 (Expr -> MINUS Expr .)
    ELSE            reduce using rule 68 (Expr -> MINUS Expr .)
    TO              reduce using rule 68 (Expr -> MINUS Expr .)
    DOWNTO          reduce using rule 68 (Expr -> MINUS Expr .)

  ! PLUS            [ shift and go to state 104 ]
  ! MINUS           [ shift and go to state 105 ]
  ! TIMES           [ shift and go to state 106 ]
  ! DIVIDE          [ shift and go to state 107 ]


state 112

    (51) open_while_statement -> WHILE BoolExpr DO . open_statement
    (52) closed_while_statement -> WHILE BoolExpr DO . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 53
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    ELSE            reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    open_statement                 shift and go to state 141
    closed_statement               shift and go to state 142
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    Variable                       shift and go to state 52

state 113

    (53) open_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO open_statement
    (54) closed_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO closed_statement
    (55) initial_value -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Variable                       shift and go to state 76
    initial_value                  shift and go to state 143
    Expr                           shift and go to state 144
    const                          shift and go to state 77

state 114

    (59) assignment_statement -> Variable ASSIGNMENT Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    END             reduce using rule 59 (assignment_statement -> Variable ASSIGNMENT Expr .)
    SEMICOLON       reduce using rule 59 (assignment_statement -> Variable ASSIGNMENT Expr .)
    ELSE            reduce using rule 59 (assignment_statement -> Variable ASSIGNMENT Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 115

    (41) case_statement -> CASE case_index OF . case_element_list END
    (42) case_statement -> CASE case_index OF . case_element_list SEMICOLON END
    (44) case_element_list -> . case_element_list SEMICOLON case_element
    (45) case_element_list -> . case_element
    (46) case_element -> . case_constant COLON Statement
    (47) case_constant -> . const
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    case_element_list              shift and go to state 145
    case_element                   shift and go to state 146
    case_constant                  shift and go to state 147
    const                          shift and go to state 148

state 116

    (67) Expr -> LPAREN Expr . RPAREN
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    RPAREN          shift and go to state 140
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 117

    (88) function_heading -> FUNCTION funcName parameter_list COLON return_type .

    SEMICOLON       reduce using rule 88 (function_heading -> FUNCTION funcName parameter_list COLON return_type .)


state 118

    (89) parameter_list -> LPAREN VarDefList RPAREN .

    COLON           reduce using rule 89 (parameter_list -> LPAREN VarDefList RPAREN .)


state 119

    (4) VarDefList -> VarDefList SEMICOLON . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    TYPE            shift and go to state 18
    ID              shift and go to state 19

    VarDefState                    shift and go to state 60
    VarList                        shift and go to state 15
    ArrayDefState                  shift and go to state 16
    Variable                       shift and go to state 17

state 120

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC . index_list RBRAC OF Type
    (12) index_list -> . index_list COMMA index
    (13) index_list -> . index
    (14) index -> . startIndex DOTDOT endIndex
    (20) startIndex -> . const
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    index_list                     shift and go to state 149
    index                          shift and go to state 150
    startIndex                     shift and go to state 151
    const                          shift and go to state 152

state 121

    (50) closed_if_statement -> IF . BoolExpr THEN closed_statement ELSE closed_statement
    (48) open_if_statement -> IF . BoolExpr THEN Statement
    (49) open_if_statement -> IF . BoolExpr THEN closed_statement ELSE open_statement
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 73
    LPAREN          shift and go to state 74
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    BoolExpr                       shift and go to state 153
    Expr                           shift and go to state 72
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 122

    (48) open_if_statement -> IF BoolExpr THEN Statement .

    END             reduce using rule 48 (open_if_statement -> IF BoolExpr THEN Statement .)
    SEMICOLON       reduce using rule 48 (open_if_statement -> IF BoolExpr THEN Statement .)


state 123

    (49) open_if_statement -> IF BoolExpr THEN closed_statement . ELSE open_statement
    (50) closed_if_statement -> IF BoolExpr THEN closed_statement . ELSE closed_statement
    (25) Statement -> closed_statement .

    ELSE            shift and go to state 154
    END             reduce using rule 25 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 25 (Statement -> closed_statement .)


state 124

    (28) closed_statement -> label . COLON non_labeled_closed_statement
    (26) open_statement -> label . COLON non_labeled_open_statement

    COLON           shift and go to state 155


state 125

    (52) closed_while_statement -> WHILE . BoolExpr DO closed_statement
    (51) open_while_statement -> WHILE . BoolExpr DO open_statement
    (73) BoolExpr -> . Expr LT Expr
    (74) BoolExpr -> . Expr LE Expr
    (75) BoolExpr -> . Expr GT Expr
    (76) BoolExpr -> . Expr GE Expr
    (77) BoolExpr -> . Expr EQ Expr
    (78) BoolExpr -> . Expr NE Expr
    (79) BoolExpr -> . BoolExpr AND BoolExpr
    (80) BoolExpr -> . BoolExpr OR BoolExpr
    (81) BoolExpr -> . NOT BoolExpr
    (82) BoolExpr -> . LPAREN BoolExpr RPAREN
    (83) BoolExpr -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    NOT             shift and go to state 73
    LPAREN          shift and go to state 74
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    BoolExpr                       shift and go to state 156
    Expr                           shift and go to state 72
    Variable                       shift and go to state 76
    const                          shift and go to state 77

state 126

    (54) closed_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (53) open_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    ID              shift and go to state 19

    Variable                       shift and go to state 157

state 127

    (79) BoolExpr -> BoolExpr AND BoolExpr .
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 79 (BoolExpr -> BoolExpr AND BoolExpr .)
    DO              reduce using rule 79 (BoolExpr -> BoolExpr AND BoolExpr .)
    RPAREN          reduce using rule 79 (BoolExpr -> BoolExpr AND BoolExpr .)
    AND             shift and go to state 96
    OR              shift and go to state 97

  ! AND             [ reduce using rule 79 (BoolExpr -> BoolExpr AND BoolExpr .) ]
  ! OR              [ reduce using rule 79 (BoolExpr -> BoolExpr AND BoolExpr .) ]


state 128

    (80) BoolExpr -> BoolExpr OR BoolExpr .
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 80 (BoolExpr -> BoolExpr OR BoolExpr .)
    DO              reduce using rule 80 (BoolExpr -> BoolExpr OR BoolExpr .)
    RPAREN          reduce using rule 80 (BoolExpr -> BoolExpr OR BoolExpr .)
    AND             shift and go to state 96
    OR              shift and go to state 97

  ! AND             [ reduce using rule 80 (BoolExpr -> BoolExpr OR BoolExpr .) ]
  ! OR              [ reduce using rule 80 (BoolExpr -> BoolExpr OR BoolExpr .) ]


state 129

    (73) BoolExpr -> Expr LT Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 73 (BoolExpr -> Expr LT Expr .)
    AND             reduce using rule 73 (BoolExpr -> Expr LT Expr .)
    OR              reduce using rule 73 (BoolExpr -> Expr LT Expr .)
    DO              reduce using rule 73 (BoolExpr -> Expr LT Expr .)
    RPAREN          reduce using rule 73 (BoolExpr -> Expr LT Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 130

    (74) BoolExpr -> Expr LE Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 74 (BoolExpr -> Expr LE Expr .)
    AND             reduce using rule 74 (BoolExpr -> Expr LE Expr .)
    OR              reduce using rule 74 (BoolExpr -> Expr LE Expr .)
    DO              reduce using rule 74 (BoolExpr -> Expr LE Expr .)
    RPAREN          reduce using rule 74 (BoolExpr -> Expr LE Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 131

    (75) BoolExpr -> Expr GT Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 75 (BoolExpr -> Expr GT Expr .)
    AND             reduce using rule 75 (BoolExpr -> Expr GT Expr .)
    OR              reduce using rule 75 (BoolExpr -> Expr GT Expr .)
    DO              reduce using rule 75 (BoolExpr -> Expr GT Expr .)
    RPAREN          reduce using rule 75 (BoolExpr -> Expr GT Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 132

    (76) BoolExpr -> Expr GE Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 76 (BoolExpr -> Expr GE Expr .)
    AND             reduce using rule 76 (BoolExpr -> Expr GE Expr .)
    OR              reduce using rule 76 (BoolExpr -> Expr GE Expr .)
    DO              reduce using rule 76 (BoolExpr -> Expr GE Expr .)
    RPAREN          reduce using rule 76 (BoolExpr -> Expr GE Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 133

    (77) BoolExpr -> Expr EQ Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 77 (BoolExpr -> Expr EQ Expr .)
    AND             reduce using rule 77 (BoolExpr -> Expr EQ Expr .)
    OR              reduce using rule 77 (BoolExpr -> Expr EQ Expr .)
    DO              reduce using rule 77 (BoolExpr -> Expr EQ Expr .)
    RPAREN          reduce using rule 77 (BoolExpr -> Expr EQ Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 134

    (78) BoolExpr -> Expr NE Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 78 (BoolExpr -> Expr NE Expr .)
    AND             reduce using rule 78 (BoolExpr -> Expr NE Expr .)
    OR              reduce using rule 78 (BoolExpr -> Expr NE Expr .)
    DO              reduce using rule 78 (BoolExpr -> Expr NE Expr .)
    RPAREN          reduce using rule 78 (BoolExpr -> Expr NE Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 135

    (63) Expr -> Expr PLUS Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    LE              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    GT              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    GE              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    EQ              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    NE              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    PLUS            reduce using rule 63 (Expr -> Expr PLUS Expr .)
    MINUS           reduce using rule 63 (Expr -> Expr PLUS Expr .)
    THEN            reduce using rule 63 (Expr -> Expr PLUS Expr .)
    AND             reduce using rule 63 (Expr -> Expr PLUS Expr .)
    OR              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    DO              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    OF              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    RPAREN          reduce using rule 63 (Expr -> Expr PLUS Expr .)
    END             reduce using rule 63 (Expr -> Expr PLUS Expr .)
    SEMICOLON       reduce using rule 63 (Expr -> Expr PLUS Expr .)
    ELSE            reduce using rule 63 (Expr -> Expr PLUS Expr .)
    TO              reduce using rule 63 (Expr -> Expr PLUS Expr .)
    DOWNTO          reduce using rule 63 (Expr -> Expr PLUS Expr .)
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107

  ! TIMES           [ reduce using rule 63 (Expr -> Expr PLUS Expr .) ]
  ! DIVIDE          [ reduce using rule 63 (Expr -> Expr PLUS Expr .) ]
  ! PLUS            [ shift and go to state 104 ]
  ! MINUS           [ shift and go to state 105 ]


state 136

    (64) Expr -> Expr MINUS Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    LE              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    GT              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    GE              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    EQ              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    NE              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    PLUS            reduce using rule 64 (Expr -> Expr MINUS Expr .)
    MINUS           reduce using rule 64 (Expr -> Expr MINUS Expr .)
    THEN            reduce using rule 64 (Expr -> Expr MINUS Expr .)
    AND             reduce using rule 64 (Expr -> Expr MINUS Expr .)
    OR              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    DO              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    OF              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    RPAREN          reduce using rule 64 (Expr -> Expr MINUS Expr .)
    END             reduce using rule 64 (Expr -> Expr MINUS Expr .)
    SEMICOLON       reduce using rule 64 (Expr -> Expr MINUS Expr .)
    ELSE            reduce using rule 64 (Expr -> Expr MINUS Expr .)
    TO              reduce using rule 64 (Expr -> Expr MINUS Expr .)
    DOWNTO          reduce using rule 64 (Expr -> Expr MINUS Expr .)
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107

  ! TIMES           [ reduce using rule 64 (Expr -> Expr MINUS Expr .) ]
  ! DIVIDE          [ reduce using rule 64 (Expr -> Expr MINUS Expr .) ]
  ! PLUS            [ shift and go to state 104 ]
  ! MINUS           [ shift and go to state 105 ]


state 137

    (65) Expr -> Expr TIMES Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    LE              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    GT              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    GE              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    EQ              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    NE              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    PLUS            reduce using rule 65 (Expr -> Expr TIMES Expr .)
    MINUS           reduce using rule 65 (Expr -> Expr TIMES Expr .)
    TIMES           reduce using rule 65 (Expr -> Expr TIMES Expr .)
    DIVIDE          reduce using rule 65 (Expr -> Expr TIMES Expr .)
    THEN            reduce using rule 65 (Expr -> Expr TIMES Expr .)
    AND             reduce using rule 65 (Expr -> Expr TIMES Expr .)
    OR              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    DO              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    OF              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    RPAREN          reduce using rule 65 (Expr -> Expr TIMES Expr .)
    END             reduce using rule 65 (Expr -> Expr TIMES Expr .)
    SEMICOLON       reduce using rule 65 (Expr -> Expr TIMES Expr .)
    ELSE            reduce using rule 65 (Expr -> Expr TIMES Expr .)
    TO              reduce using rule 65 (Expr -> Expr TIMES Expr .)
    DOWNTO          reduce using rule 65 (Expr -> Expr TIMES Expr .)

  ! PLUS            [ shift and go to state 104 ]
  ! MINUS           [ shift and go to state 105 ]
  ! TIMES           [ shift and go to state 106 ]
  ! DIVIDE          [ shift and go to state 107 ]


state 138

    (66) Expr -> Expr DIVIDE Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    LE              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    GT              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    GE              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    EQ              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    NE              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    PLUS            reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    MINUS           reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    TIMES           reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    DIVIDE          reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    THEN            reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    AND             reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    OR              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    DO              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    OF              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    RPAREN          reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    END             reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    SEMICOLON       reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    ELSE            reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    TO              reduce using rule 66 (Expr -> Expr DIVIDE Expr .)
    DOWNTO          reduce using rule 66 (Expr -> Expr DIVIDE Expr .)

  ! PLUS            [ shift and go to state 104 ]
  ! MINUS           [ shift and go to state 105 ]
  ! TIMES           [ shift and go to state 106 ]
  ! DIVIDE          [ shift and go to state 107 ]


state 139

    (82) BoolExpr -> LPAREN BoolExpr RPAREN .

    THEN            reduce using rule 82 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    AND             reduce using rule 82 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    OR              reduce using rule 82 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    DO              reduce using rule 82 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    RPAREN          reduce using rule 82 (BoolExpr -> LPAREN BoolExpr RPAREN .)


state 140

    (67) Expr -> LPAREN Expr RPAREN .

    LT              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    LE              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    GT              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    GE              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    EQ              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    NE              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    PLUS            reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    MINUS           reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    TIMES           reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    DIVIDE          reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    THEN            reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    AND             reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    OR              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    DO              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    OF              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    RPAREN          reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    END             reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    SEMICOLON       reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    ELSE            reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    TO              reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)
    DOWNTO          reduce using rule 67 (Expr -> LPAREN Expr RPAREN .)


state 141

    (51) open_while_statement -> WHILE BoolExpr DO open_statement .

    END             reduce using rule 51 (open_while_statement -> WHILE BoolExpr DO open_statement .)
    SEMICOLON       reduce using rule 51 (open_while_statement -> WHILE BoolExpr DO open_statement .)


state 142

    (52) closed_while_statement -> WHILE BoolExpr DO closed_statement .

    END             reduce using rule 52 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)
    SEMICOLON       reduce using rule 52 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)
    ELSE            reduce using rule 52 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)


state 143

    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO open_statement
    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO closed_statement
    (57) direction -> . TO
    (58) direction -> . DOWNTO

    TO              shift and go to state 159
    DOWNTO          shift and go to state 160

    direction                      shift and go to state 158

state 144

    (55) initial_value -> Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    TO              reduce using rule 55 (initial_value -> Expr .)
    DOWNTO          reduce using rule 55 (initial_value -> Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 145

    (41) case_statement -> CASE case_index OF case_element_list . END
    (42) case_statement -> CASE case_index OF case_element_list . SEMICOLON END
    (44) case_element_list -> case_element_list . SEMICOLON case_element

    END             shift and go to state 161
    SEMICOLON       shift and go to state 162


state 146

    (45) case_element_list -> case_element .

    END             reduce using rule 45 (case_element_list -> case_element .)
    SEMICOLON       reduce using rule 45 (case_element_list -> case_element .)


state 147

    (46) case_element -> case_constant . COLON Statement

    COLON           shift and go to state 163


state 148

    (47) case_constant -> const .

    COLON           reduce using rule 47 (case_constant -> const .)


state 149

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list . RBRAC OF Type
    (12) index_list -> index_list . COMMA index

    RBRAC           shift and go to state 164
    COMMA           shift and go to state 165


state 150

    (13) index_list -> index .

    RBRAC           reduce using rule 13 (index_list -> index .)
    COMMA           reduce using rule 13 (index_list -> index .)


state 151

    (14) index -> startIndex . DOTDOT endIndex

    DOTDOT          shift and go to state 166


state 152

    (20) startIndex -> const .

    DOTDOT          reduce using rule 20 (startIndex -> const .)


state 153

    (50) closed_if_statement -> IF BoolExpr . THEN closed_statement ELSE closed_statement
    (48) open_if_statement -> IF BoolExpr . THEN Statement
    (49) open_if_statement -> IF BoolExpr . THEN closed_statement ELSE open_statement
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

    THEN            shift and go to state 167
    AND             shift and go to state 96
    OR              shift and go to state 97


state 154

    (49) open_if_statement -> IF BoolExpr THEN closed_statement ELSE . open_statement
    (50) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 53
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    ELSE            reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    closed_statement               shift and go to state 168
    open_statement                 shift and go to state 169
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    Variable                       shift and go to state 52

state 155

    (28) closed_statement -> label COLON . non_labeled_closed_statement
    (26) open_statement -> label COLON . non_labeled_open_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    BEGIN           shift and go to state 21
    IF              shift and go to state 121
    WHILE           shift and go to state 125
    FOR             shift and go to state 126
    GOTO            shift and go to state 53
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    non_labeled_closed_statement   shift and go to state 94
    non_labeled_open_statement     shift and go to state 93
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    Variable                       shift and go to state 52

state 156

    (52) closed_while_statement -> WHILE BoolExpr . DO closed_statement
    (51) open_while_statement -> WHILE BoolExpr . DO open_statement
    (79) BoolExpr -> BoolExpr . AND BoolExpr
    (80) BoolExpr -> BoolExpr . OR BoolExpr

    DO              shift and go to state 170
    AND             shift and go to state 96
    OR              shift and go to state 97


state 157

    (54) closed_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO closed_statement
    (53) open_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO open_statement

    ASSIGNMENT      shift and go to state 171


state 158

    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO open_statement
    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO closed_statement
    (56) final_value -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Variable                       shift and go to state 76
    final_value                    shift and go to state 172
    Expr                           shift and go to state 173
    const                          shift and go to state 77

state 159

    (57) direction -> TO .

    LPAREN          reduce using rule 57 (direction -> TO .)
    MINUS           reduce using rule 57 (direction -> TO .)
    ID              reduce using rule 57 (direction -> TO .)
    INT_NUMBER      reduce using rule 57 (direction -> TO .)
    REAL_NUMBER     reduce using rule 57 (direction -> TO .)


state 160

    (58) direction -> DOWNTO .

    LPAREN          reduce using rule 58 (direction -> DOWNTO .)
    MINUS           reduce using rule 58 (direction -> DOWNTO .)
    ID              reduce using rule 58 (direction -> DOWNTO .)
    INT_NUMBER      reduce using rule 58 (direction -> DOWNTO .)
    REAL_NUMBER     reduce using rule 58 (direction -> DOWNTO .)


state 161

    (41) case_statement -> CASE case_index OF case_element_list END .

    END             reduce using rule 41 (case_statement -> CASE case_index OF case_element_list END .)
    SEMICOLON       reduce using rule 41 (case_statement -> CASE case_index OF case_element_list END .)
    ELSE            reduce using rule 41 (case_statement -> CASE case_index OF case_element_list END .)


state 162

    (42) case_statement -> CASE case_index OF case_element_list SEMICOLON . END
    (44) case_element_list -> case_element_list SEMICOLON . case_element
    (46) case_element -> . case_constant COLON Statement
    (47) case_constant -> . const
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    END             shift and go to state 174
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    case_element                   shift and go to state 175
    case_constant                  shift and go to state 147
    const                          shift and go to state 148

state 163

    (46) case_element -> case_constant COLON . Statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 53
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    Statement                      shift and go to state 176
    open_statement                 shift and go to state 32
    closed_statement               shift and go to state 33
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    Variable                       shift and go to state 52

state 164

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC . OF Type

    OF              shift and go to state 177


state 165

    (12) index_list -> index_list COMMA . index
    (14) index -> . startIndex DOTDOT endIndex
    (20) startIndex -> . const
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    index                          shift and go to state 178
    startIndex                     shift and go to state 151
    const                          shift and go to state 152

state 166

    (14) index -> startIndex DOTDOT . endIndex
    (21) endIndex -> . const
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    endIndex                       shift and go to state 179
    const                          shift and go to state 180

state 167

    (50) closed_if_statement -> IF BoolExpr THEN . closed_statement ELSE closed_statement
    (48) open_if_statement -> IF BoolExpr THEN . Statement
    (49) open_if_statement -> IF BoolExpr THEN . closed_statement ELSE open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (24) Statement -> . open_statement
    (25) Statement -> . closed_statement
    (62) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (19) Variable -> . ID
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement

    DIGSEQ          shift and go to state 37
    BEGIN           shift and go to state 21
    IF              shift and go to state 121
    WHILE           shift and go to state 125
    FOR             shift and go to state 126
    GOTO            shift and go to state 53
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    closed_statement               shift and go to state 181
    Statement                      shift and go to state 122
    open_statement                 shift and go to state 32
    label                          shift and go to state 124
    non_labeled_closed_statement   shift and go to state 36
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    non_labeled_open_statement     shift and go to state 35
    Variable                       shift and go to state 52
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40

state 168

    (50) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .

    END             reduce using rule 50 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)
    SEMICOLON       reduce using rule 50 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)
    ELSE            reduce using rule 50 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)


state 169

    (49) open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .

    END             reduce using rule 49 (open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .)
    SEMICOLON       reduce using rule 49 (open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .)


state 170

    (52) closed_while_statement -> WHILE BoolExpr DO . closed_statement
    (51) open_while_statement -> WHILE BoolExpr DO . open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (62) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    BEGIN           shift and go to state 21
    IF              shift and go to state 121
    WHILE           shift and go to state 125
    FOR             shift and go to state 126
    GOTO            shift and go to state 53
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    closed_statement               shift and go to state 142
    open_statement                 shift and go to state 141
    label                          shift and go to state 124
    non_labeled_closed_statement   shift and go to state 36
    non_labeled_open_statement     shift and go to state 35
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    Variable                       shift and go to state 52

state 171

    (54) closed_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO closed_statement
    (53) open_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO open_statement
    (55) initial_value -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Variable                       shift and go to state 76
    initial_value                  shift and go to state 182
    Expr                           shift and go to state 144
    const                          shift and go to state 77

state 172

    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO open_statement
    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO closed_statement

    DO              shift and go to state 183


state 173

    (56) final_value -> Expr .
    (63) Expr -> Expr . PLUS Expr
    (64) Expr -> Expr . MINUS Expr
    (65) Expr -> Expr . TIMES Expr
    (66) Expr -> Expr . DIVIDE Expr

    DO              reduce using rule 56 (final_value -> Expr .)
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107


state 174

    (42) case_statement -> CASE case_index OF case_element_list SEMICOLON END .

    END             reduce using rule 42 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)
    SEMICOLON       reduce using rule 42 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)
    ELSE            reduce using rule 42 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)


state 175

    (44) case_element_list -> case_element_list SEMICOLON case_element .

    END             reduce using rule 44 (case_element_list -> case_element_list SEMICOLON case_element .)
    SEMICOLON       reduce using rule 44 (case_element_list -> case_element_list SEMICOLON case_element .)


state 176

    (46) case_element -> case_constant COLON Statement .

    END             reduce using rule 46 (case_element -> case_constant COLON Statement .)
    SEMICOLON       reduce using rule 46 (case_element -> case_constant COLON Statement .)


state 177

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 62
    REAL            shift and go to state 63
    BOOLEAN         shift and go to state 64
    ID              shift and go to state 29

    arrayName                      shift and go to state 65
    Type                           shift and go to state 184

state 178

    (12) index_list -> index_list COMMA index .

    RBRAC           reduce using rule 12 (index_list -> index_list COMMA index .)
    COMMA           reduce using rule 12 (index_list -> index_list COMMA index .)


state 179

    (14) index -> startIndex DOTDOT endIndex .

    RBRAC           reduce using rule 14 (index -> startIndex DOTDOT endIndex .)
    COMMA           reduce using rule 14 (index -> startIndex DOTDOT endIndex .)


state 180

    (21) endIndex -> const .

    RBRAC           reduce using rule 21 (endIndex -> const .)
    COMMA           reduce using rule 21 (endIndex -> const .)


state 181

    (50) closed_if_statement -> IF BoolExpr THEN closed_statement . ELSE closed_statement
    (49) open_if_statement -> IF BoolExpr THEN closed_statement . ELSE open_statement
    (25) Statement -> closed_statement .

    ELSE            shift and go to state 185
    END             reduce using rule 25 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 25 (Statement -> closed_statement .)


state 182

    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO closed_statement
    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO open_statement
    (57) direction -> . TO
    (58) direction -> . DOWNTO

    TO              shift and go to state 159
    DOWNTO          shift and go to state 160

    direction                      shift and go to state 186

state 183

    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . open_statement
    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (62) label -> . DIGSEQ
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    BEGIN           shift and go to state 21
    GOTO            shift and go to state 53
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    ELSE            reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    Variable                       shift and go to state 52
    open_statement                 shift and go to state 187
    closed_statement               shift and go to state 188
    label                          shift and go to state 34
    non_labeled_open_statement     shift and go to state 35
    non_labeled_closed_statement   shift and go to state 36
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48

state 184

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type .

    SEMICOLON       reduce using rule 10 (ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type .)
    RPAREN          reduce using rule 10 (ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type .)


state 185

    (50) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE . closed_statement
    (49) open_if_statement -> IF BoolExpr THEN closed_statement ELSE . open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (62) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    BEGIN           shift and go to state 21
    IF              shift and go to state 121
    WHILE           shift and go to state 125
    FOR             shift and go to state 126
    GOTO            shift and go to state 53
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    closed_statement               shift and go to state 168
    open_statement                 shift and go to state 169
    label                          shift and go to state 124
    non_labeled_closed_statement   shift and go to state 36
    non_labeled_open_statement     shift and go to state 35
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
    Variable                       shift and go to state 52

state 186

    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO closed_statement
    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO open_statement
    (56) final_value -> . Expr
    (63) Expr -> . Expr PLUS Expr
    (64) Expr -> . Expr MINUS Expr
    (65) Expr -> . Expr TIMES Expr
    (66) Expr -> . Expr DIVIDE Expr
    (67) Expr -> . LPAREN Expr RPAREN
    (68) Expr -> . MINUS Expr
    (69) Expr -> . Variable
    (70) Expr -> . const
    (19) Variable -> . ID
    (71) const -> . INT_NUMBER
    (72) const -> . REAL_NUMBER

    LPAREN          shift and go to state 86
    MINUS           shift and go to state 75
    ID              shift and go to state 19
    INT_NUMBER      shift and go to state 78
    REAL_NUMBER     shift and go to state 79

    Variable                       shift and go to state 76
    final_value                    shift and go to state 189
    Expr                           shift and go to state 173
    const                          shift and go to state 77

state 187

    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .

    END             reduce using rule 53 (open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .)
    SEMICOLON       reduce using rule 53 (open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .)


state 188

    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .

    END             reduce using rule 54 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)
    SEMICOLON       reduce using rule 54 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)
    ELSE            reduce using rule 54 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)


state 189

    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO closed_statement
    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO open_statement

    DO              shift and go to state 190


state 190

    (54) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . closed_statement
    (53) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . open_statement
    (28) closed_statement -> . label COLON non_labeled_closed_statement
    (29) closed_statement -> . non_labeled_closed_statement
    (26) open_statement -> . label COLON non_labeled_open_statement
    (27) open_statement -> . non_labeled_open_statement
    (62) label -> . DIGSEQ
    (33) non_labeled_closed_statement -> . assignment_statement
    (34) non_labeled_closed_statement -> . compound_statement
    (35) non_labeled_closed_statement -> . closed_if_statement
    (36) non_labeled_closed_statement -> . closed_while_statement
    (37) non_labeled_closed_statement -> . closed_for_statement
    (38) non_labeled_closed_statement -> . goto_statement
    (39) non_labeled_closed_statement -> . empty
    (40) non_labeled_closed_statement -> . case_statement
    (30) non_labeled_open_statement -> . open_if_statement
    (31) non_labeled_open_statement -> . open_while_statement
    (32) non_labeled_open_statement -> . open_for_statement
    (59) assignment_statement -> . Variable ASSIGNMENT Expr
    (60) compound_statement -> . BEGIN StateList END
    (50) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (52) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (54) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) goto_statement -> . GOTO label
    (84) empty -> .
    (41) case_statement -> . CASE case_index OF case_element_list END
    (42) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (48) open_if_statement -> . IF BoolExpr THEN Statement
    (49) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (51) open_while_statement -> . WHILE BoolExpr DO open_statement
    (53) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 37
    BEGIN           shift and go to state 21
    IF              shift and go to state 121
    WHILE           shift and go to state 125
    FOR             shift and go to state 126
    GOTO            shift and go to state 53
    ELSE            reduce using rule 84 (empty -> .)
    END             reduce using rule 84 (empty -> .)
    SEMICOLON       reduce using rule 84 (empty -> .)
    CASE            shift and go to state 54
    ID              shift and go to state 19

    Variable                       shift and go to state 52
    closed_statement               shift and go to state 188
    open_statement                 shift and go to state 187
    label                          shift and go to state 124
    non_labeled_closed_statement   shift and go to state 36
    non_labeled_open_statement     shift and go to state 35
    assignment_statement           shift and go to state 41
    compound_statement             shift and go to state 42
    closed_if_statement            shift and go to state 43
    closed_while_statement         shift and go to state 44
    closed_for_statement           shift and go to state 45
    goto_statement                 shift and go to state 46
    empty                          shift and go to state 47
    case_statement                 shift and go to state 48
    open_if_statement              shift and go to state 38
    open_while_statement           shift and go to state 39
    open_for_statement             shift and go to state 40
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 108 resolved as shift
WARNING: shift/reduce conflict for OR in state 108 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 110 resolved as shift
WARNING: shift/reduce conflict for AND in state 127 resolved as shift
WARNING: shift/reduce conflict for OR in state 127 resolved as shift
WARNING: shift/reduce conflict for AND in state 128 resolved as shift
WARNING: shift/reduce conflict for OR in state 128 resolved as shift
