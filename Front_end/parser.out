Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    LLAVEI
    LLAVED
    MOD
    RETURN
    CHAR
    STRING
    USES
    CONST

Grammar

Rule 0     S' -> ProgDef
Rule 1     ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT
Rule 2     SubProg -> VarDef label_declaration_part function_definition compound_statement
Rule 3     VarDef -> VAR VarDefList SEMICOLON
Rule 4     VarDefList -> VarDefList SEMICOLON VarDefState
Rule 5     VarDefList -> VarDefState
Rule 6     VarDefState -> VarList COLON Type
Rule 7     VarDefState -> ArrayDefState
Rule 8     VarList -> VarList COMMA Variable
Rule 9     VarList -> Variable
Rule 10    ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
Rule 11    arrayName -> ID
Rule 12    index_list -> index_list COMMA index
Rule 13    index_list -> index
Rule 14    index -> startIndex DOTDOT endIndex
Rule 15    Type -> INTEGER
Rule 16    Type -> REAL
Rule 17    Type -> BOOLEAN
Rule 18    Type -> arrayName
Rule 19    Variable -> ID
Rule 20    startIndex -> const
Rule 21    endIndex -> const
Rule 22    label_declaration_part -> LABEL label_list SEMICOLON
Rule 23    label_declaration_part -> empty
Rule 24    label_list -> label_list COMMA label
Rule 25    label_list -> label
Rule 26    StateList -> StateList SEMICOLON Statement
Rule 27    StateList -> Statement
Rule 28    Statement -> open_statement
Rule 29    Statement -> closed_statement
Rule 30    open_statement -> label COLON non_labeled_open_statement
Rule 31    open_statement -> non_labeled_open_statement
Rule 32    closed_statement -> label COLON non_labeled_closed_statement
Rule 33    closed_statement -> non_labeled_closed_statement
Rule 34    non_labeled_open_statement -> open_if_statement
Rule 35    non_labeled_open_statement -> open_while_statement
Rule 36    non_labeled_open_statement -> open_for_statement
Rule 37    non_labeled_closed_statement -> assignment_statement
Rule 38    non_labeled_closed_statement -> compound_statement
Rule 39    non_labeled_closed_statement -> closed_if_statement
Rule 40    non_labeled_closed_statement -> closed_while_statement
Rule 41    non_labeled_closed_statement -> closed_for_statement
Rule 42    non_labeled_closed_statement -> goto_statement
Rule 43    non_labeled_closed_statement -> empty
Rule 44    non_labeled_closed_statement -> case_statement
Rule 45    non_labeled_closed_statement -> continue_statement
Rule 46    continue_statement -> CONTINUE
Rule 47    non_labeled_closed_statement -> break_statement
Rule 48    break_statement -> BREAK
Rule 49    case_statement -> CASE case_index OF case_element_list END
Rule 50    case_statement -> CASE case_index OF case_element_list SEMICOLON END
Rule 51    case_index -> Expr
Rule 52    case_element_list -> case_element_list SEMICOLON case_element
Rule 53    case_element_list -> case_element
Rule 54    case_element -> case_constant COLON Statement
Rule 55    case_constant -> const
Rule 56    open_if_statement -> IF BoolExpr THEN Statement
Rule 57    open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement
Rule 58    closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement
Rule 59    open_while_statement -> WHILE BoolExpr DO open_statement
Rule 60    closed_while_statement -> WHILE BoolExpr DO closed_statement
Rule 61    open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
Rule 62    closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
Rule 63    initial_value -> Expr
Rule 64    final_value -> Expr
Rule 65    direction -> TO
Rule 66    direction -> DOWNTO
Rule 67    assignment_statement -> Variable ASSIGNMENT Expr
Rule 68    compound_statement -> BEGIN StateList END
Rule 69    goto_statement -> GOTO label
Rule 70    label -> DIGSEQ
Rule 71    Expr -> Expr PLUS Expr
Rule 72    Expr -> Expr MINUS Expr
Rule 73    Expr -> Expr TIMES Expr
Rule 74    Expr -> Expr DIVIDE Expr
Rule 75    Expr -> LPAREN Expr RPAREN
Rule 76    Expr -> MINUS Expr
Rule 77    Expr -> Variable
Rule 78    Expr -> const
Rule 79    const -> INT_NUMBER
Rule 80    const -> REAL_NUMBER
Rule 81    BoolExpr -> Expr LT Expr
Rule 82    BoolExpr -> Expr LE Expr
Rule 83    BoolExpr -> Expr GT Expr
Rule 84    BoolExpr -> Expr GE Expr
Rule 85    BoolExpr -> Expr EQ Expr
Rule 86    BoolExpr -> Expr NE Expr
Rule 87    BoolExpr -> BoolExpr AND BoolExpr
Rule 88    BoolExpr -> BoolExpr OR BoolExpr
Rule 89    BoolExpr -> NOT BoolExpr
Rule 90    BoolExpr -> LPAREN BoolExpr RPAREN
Rule 91    BoolExpr -> Expr
Rule 92    empty -> <empty>
Rule 93    function_definition -> function_heading SEMICOLON function_block
Rule 94    function_definition -> empty
Rule 95    function_heading -> FUNCTION funcName COLON return_type
Rule 96    function_heading -> FUNCTION funcName parameter_list COLON return_type
Rule 97    parameter_list -> LPAREN VarDefList RPAREN
Rule 98    funcName -> ID
Rule 99    return_type -> Type
Rule 100   function_block -> compound_statement

Terminals, with rules where they appear

AND                  : 87
ARRAY                : 10
ASSIGNMENT           : 61 62 67
BEGIN                : 68
BOOLEAN              : 17
BREAK                : 48
CASE                 : 49 50
CHAR                 : 
COLON                : 6 30 32 54 95 96
COMMA                : 8 12 24
CONST                : 
CONTINUE             : 46
DIGSEQ               : 70
DIVIDE               : 74
DO                   : 59 60 61 62
DOTDOT               : 14
DOWNTO               : 66
ELSE                 : 57 58
END                  : 49 50 68
ENDPOINT             : 1
EQ                   : 10 85
FOR                  : 61 62
FUNCTION             : 95 96
GE                   : 84
GOTO                 : 69
GT                   : 83
ID                   : 1 11 19 98
IF                   : 56 57 58
INTEGER              : 15
INT_NUMBER           : 79
LABEL                : 22
LBRAC                : 10
LE                   : 82
LLAVED               : 
LLAVEI               : 
LPAREN               : 75 90 97
LT                   : 81
MINUS                : 72 76
MOD                  : 
NE                   : 86
NOT                  : 89
OF                   : 10 49 50
OR                   : 88
PLUS                 : 71
PROGRAM              : 1
RBRAC                : 10
REAL                 : 16
REAL_NUMBER          : 80
RETURN               : 
RPAREN               : 75 90 97
SEMICOLON            : 1 3 4 22 26 50 52 93
STRING               : 
THEN                 : 56 57 58
TIMES                : 73
TO                   : 65
TYPE                 : 10
USES                 : 
VAR                  : 3
WHILE                : 59 60
error                : 

Nonterminals, with rules where they appear

ArrayDefState        : 7
BoolExpr             : 56 57 58 59 60 87 87 88 88 89 90
Expr                 : 51 63 64 67 71 71 72 72 73 73 74 74 75 76 81 81 82 82 83 83 84 84 85 85 86 86 91
ProgDef              : 0
StateList            : 26 68
Statement            : 26 27 54 56
SubProg              : 1
Type                 : 6 10 99
VarDef               : 2
VarDefList           : 3 4 97
VarDefState          : 4 5
VarList              : 6 8
Variable             : 8 9 61 62 67 77
arrayName            : 10 18
assignment_statement : 37
break_statement      : 47
case_constant        : 54
case_element         : 52 53
case_element_list    : 49 50 52
case_index           : 49 50
case_statement       : 44
closed_for_statement : 41
closed_if_statement  : 39
closed_statement     : 29 57 58 58 60 62
closed_while_statement : 40
compound_statement   : 2 38 100
const                : 20 21 55 78
continue_statement   : 45
direction            : 61 62
empty                : 23 43 94
endIndex             : 14
final_value          : 61 62
funcName             : 95 96
function_block       : 93
function_definition  : 2
function_heading     : 93
goto_statement       : 42
index                : 12 13
index_list           : 10 12
initial_value        : 61 62
label                : 24 25 30 32 69
label_declaration_part : 2
label_list           : 22 24
non_labeled_closed_statement : 32 33
non_labeled_open_statement : 30 31
open_for_statement   : 36
open_if_statement    : 34
open_statement       : 28 57 59 61
open_while_statement : 35
parameter_list       : 96
return_type          : 95 96
startIndex           : 14

Parsing method: LALR

state 0

    (0) S' -> . ProgDef
    (1) ProgDef -> . PROGRAM ID SEMICOLON SubProg ENDPOINT

    PROGRAM         shift and go to state 2

    ProgDef                        shift and go to state 1

state 1

    (0) S' -> ProgDef .



state 2

    (1) ProgDef -> PROGRAM . ID SEMICOLON SubProg ENDPOINT

    ID              shift and go to state 3


state 3

    (1) ProgDef -> PROGRAM ID . SEMICOLON SubProg ENDPOINT

    SEMICOLON       shift and go to state 4


state 4

    (1) ProgDef -> PROGRAM ID SEMICOLON . SubProg ENDPOINT
    (2) SubProg -> . VarDef label_declaration_part function_definition compound_statement
    (3) VarDef -> . VAR VarDefList SEMICOLON

    VAR             shift and go to state 7

    SubProg                        shift and go to state 5
    VarDef                         shift and go to state 6

state 5

    (1) ProgDef -> PROGRAM ID SEMICOLON SubProg . ENDPOINT

    ENDPOINT        shift and go to state 8


state 6

    (2) SubProg -> VarDef . label_declaration_part function_definition compound_statement
    (22) label_declaration_part -> . LABEL label_list SEMICOLON
    (23) label_declaration_part -> . empty
    (92) empty -> .

    LABEL           shift and go to state 10
    FUNCTION        reduce using rule 92 (empty -> .)
    BEGIN           reduce using rule 92 (empty -> .)

    label_declaration_part         shift and go to state 9
    empty                          shift and go to state 11

state 7

    (3) VarDef -> VAR . VarDefList SEMICOLON
    (4) VarDefList -> . VarDefList SEMICOLON VarDefState
    (5) VarDefList -> . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    TYPE            shift and go to state 17
    ID              shift and go to state 18

    VarDefList                     shift and go to state 12
    VarDefState                    shift and go to state 13
    VarList                        shift and go to state 14
    ArrayDefState                  shift and go to state 15
    Variable                       shift and go to state 16

state 8

    (1) ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT .

    $end            reduce using rule 1 (ProgDef -> PROGRAM ID SEMICOLON SubProg ENDPOINT .)


state 9

    (2) SubProg -> VarDef label_declaration_part . function_definition compound_statement
    (93) function_definition -> . function_heading SEMICOLON function_block
    (94) function_definition -> . empty
    (95) function_heading -> . FUNCTION funcName COLON return_type
    (96) function_heading -> . FUNCTION funcName parameter_list COLON return_type
    (92) empty -> .

    FUNCTION        shift and go to state 22
    BEGIN           reduce using rule 92 (empty -> .)

    function_definition            shift and go to state 19
    function_heading               shift and go to state 20
    empty                          shift and go to state 21

state 10

    (22) label_declaration_part -> LABEL . label_list SEMICOLON
    (24) label_list -> . label_list COMMA label
    (25) label_list -> . label
    (70) label -> . DIGSEQ

    DIGSEQ          shift and go to state 25

    label_list                     shift and go to state 23
    label                          shift and go to state 24

state 11

    (23) label_declaration_part -> empty .

    FUNCTION        reduce using rule 23 (label_declaration_part -> empty .)
    BEGIN           reduce using rule 23 (label_declaration_part -> empty .)


state 12

    (3) VarDef -> VAR VarDefList . SEMICOLON
    (4) VarDefList -> VarDefList . SEMICOLON VarDefState

    SEMICOLON       shift and go to state 26


state 13

    (5) VarDefList -> VarDefState .

    SEMICOLON       reduce using rule 5 (VarDefList -> VarDefState .)
    RPAREN          reduce using rule 5 (VarDefList -> VarDefState .)


state 14

    (6) VarDefState -> VarList . COLON Type
    (8) VarList -> VarList . COMMA Variable

    COLON           shift and go to state 27
    COMMA           shift and go to state 28


state 15

    (7) VarDefState -> ArrayDefState .

    SEMICOLON       reduce using rule 7 (VarDefState -> ArrayDefState .)
    RPAREN          reduce using rule 7 (VarDefState -> ArrayDefState .)


state 16

    (9) VarList -> Variable .

    COLON           reduce using rule 9 (VarList -> Variable .)
    COMMA           reduce using rule 9 (VarList -> Variable .)


state 17

    (10) ArrayDefState -> TYPE . arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (11) arrayName -> . ID

    ID              shift and go to state 30

    arrayName                      shift and go to state 29

state 18

    (19) Variable -> ID .

    COLON           reduce using rule 19 (Variable -> ID .)
    COMMA           reduce using rule 19 (Variable -> ID .)
    ASSIGNMENT      reduce using rule 19 (Variable -> ID .)
    LT              reduce using rule 19 (Variable -> ID .)
    LE              reduce using rule 19 (Variable -> ID .)
    GT              reduce using rule 19 (Variable -> ID .)
    GE              reduce using rule 19 (Variable -> ID .)
    EQ              reduce using rule 19 (Variable -> ID .)
    NE              reduce using rule 19 (Variable -> ID .)
    PLUS            reduce using rule 19 (Variable -> ID .)
    MINUS           reduce using rule 19 (Variable -> ID .)
    TIMES           reduce using rule 19 (Variable -> ID .)
    DIVIDE          reduce using rule 19 (Variable -> ID .)
    THEN            reduce using rule 19 (Variable -> ID .)
    AND             reduce using rule 19 (Variable -> ID .)
    OR              reduce using rule 19 (Variable -> ID .)
    DO              reduce using rule 19 (Variable -> ID .)
    OF              reduce using rule 19 (Variable -> ID .)
    RPAREN          reduce using rule 19 (Variable -> ID .)
    END             reduce using rule 19 (Variable -> ID .)
    SEMICOLON       reduce using rule 19 (Variable -> ID .)
    ELSE            reduce using rule 19 (Variable -> ID .)
    TO              reduce using rule 19 (Variable -> ID .)
    DOWNTO          reduce using rule 19 (Variable -> ID .)


state 19

    (2) SubProg -> VarDef label_declaration_part function_definition . compound_statement
    (68) compound_statement -> . BEGIN StateList END

    BEGIN           shift and go to state 32

    compound_statement             shift and go to state 31

state 20

    (93) function_definition -> function_heading . SEMICOLON function_block

    SEMICOLON       shift and go to state 33


state 21

    (94) function_definition -> empty .

    BEGIN           reduce using rule 94 (function_definition -> empty .)


state 22

    (95) function_heading -> FUNCTION . funcName COLON return_type
    (96) function_heading -> FUNCTION . funcName parameter_list COLON return_type
    (98) funcName -> . ID

    ID              shift and go to state 35

    funcName                       shift and go to state 34

state 23

    (22) label_declaration_part -> LABEL label_list . SEMICOLON
    (24) label_list -> label_list . COMMA label

    SEMICOLON       shift and go to state 36
    COMMA           shift and go to state 37


state 24

    (25) label_list -> label .

    SEMICOLON       reduce using rule 25 (label_list -> label .)
    COMMA           reduce using rule 25 (label_list -> label .)


state 25

    (70) label -> DIGSEQ .

    SEMICOLON       reduce using rule 70 (label -> DIGSEQ .)
    COMMA           reduce using rule 70 (label -> DIGSEQ .)
    COLON           reduce using rule 70 (label -> DIGSEQ .)
    END             reduce using rule 70 (label -> DIGSEQ .)
    ELSE            reduce using rule 70 (label -> DIGSEQ .)


state 26

    (3) VarDef -> VAR VarDefList SEMICOLON .
    (4) VarDefList -> VarDefList SEMICOLON . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    LABEL           reduce using rule 3 (VarDef -> VAR VarDefList SEMICOLON .)
    FUNCTION        reduce using rule 3 (VarDef -> VAR VarDefList SEMICOLON .)
    BEGIN           reduce using rule 3 (VarDef -> VAR VarDefList SEMICOLON .)
    TYPE            shift and go to state 17
    ID              shift and go to state 18

    VarDefState                    shift and go to state 38
    VarList                        shift and go to state 14
    ArrayDefState                  shift and go to state 15
    Variable                       shift and go to state 16

state 27

    (6) VarDefState -> VarList COLON . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 40
    REAL            shift and go to state 41
    BOOLEAN         shift and go to state 42
    ID              shift and go to state 30

    Type                           shift and go to state 39
    arrayName                      shift and go to state 43

state 28

    (8) VarList -> VarList COMMA . Variable
    (19) Variable -> . ID

    ID              shift and go to state 18

    Variable                       shift and go to state 44

state 29

    (10) ArrayDefState -> TYPE arrayName . EQ ARRAY LBRAC index_list RBRAC OF Type

    EQ              shift and go to state 45


state 30

    (11) arrayName -> ID .

    EQ              reduce using rule 11 (arrayName -> ID .)
    SEMICOLON       reduce using rule 11 (arrayName -> ID .)
    RPAREN          reduce using rule 11 (arrayName -> ID .)


state 31

    (2) SubProg -> VarDef label_declaration_part function_definition compound_statement .

    ENDPOINT        reduce using rule 2 (SubProg -> VarDef label_declaration_part function_definition compound_statement .)


state 32

    (68) compound_statement -> BEGIN . StateList END
    (26) StateList -> . StateList SEMICOLON Statement
    (27) StateList -> . Statement
    (28) Statement -> . open_statement
    (29) Statement -> . closed_statement
    (30) open_statement -> . label COLON non_labeled_open_statement
    (31) open_statement -> . non_labeled_open_statement
    (32) closed_statement -> . label COLON non_labeled_closed_statement
    (33) closed_statement -> . non_labeled_closed_statement
    (70) label -> . DIGSEQ
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 66
    WHILE           shift and go to state 67
    FOR             shift and go to state 68
    BEGIN           shift and go to state 32
    GOTO            shift and go to state 70
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    StateList                      shift and go to state 46
    Statement                      shift and go to state 47
    open_statement                 shift and go to state 48
    closed_statement               shift and go to state 49
    label                          shift and go to state 50
    non_labeled_open_statement     shift and go to state 51
    non_labeled_closed_statement   shift and go to state 52
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    Variable                       shift and go to state 69

state 33

    (93) function_definition -> function_heading SEMICOLON . function_block
    (100) function_block -> . compound_statement
    (68) compound_statement -> . BEGIN StateList END

    BEGIN           shift and go to state 32

    function_block                 shift and go to state 74
    compound_statement             shift and go to state 75

state 34

    (95) function_heading -> FUNCTION funcName . COLON return_type
    (96) function_heading -> FUNCTION funcName . parameter_list COLON return_type
    (97) parameter_list -> . LPAREN VarDefList RPAREN

    COLON           shift and go to state 76
    LPAREN          shift and go to state 78

    parameter_list                 shift and go to state 77

state 35

    (98) funcName -> ID .

    COLON           reduce using rule 98 (funcName -> ID .)
    LPAREN          reduce using rule 98 (funcName -> ID .)


state 36

    (22) label_declaration_part -> LABEL label_list SEMICOLON .

    FUNCTION        reduce using rule 22 (label_declaration_part -> LABEL label_list SEMICOLON .)
    BEGIN           reduce using rule 22 (label_declaration_part -> LABEL label_list SEMICOLON .)


state 37

    (24) label_list -> label_list COMMA . label
    (70) label -> . DIGSEQ

    DIGSEQ          shift and go to state 25

    label                          shift and go to state 79

state 38

    (4) VarDefList -> VarDefList SEMICOLON VarDefState .

    SEMICOLON       reduce using rule 4 (VarDefList -> VarDefList SEMICOLON VarDefState .)
    RPAREN          reduce using rule 4 (VarDefList -> VarDefList SEMICOLON VarDefState .)


state 39

    (6) VarDefState -> VarList COLON Type .

    SEMICOLON       reduce using rule 6 (VarDefState -> VarList COLON Type .)
    RPAREN          reduce using rule 6 (VarDefState -> VarList COLON Type .)


state 40

    (15) Type -> INTEGER .

    SEMICOLON       reduce using rule 15 (Type -> INTEGER .)
    RPAREN          reduce using rule 15 (Type -> INTEGER .)


state 41

    (16) Type -> REAL .

    SEMICOLON       reduce using rule 16 (Type -> REAL .)
    RPAREN          reduce using rule 16 (Type -> REAL .)


state 42

    (17) Type -> BOOLEAN .

    SEMICOLON       reduce using rule 17 (Type -> BOOLEAN .)
    RPAREN          reduce using rule 17 (Type -> BOOLEAN .)


state 43

    (18) Type -> arrayName .

    SEMICOLON       reduce using rule 18 (Type -> arrayName .)
    RPAREN          reduce using rule 18 (Type -> arrayName .)


state 44

    (8) VarList -> VarList COMMA Variable .

    COLON           reduce using rule 8 (VarList -> VarList COMMA Variable .)
    COMMA           reduce using rule 8 (VarList -> VarList COMMA Variable .)


state 45

    (10) ArrayDefState -> TYPE arrayName EQ . ARRAY LBRAC index_list RBRAC OF Type

    ARRAY           shift and go to state 80


state 46

    (68) compound_statement -> BEGIN StateList . END
    (26) StateList -> StateList . SEMICOLON Statement

    END             shift and go to state 81
    SEMICOLON       shift and go to state 82


state 47

    (27) StateList -> Statement .

    END             reduce using rule 27 (StateList -> Statement .)
    SEMICOLON       reduce using rule 27 (StateList -> Statement .)


state 48

    (28) Statement -> open_statement .

    END             reduce using rule 28 (Statement -> open_statement .)
    SEMICOLON       reduce using rule 28 (Statement -> open_statement .)


state 49

    (29) Statement -> closed_statement .

    END             reduce using rule 29 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 29 (Statement -> closed_statement .)


state 50

    (30) open_statement -> label . COLON non_labeled_open_statement
    (32) closed_statement -> label . COLON non_labeled_closed_statement

    COLON           shift and go to state 83


state 51

    (31) open_statement -> non_labeled_open_statement .

    END             reduce using rule 31 (open_statement -> non_labeled_open_statement .)
    SEMICOLON       reduce using rule 31 (open_statement -> non_labeled_open_statement .)


state 52

    (33) closed_statement -> non_labeled_closed_statement .

    END             reduce using rule 33 (closed_statement -> non_labeled_closed_statement .)
    SEMICOLON       reduce using rule 33 (closed_statement -> non_labeled_closed_statement .)
    ELSE            reduce using rule 33 (closed_statement -> non_labeled_closed_statement .)


state 53

    (34) non_labeled_open_statement -> open_if_statement .

    END             reduce using rule 34 (non_labeled_open_statement -> open_if_statement .)
    SEMICOLON       reduce using rule 34 (non_labeled_open_statement -> open_if_statement .)


state 54

    (35) non_labeled_open_statement -> open_while_statement .

    END             reduce using rule 35 (non_labeled_open_statement -> open_while_statement .)
    SEMICOLON       reduce using rule 35 (non_labeled_open_statement -> open_while_statement .)


state 55

    (36) non_labeled_open_statement -> open_for_statement .

    END             reduce using rule 36 (non_labeled_open_statement -> open_for_statement .)
    SEMICOLON       reduce using rule 36 (non_labeled_open_statement -> open_for_statement .)


state 56

    (37) non_labeled_closed_statement -> assignment_statement .

    END             reduce using rule 37 (non_labeled_closed_statement -> assignment_statement .)
    SEMICOLON       reduce using rule 37 (non_labeled_closed_statement -> assignment_statement .)
    ELSE            reduce using rule 37 (non_labeled_closed_statement -> assignment_statement .)


state 57

    (38) non_labeled_closed_statement -> compound_statement .

    END             reduce using rule 38 (non_labeled_closed_statement -> compound_statement .)
    SEMICOLON       reduce using rule 38 (non_labeled_closed_statement -> compound_statement .)
    ELSE            reduce using rule 38 (non_labeled_closed_statement -> compound_statement .)


state 58

    (39) non_labeled_closed_statement -> closed_if_statement .

    END             reduce using rule 39 (non_labeled_closed_statement -> closed_if_statement .)
    SEMICOLON       reduce using rule 39 (non_labeled_closed_statement -> closed_if_statement .)
    ELSE            reduce using rule 39 (non_labeled_closed_statement -> closed_if_statement .)


state 59

    (40) non_labeled_closed_statement -> closed_while_statement .

    END             reduce using rule 40 (non_labeled_closed_statement -> closed_while_statement .)
    SEMICOLON       reduce using rule 40 (non_labeled_closed_statement -> closed_while_statement .)
    ELSE            reduce using rule 40 (non_labeled_closed_statement -> closed_while_statement .)


state 60

    (41) non_labeled_closed_statement -> closed_for_statement .

    END             reduce using rule 41 (non_labeled_closed_statement -> closed_for_statement .)
    SEMICOLON       reduce using rule 41 (non_labeled_closed_statement -> closed_for_statement .)
    ELSE            reduce using rule 41 (non_labeled_closed_statement -> closed_for_statement .)


state 61

    (42) non_labeled_closed_statement -> goto_statement .

    END             reduce using rule 42 (non_labeled_closed_statement -> goto_statement .)
    SEMICOLON       reduce using rule 42 (non_labeled_closed_statement -> goto_statement .)
    ELSE            reduce using rule 42 (non_labeled_closed_statement -> goto_statement .)


state 62

    (43) non_labeled_closed_statement -> empty .

    END             reduce using rule 43 (non_labeled_closed_statement -> empty .)
    SEMICOLON       reduce using rule 43 (non_labeled_closed_statement -> empty .)
    ELSE            reduce using rule 43 (non_labeled_closed_statement -> empty .)


state 63

    (44) non_labeled_closed_statement -> case_statement .

    END             reduce using rule 44 (non_labeled_closed_statement -> case_statement .)
    SEMICOLON       reduce using rule 44 (non_labeled_closed_statement -> case_statement .)
    ELSE            reduce using rule 44 (non_labeled_closed_statement -> case_statement .)


state 64

    (45) non_labeled_closed_statement -> continue_statement .

    END             reduce using rule 45 (non_labeled_closed_statement -> continue_statement .)
    SEMICOLON       reduce using rule 45 (non_labeled_closed_statement -> continue_statement .)
    ELSE            reduce using rule 45 (non_labeled_closed_statement -> continue_statement .)


state 65

    (47) non_labeled_closed_statement -> break_statement .

    END             reduce using rule 47 (non_labeled_closed_statement -> break_statement .)
    SEMICOLON       reduce using rule 47 (non_labeled_closed_statement -> break_statement .)
    ELSE            reduce using rule 47 (non_labeled_closed_statement -> break_statement .)


state 66

    (56) open_if_statement -> IF . BoolExpr THEN Statement
    (57) open_if_statement -> IF . BoolExpr THEN closed_statement ELSE open_statement
    (58) closed_if_statement -> IF . BoolExpr THEN closed_statement ELSE closed_statement
    (81) BoolExpr -> . Expr LT Expr
    (82) BoolExpr -> . Expr LE Expr
    (83) BoolExpr -> . Expr GT Expr
    (84) BoolExpr -> . Expr GE Expr
    (85) BoolExpr -> . Expr EQ Expr
    (86) BoolExpr -> . Expr NE Expr
    (87) BoolExpr -> . BoolExpr AND BoolExpr
    (88) BoolExpr -> . BoolExpr OR BoolExpr
    (89) BoolExpr -> . NOT BoolExpr
    (90) BoolExpr -> . LPAREN BoolExpr RPAREN
    (91) BoolExpr -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    NOT             shift and go to state 86
    LPAREN          shift and go to state 87
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    BoolExpr                       shift and go to state 84
    Expr                           shift and go to state 85
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 67

    (59) open_while_statement -> WHILE . BoolExpr DO open_statement
    (60) closed_while_statement -> WHILE . BoolExpr DO closed_statement
    (81) BoolExpr -> . Expr LT Expr
    (82) BoolExpr -> . Expr LE Expr
    (83) BoolExpr -> . Expr GT Expr
    (84) BoolExpr -> . Expr GE Expr
    (85) BoolExpr -> . Expr EQ Expr
    (86) BoolExpr -> . Expr NE Expr
    (87) BoolExpr -> . BoolExpr AND BoolExpr
    (88) BoolExpr -> . BoolExpr OR BoolExpr
    (89) BoolExpr -> . NOT BoolExpr
    (90) BoolExpr -> . LPAREN BoolExpr RPAREN
    (91) BoolExpr -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    NOT             shift and go to state 86
    LPAREN          shift and go to state 87
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    BoolExpr                       shift and go to state 93
    Expr                           shift and go to state 85
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 68

    (61) open_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (62) closed_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (19) Variable -> . ID

    ID              shift and go to state 18

    Variable                       shift and go to state 94

state 69

    (67) assignment_statement -> Variable . ASSIGNMENT Expr

    ASSIGNMENT      shift and go to state 95


state 70

    (69) goto_statement -> GOTO . label
    (70) label -> . DIGSEQ

    DIGSEQ          shift and go to state 25

    label                          shift and go to state 96

state 71

    (49) case_statement -> CASE . case_index OF case_element_list END
    (50) case_statement -> CASE . case_index OF case_element_list SEMICOLON END
    (51) case_index -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    case_index                     shift and go to state 97
    Expr                           shift and go to state 98
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 72

    (46) continue_statement -> CONTINUE .

    END             reduce using rule 46 (continue_statement -> CONTINUE .)
    SEMICOLON       reduce using rule 46 (continue_statement -> CONTINUE .)
    ELSE            reduce using rule 46 (continue_statement -> CONTINUE .)


state 73

    (48) break_statement -> BREAK .

    END             reduce using rule 48 (break_statement -> BREAK .)
    SEMICOLON       reduce using rule 48 (break_statement -> BREAK .)
    ELSE            reduce using rule 48 (break_statement -> BREAK .)


state 74

    (93) function_definition -> function_heading SEMICOLON function_block .

    BEGIN           reduce using rule 93 (function_definition -> function_heading SEMICOLON function_block .)


state 75

    (100) function_block -> compound_statement .

    BEGIN           reduce using rule 100 (function_block -> compound_statement .)


state 76

    (95) function_heading -> FUNCTION funcName COLON . return_type
    (99) return_type -> . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 40
    REAL            shift and go to state 41
    BOOLEAN         shift and go to state 42
    ID              shift and go to state 30

    return_type                    shift and go to state 100
    Type                           shift and go to state 101
    arrayName                      shift and go to state 43

state 77

    (96) function_heading -> FUNCTION funcName parameter_list . COLON return_type

    COLON           shift and go to state 102


state 78

    (97) parameter_list -> LPAREN . VarDefList RPAREN
    (4) VarDefList -> . VarDefList SEMICOLON VarDefState
    (5) VarDefList -> . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    TYPE            shift and go to state 17
    ID              shift and go to state 18

    VarDefList                     shift and go to state 103
    VarDefState                    shift and go to state 13
    VarList                        shift and go to state 14
    ArrayDefState                  shift and go to state 15
    Variable                       shift and go to state 16

state 79

    (24) label_list -> label_list COMMA label .

    SEMICOLON       reduce using rule 24 (label_list -> label_list COMMA label .)
    COMMA           reduce using rule 24 (label_list -> label_list COMMA label .)


state 80

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY . LBRAC index_list RBRAC OF Type

    LBRAC           shift and go to state 104


state 81

    (68) compound_statement -> BEGIN StateList END .

    ENDPOINT        reduce using rule 68 (compound_statement -> BEGIN StateList END .)
    END             reduce using rule 68 (compound_statement -> BEGIN StateList END .)
    SEMICOLON       reduce using rule 68 (compound_statement -> BEGIN StateList END .)
    BEGIN           reduce using rule 68 (compound_statement -> BEGIN StateList END .)
    ELSE            reduce using rule 68 (compound_statement -> BEGIN StateList END .)


state 82

    (26) StateList -> StateList SEMICOLON . Statement
    (28) Statement -> . open_statement
    (29) Statement -> . closed_statement
    (30) open_statement -> . label COLON non_labeled_open_statement
    (31) open_statement -> . non_labeled_open_statement
    (32) closed_statement -> . label COLON non_labeled_closed_statement
    (33) closed_statement -> . non_labeled_closed_statement
    (70) label -> . DIGSEQ
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 66
    WHILE           shift and go to state 67
    FOR             shift and go to state 68
    BEGIN           shift and go to state 32
    GOTO            shift and go to state 70
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    Statement                      shift and go to state 105
    open_statement                 shift and go to state 48
    closed_statement               shift and go to state 49
    label                          shift and go to state 50
    non_labeled_open_statement     shift and go to state 51
    non_labeled_closed_statement   shift and go to state 52
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    Variable                       shift and go to state 69

state 83

    (30) open_statement -> label COLON . non_labeled_open_statement
    (32) closed_statement -> label COLON . non_labeled_closed_statement
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (19) Variable -> . ID

    IF              shift and go to state 66
    WHILE           shift and go to state 67
    FOR             shift and go to state 68
    BEGIN           shift and go to state 32
    GOTO            shift and go to state 70
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    ELSE            reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    non_labeled_open_statement     shift and go to state 106
    non_labeled_closed_statement   shift and go to state 107
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    Variable                       shift and go to state 69

state 84

    (56) open_if_statement -> IF BoolExpr . THEN Statement
    (57) open_if_statement -> IF BoolExpr . THEN closed_statement ELSE open_statement
    (58) closed_if_statement -> IF BoolExpr . THEN closed_statement ELSE closed_statement
    (87) BoolExpr -> BoolExpr . AND BoolExpr
    (88) BoolExpr -> BoolExpr . OR BoolExpr

    THEN            shift and go to state 108
    AND             shift and go to state 109
    OR              shift and go to state 110


state 85

    (81) BoolExpr -> Expr . LT Expr
    (82) BoolExpr -> Expr . LE Expr
    (83) BoolExpr -> Expr . GT Expr
    (84) BoolExpr -> Expr . GE Expr
    (85) BoolExpr -> Expr . EQ Expr
    (86) BoolExpr -> Expr . NE Expr
    (91) BoolExpr -> Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    LT              shift and go to state 111
    LE              shift and go to state 112
    GT              shift and go to state 113
    GE              shift and go to state 114
    EQ              shift and go to state 115
    NE              shift and go to state 116
    THEN            reduce using rule 91 (BoolExpr -> Expr .)
    AND             reduce using rule 91 (BoolExpr -> Expr .)
    OR              reduce using rule 91 (BoolExpr -> Expr .)
    DO              reduce using rule 91 (BoolExpr -> Expr .)
    RPAREN          reduce using rule 91 (BoolExpr -> Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 86

    (89) BoolExpr -> NOT . BoolExpr
    (81) BoolExpr -> . Expr LT Expr
    (82) BoolExpr -> . Expr LE Expr
    (83) BoolExpr -> . Expr GT Expr
    (84) BoolExpr -> . Expr GE Expr
    (85) BoolExpr -> . Expr EQ Expr
    (86) BoolExpr -> . Expr NE Expr
    (87) BoolExpr -> . BoolExpr AND BoolExpr
    (88) BoolExpr -> . BoolExpr OR BoolExpr
    (89) BoolExpr -> . NOT BoolExpr
    (90) BoolExpr -> . LPAREN BoolExpr RPAREN
    (91) BoolExpr -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    NOT             shift and go to state 86
    LPAREN          shift and go to state 87
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    BoolExpr                       shift and go to state 121
    Expr                           shift and go to state 85
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 87

    (90) BoolExpr -> LPAREN . BoolExpr RPAREN
    (75) Expr -> LPAREN . Expr RPAREN
    (81) BoolExpr -> . Expr LT Expr
    (82) BoolExpr -> . Expr LE Expr
    (83) BoolExpr -> . Expr GT Expr
    (84) BoolExpr -> . Expr GE Expr
    (85) BoolExpr -> . Expr EQ Expr
    (86) BoolExpr -> . Expr NE Expr
    (87) BoolExpr -> . BoolExpr AND BoolExpr
    (88) BoolExpr -> . BoolExpr OR BoolExpr
    (89) BoolExpr -> . NOT BoolExpr
    (90) BoolExpr -> . LPAREN BoolExpr RPAREN
    (91) BoolExpr -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    NOT             shift and go to state 86
    LPAREN          shift and go to state 87
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    BoolExpr                       shift and go to state 122
    Expr                           shift and go to state 123
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 88

    (76) Expr -> MINUS . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 124
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 89

    (77) Expr -> Variable .

    LT              reduce using rule 77 (Expr -> Variable .)
    LE              reduce using rule 77 (Expr -> Variable .)
    GT              reduce using rule 77 (Expr -> Variable .)
    GE              reduce using rule 77 (Expr -> Variable .)
    EQ              reduce using rule 77 (Expr -> Variable .)
    NE              reduce using rule 77 (Expr -> Variable .)
    PLUS            reduce using rule 77 (Expr -> Variable .)
    MINUS           reduce using rule 77 (Expr -> Variable .)
    TIMES           reduce using rule 77 (Expr -> Variable .)
    DIVIDE          reduce using rule 77 (Expr -> Variable .)
    THEN            reduce using rule 77 (Expr -> Variable .)
    AND             reduce using rule 77 (Expr -> Variable .)
    OR              reduce using rule 77 (Expr -> Variable .)
    DO              reduce using rule 77 (Expr -> Variable .)
    OF              reduce using rule 77 (Expr -> Variable .)
    RPAREN          reduce using rule 77 (Expr -> Variable .)
    END             reduce using rule 77 (Expr -> Variable .)
    SEMICOLON       reduce using rule 77 (Expr -> Variable .)
    ELSE            reduce using rule 77 (Expr -> Variable .)
    TO              reduce using rule 77 (Expr -> Variable .)
    DOWNTO          reduce using rule 77 (Expr -> Variable .)


state 90

    (78) Expr -> const .

    LT              reduce using rule 78 (Expr -> const .)
    LE              reduce using rule 78 (Expr -> const .)
    GT              reduce using rule 78 (Expr -> const .)
    GE              reduce using rule 78 (Expr -> const .)
    EQ              reduce using rule 78 (Expr -> const .)
    NE              reduce using rule 78 (Expr -> const .)
    PLUS            reduce using rule 78 (Expr -> const .)
    MINUS           reduce using rule 78 (Expr -> const .)
    TIMES           reduce using rule 78 (Expr -> const .)
    DIVIDE          reduce using rule 78 (Expr -> const .)
    THEN            reduce using rule 78 (Expr -> const .)
    AND             reduce using rule 78 (Expr -> const .)
    OR              reduce using rule 78 (Expr -> const .)
    DO              reduce using rule 78 (Expr -> const .)
    OF              reduce using rule 78 (Expr -> const .)
    RPAREN          reduce using rule 78 (Expr -> const .)
    END             reduce using rule 78 (Expr -> const .)
    SEMICOLON       reduce using rule 78 (Expr -> const .)
    ELSE            reduce using rule 78 (Expr -> const .)
    TO              reduce using rule 78 (Expr -> const .)
    DOWNTO          reduce using rule 78 (Expr -> const .)


state 91

    (79) const -> INT_NUMBER .

    LT              reduce using rule 79 (const -> INT_NUMBER .)
    LE              reduce using rule 79 (const -> INT_NUMBER .)
    GT              reduce using rule 79 (const -> INT_NUMBER .)
    GE              reduce using rule 79 (const -> INT_NUMBER .)
    EQ              reduce using rule 79 (const -> INT_NUMBER .)
    NE              reduce using rule 79 (const -> INT_NUMBER .)
    PLUS            reduce using rule 79 (const -> INT_NUMBER .)
    MINUS           reduce using rule 79 (const -> INT_NUMBER .)
    TIMES           reduce using rule 79 (const -> INT_NUMBER .)
    DIVIDE          reduce using rule 79 (const -> INT_NUMBER .)
    THEN            reduce using rule 79 (const -> INT_NUMBER .)
    AND             reduce using rule 79 (const -> INT_NUMBER .)
    OR              reduce using rule 79 (const -> INT_NUMBER .)
    DO              reduce using rule 79 (const -> INT_NUMBER .)
    OF              reduce using rule 79 (const -> INT_NUMBER .)
    RPAREN          reduce using rule 79 (const -> INT_NUMBER .)
    END             reduce using rule 79 (const -> INT_NUMBER .)
    SEMICOLON       reduce using rule 79 (const -> INT_NUMBER .)
    ELSE            reduce using rule 79 (const -> INT_NUMBER .)
    TO              reduce using rule 79 (const -> INT_NUMBER .)
    DOWNTO          reduce using rule 79 (const -> INT_NUMBER .)
    DOTDOT          reduce using rule 79 (const -> INT_NUMBER .)
    COLON           reduce using rule 79 (const -> INT_NUMBER .)
    RBRAC           reduce using rule 79 (const -> INT_NUMBER .)
    COMMA           reduce using rule 79 (const -> INT_NUMBER .)


state 92

    (80) const -> REAL_NUMBER .

    LT              reduce using rule 80 (const -> REAL_NUMBER .)
    LE              reduce using rule 80 (const -> REAL_NUMBER .)
    GT              reduce using rule 80 (const -> REAL_NUMBER .)
    GE              reduce using rule 80 (const -> REAL_NUMBER .)
    EQ              reduce using rule 80 (const -> REAL_NUMBER .)
    NE              reduce using rule 80 (const -> REAL_NUMBER .)
    PLUS            reduce using rule 80 (const -> REAL_NUMBER .)
    MINUS           reduce using rule 80 (const -> REAL_NUMBER .)
    TIMES           reduce using rule 80 (const -> REAL_NUMBER .)
    DIVIDE          reduce using rule 80 (const -> REAL_NUMBER .)
    THEN            reduce using rule 80 (const -> REAL_NUMBER .)
    AND             reduce using rule 80 (const -> REAL_NUMBER .)
    OR              reduce using rule 80 (const -> REAL_NUMBER .)
    DO              reduce using rule 80 (const -> REAL_NUMBER .)
    OF              reduce using rule 80 (const -> REAL_NUMBER .)
    RPAREN          reduce using rule 80 (const -> REAL_NUMBER .)
    END             reduce using rule 80 (const -> REAL_NUMBER .)
    SEMICOLON       reduce using rule 80 (const -> REAL_NUMBER .)
    ELSE            reduce using rule 80 (const -> REAL_NUMBER .)
    TO              reduce using rule 80 (const -> REAL_NUMBER .)
    DOWNTO          reduce using rule 80 (const -> REAL_NUMBER .)
    DOTDOT          reduce using rule 80 (const -> REAL_NUMBER .)
    COLON           reduce using rule 80 (const -> REAL_NUMBER .)
    RBRAC           reduce using rule 80 (const -> REAL_NUMBER .)
    COMMA           reduce using rule 80 (const -> REAL_NUMBER .)


state 93

    (59) open_while_statement -> WHILE BoolExpr . DO open_statement
    (60) closed_while_statement -> WHILE BoolExpr . DO closed_statement
    (87) BoolExpr -> BoolExpr . AND BoolExpr
    (88) BoolExpr -> BoolExpr . OR BoolExpr

    DO              shift and go to state 125
    AND             shift and go to state 109
    OR              shift and go to state 110


state 94

    (61) open_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO open_statement
    (62) closed_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO closed_statement

    ASSIGNMENT      shift and go to state 126


state 95

    (67) assignment_statement -> Variable ASSIGNMENT . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Variable                       shift and go to state 89
    Expr                           shift and go to state 127
    const                          shift and go to state 90

state 96

    (69) goto_statement -> GOTO label .

    END             reduce using rule 69 (goto_statement -> GOTO label .)
    SEMICOLON       reduce using rule 69 (goto_statement -> GOTO label .)
    ELSE            reduce using rule 69 (goto_statement -> GOTO label .)


state 97

    (49) case_statement -> CASE case_index . OF case_element_list END
    (50) case_statement -> CASE case_index . OF case_element_list SEMICOLON END

    OF              shift and go to state 128


state 98

    (51) case_index -> Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    OF              reduce using rule 51 (case_index -> Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 99

    (75) Expr -> LPAREN . Expr RPAREN
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 129
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 100

    (95) function_heading -> FUNCTION funcName COLON return_type .

    SEMICOLON       reduce using rule 95 (function_heading -> FUNCTION funcName COLON return_type .)


state 101

    (99) return_type -> Type .

    SEMICOLON       reduce using rule 99 (return_type -> Type .)


state 102

    (96) function_heading -> FUNCTION funcName parameter_list COLON . return_type
    (99) return_type -> . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 40
    REAL            shift and go to state 41
    BOOLEAN         shift and go to state 42
    ID              shift and go to state 30

    return_type                    shift and go to state 130
    Type                           shift and go to state 101
    arrayName                      shift and go to state 43

state 103

    (97) parameter_list -> LPAREN VarDefList . RPAREN
    (4) VarDefList -> VarDefList . SEMICOLON VarDefState

    RPAREN          shift and go to state 131
    SEMICOLON       shift and go to state 132


state 104

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC . index_list RBRAC OF Type
    (12) index_list -> . index_list COMMA index
    (13) index_list -> . index
    (14) index -> . startIndex DOTDOT endIndex
    (20) startIndex -> . const
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    index_list                     shift and go to state 133
    index                          shift and go to state 134
    startIndex                     shift and go to state 135
    const                          shift and go to state 136

state 105

    (26) StateList -> StateList SEMICOLON Statement .

    END             reduce using rule 26 (StateList -> StateList SEMICOLON Statement .)
    SEMICOLON       reduce using rule 26 (StateList -> StateList SEMICOLON Statement .)


state 106

    (30) open_statement -> label COLON non_labeled_open_statement .

    END             reduce using rule 30 (open_statement -> label COLON non_labeled_open_statement .)
    SEMICOLON       reduce using rule 30 (open_statement -> label COLON non_labeled_open_statement .)


state 107

    (32) closed_statement -> label COLON non_labeled_closed_statement .

    END             reduce using rule 32 (closed_statement -> label COLON non_labeled_closed_statement .)
    SEMICOLON       reduce using rule 32 (closed_statement -> label COLON non_labeled_closed_statement .)
    ELSE            reduce using rule 32 (closed_statement -> label COLON non_labeled_closed_statement .)


state 108

    (56) open_if_statement -> IF BoolExpr THEN . Statement
    (57) open_if_statement -> IF BoolExpr THEN . closed_statement ELSE open_statement
    (58) closed_if_statement -> IF BoolExpr THEN . closed_statement ELSE closed_statement
    (28) Statement -> . open_statement
    (29) Statement -> . closed_statement
    (32) closed_statement -> . label COLON non_labeled_closed_statement
    (33) closed_statement -> . non_labeled_closed_statement
    (30) open_statement -> . label COLON non_labeled_open_statement
    (31) open_statement -> . non_labeled_open_statement
    (70) label -> . DIGSEQ
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    BEGIN           shift and go to state 32
    IF              shift and go to state 137
    WHILE           shift and go to state 141
    FOR             shift and go to state 142
    GOTO            shift and go to state 70
    ELSE            reduce using rule 92 (empty -> .)
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    Statement                      shift and go to state 138
    closed_statement               shift and go to state 139
    open_statement                 shift and go to state 48
    label                          shift and go to state 140
    non_labeled_closed_statement   shift and go to state 52
    non_labeled_open_statement     shift and go to state 51
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
    Variable                       shift and go to state 69

state 109

    (87) BoolExpr -> BoolExpr AND . BoolExpr
    (81) BoolExpr -> . Expr LT Expr
    (82) BoolExpr -> . Expr LE Expr
    (83) BoolExpr -> . Expr GT Expr
    (84) BoolExpr -> . Expr GE Expr
    (85) BoolExpr -> . Expr EQ Expr
    (86) BoolExpr -> . Expr NE Expr
    (87) BoolExpr -> . BoolExpr AND BoolExpr
    (88) BoolExpr -> . BoolExpr OR BoolExpr
    (89) BoolExpr -> . NOT BoolExpr
    (90) BoolExpr -> . LPAREN BoolExpr RPAREN
    (91) BoolExpr -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    NOT             shift and go to state 86
    LPAREN          shift and go to state 87
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    BoolExpr                       shift and go to state 143
    Expr                           shift and go to state 85
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 110

    (88) BoolExpr -> BoolExpr OR . BoolExpr
    (81) BoolExpr -> . Expr LT Expr
    (82) BoolExpr -> . Expr LE Expr
    (83) BoolExpr -> . Expr GT Expr
    (84) BoolExpr -> . Expr GE Expr
    (85) BoolExpr -> . Expr EQ Expr
    (86) BoolExpr -> . Expr NE Expr
    (87) BoolExpr -> . BoolExpr AND BoolExpr
    (88) BoolExpr -> . BoolExpr OR BoolExpr
    (89) BoolExpr -> . NOT BoolExpr
    (90) BoolExpr -> . LPAREN BoolExpr RPAREN
    (91) BoolExpr -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    NOT             shift and go to state 86
    LPAREN          shift and go to state 87
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    BoolExpr                       shift and go to state 144
    Expr                           shift and go to state 85
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 111

    (81) BoolExpr -> Expr LT . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 145
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 112

    (82) BoolExpr -> Expr LE . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 146
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 113

    (83) BoolExpr -> Expr GT . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 147
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 114

    (84) BoolExpr -> Expr GE . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 148
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 115

    (85) BoolExpr -> Expr EQ . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 149
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 116

    (86) BoolExpr -> Expr NE . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 150
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 117

    (71) Expr -> Expr PLUS . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 151
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 118

    (72) Expr -> Expr MINUS . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 152
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 119

    (73) Expr -> Expr TIMES . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 153
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 120

    (74) Expr -> Expr DIVIDE . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Expr                           shift and go to state 154
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 121

    (89) BoolExpr -> NOT BoolExpr .
    (87) BoolExpr -> BoolExpr . AND BoolExpr
    (88) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 89 (BoolExpr -> NOT BoolExpr .)
    DO              reduce using rule 89 (BoolExpr -> NOT BoolExpr .)
    RPAREN          reduce using rule 89 (BoolExpr -> NOT BoolExpr .)
    AND             shift and go to state 109
    OR              shift and go to state 110

  ! AND             [ reduce using rule 89 (BoolExpr -> NOT BoolExpr .) ]
  ! OR              [ reduce using rule 89 (BoolExpr -> NOT BoolExpr .) ]


state 122

    (90) BoolExpr -> LPAREN BoolExpr . RPAREN
    (87) BoolExpr -> BoolExpr . AND BoolExpr
    (88) BoolExpr -> BoolExpr . OR BoolExpr

    RPAREN          shift and go to state 155
    AND             shift and go to state 109
    OR              shift and go to state 110


state 123

    (75) Expr -> LPAREN Expr . RPAREN
    (81) BoolExpr -> Expr . LT Expr
    (82) BoolExpr -> Expr . LE Expr
    (83) BoolExpr -> Expr . GT Expr
    (84) BoolExpr -> Expr . GE Expr
    (85) BoolExpr -> Expr . EQ Expr
    (86) BoolExpr -> Expr . NE Expr
    (91) BoolExpr -> Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 156
    LT              shift and go to state 111
    LE              shift and go to state 112
    GT              shift and go to state 113
    GE              shift and go to state 114
    EQ              shift and go to state 115
    NE              shift and go to state 116
    AND             reduce using rule 91 (BoolExpr -> Expr .)
    OR              reduce using rule 91 (BoolExpr -> Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120

  ! RPAREN          [ reduce using rule 91 (BoolExpr -> Expr .) ]


state 124

    (76) Expr -> MINUS Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 76 (Expr -> MINUS Expr .)
    LE              reduce using rule 76 (Expr -> MINUS Expr .)
    GT              reduce using rule 76 (Expr -> MINUS Expr .)
    GE              reduce using rule 76 (Expr -> MINUS Expr .)
    EQ              reduce using rule 76 (Expr -> MINUS Expr .)
    NE              reduce using rule 76 (Expr -> MINUS Expr .)
    PLUS            reduce using rule 76 (Expr -> MINUS Expr .)
    MINUS           reduce using rule 76 (Expr -> MINUS Expr .)
    TIMES           reduce using rule 76 (Expr -> MINUS Expr .)
    DIVIDE          reduce using rule 76 (Expr -> MINUS Expr .)
    THEN            reduce using rule 76 (Expr -> MINUS Expr .)
    AND             reduce using rule 76 (Expr -> MINUS Expr .)
    OR              reduce using rule 76 (Expr -> MINUS Expr .)
    DO              reduce using rule 76 (Expr -> MINUS Expr .)
    OF              reduce using rule 76 (Expr -> MINUS Expr .)
    RPAREN          reduce using rule 76 (Expr -> MINUS Expr .)
    END             reduce using rule 76 (Expr -> MINUS Expr .)
    SEMICOLON       reduce using rule 76 (Expr -> MINUS Expr .)
    ELSE            reduce using rule 76 (Expr -> MINUS Expr .)
    TO              reduce using rule 76 (Expr -> MINUS Expr .)
    DOWNTO          reduce using rule 76 (Expr -> MINUS Expr .)

  ! PLUS            [ shift and go to state 117 ]
  ! MINUS           [ shift and go to state 118 ]
  ! TIMES           [ shift and go to state 119 ]
  ! DIVIDE          [ shift and go to state 120 ]


state 125

    (59) open_while_statement -> WHILE BoolExpr DO . open_statement
    (60) closed_while_statement -> WHILE BoolExpr DO . closed_statement
    (30) open_statement -> . label COLON non_labeled_open_statement
    (31) open_statement -> . non_labeled_open_statement
    (32) closed_statement -> . label COLON non_labeled_closed_statement
    (33) closed_statement -> . non_labeled_closed_statement
    (70) label -> . DIGSEQ
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 66
    WHILE           shift and go to state 67
    FOR             shift and go to state 68
    BEGIN           shift and go to state 32
    GOTO            shift and go to state 70
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    ELSE            reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    open_statement                 shift and go to state 157
    closed_statement               shift and go to state 158
    label                          shift and go to state 50
    non_labeled_open_statement     shift and go to state 51
    non_labeled_closed_statement   shift and go to state 52
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    Variable                       shift and go to state 69

state 126

    (61) open_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO open_statement
    (62) closed_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO closed_statement
    (63) initial_value -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Variable                       shift and go to state 89
    initial_value                  shift and go to state 159
    Expr                           shift and go to state 160
    const                          shift and go to state 90

state 127

    (67) assignment_statement -> Variable ASSIGNMENT Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    END             reduce using rule 67 (assignment_statement -> Variable ASSIGNMENT Expr .)
    SEMICOLON       reduce using rule 67 (assignment_statement -> Variable ASSIGNMENT Expr .)
    ELSE            reduce using rule 67 (assignment_statement -> Variable ASSIGNMENT Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 128

    (49) case_statement -> CASE case_index OF . case_element_list END
    (50) case_statement -> CASE case_index OF . case_element_list SEMICOLON END
    (52) case_element_list -> . case_element_list SEMICOLON case_element
    (53) case_element_list -> . case_element
    (54) case_element -> . case_constant COLON Statement
    (55) case_constant -> . const
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    case_element_list              shift and go to state 161
    case_element                   shift and go to state 162
    case_constant                  shift and go to state 163
    const                          shift and go to state 164

state 129

    (75) Expr -> LPAREN Expr . RPAREN
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    RPAREN          shift and go to state 156
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 130

    (96) function_heading -> FUNCTION funcName parameter_list COLON return_type .

    SEMICOLON       reduce using rule 96 (function_heading -> FUNCTION funcName parameter_list COLON return_type .)


state 131

    (97) parameter_list -> LPAREN VarDefList RPAREN .

    COLON           reduce using rule 97 (parameter_list -> LPAREN VarDefList RPAREN .)


state 132

    (4) VarDefList -> VarDefList SEMICOLON . VarDefState
    (6) VarDefState -> . VarList COLON Type
    (7) VarDefState -> . ArrayDefState
    (8) VarList -> . VarList COMMA Variable
    (9) VarList -> . Variable
    (10) ArrayDefState -> . TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type
    (19) Variable -> . ID

    TYPE            shift and go to state 17
    ID              shift and go to state 18

    VarDefState                    shift and go to state 38
    VarList                        shift and go to state 14
    ArrayDefState                  shift and go to state 15
    Variable                       shift and go to state 16

state 133

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list . RBRAC OF Type
    (12) index_list -> index_list . COMMA index

    RBRAC           shift and go to state 165
    COMMA           shift and go to state 166


state 134

    (13) index_list -> index .

    RBRAC           reduce using rule 13 (index_list -> index .)
    COMMA           reduce using rule 13 (index_list -> index .)


state 135

    (14) index -> startIndex . DOTDOT endIndex

    DOTDOT          shift and go to state 167


state 136

    (20) startIndex -> const .

    DOTDOT          reduce using rule 20 (startIndex -> const .)


state 137

    (58) closed_if_statement -> IF . BoolExpr THEN closed_statement ELSE closed_statement
    (56) open_if_statement -> IF . BoolExpr THEN Statement
    (57) open_if_statement -> IF . BoolExpr THEN closed_statement ELSE open_statement
    (81) BoolExpr -> . Expr LT Expr
    (82) BoolExpr -> . Expr LE Expr
    (83) BoolExpr -> . Expr GT Expr
    (84) BoolExpr -> . Expr GE Expr
    (85) BoolExpr -> . Expr EQ Expr
    (86) BoolExpr -> . Expr NE Expr
    (87) BoolExpr -> . BoolExpr AND BoolExpr
    (88) BoolExpr -> . BoolExpr OR BoolExpr
    (89) BoolExpr -> . NOT BoolExpr
    (90) BoolExpr -> . LPAREN BoolExpr RPAREN
    (91) BoolExpr -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    NOT             shift and go to state 86
    LPAREN          shift and go to state 87
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    BoolExpr                       shift and go to state 168
    Expr                           shift and go to state 85
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 138

    (56) open_if_statement -> IF BoolExpr THEN Statement .

    END             reduce using rule 56 (open_if_statement -> IF BoolExpr THEN Statement .)
    SEMICOLON       reduce using rule 56 (open_if_statement -> IF BoolExpr THEN Statement .)


state 139

    (57) open_if_statement -> IF BoolExpr THEN closed_statement . ELSE open_statement
    (58) closed_if_statement -> IF BoolExpr THEN closed_statement . ELSE closed_statement
    (29) Statement -> closed_statement .

    ELSE            shift and go to state 169
    END             reduce using rule 29 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 29 (Statement -> closed_statement .)


state 140

    (32) closed_statement -> label . COLON non_labeled_closed_statement
    (30) open_statement -> label . COLON non_labeled_open_statement

    COLON           shift and go to state 170


state 141

    (60) closed_while_statement -> WHILE . BoolExpr DO closed_statement
    (59) open_while_statement -> WHILE . BoolExpr DO open_statement
    (81) BoolExpr -> . Expr LT Expr
    (82) BoolExpr -> . Expr LE Expr
    (83) BoolExpr -> . Expr GT Expr
    (84) BoolExpr -> . Expr GE Expr
    (85) BoolExpr -> . Expr EQ Expr
    (86) BoolExpr -> . Expr NE Expr
    (87) BoolExpr -> . BoolExpr AND BoolExpr
    (88) BoolExpr -> . BoolExpr OR BoolExpr
    (89) BoolExpr -> . NOT BoolExpr
    (90) BoolExpr -> . LPAREN BoolExpr RPAREN
    (91) BoolExpr -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    NOT             shift and go to state 86
    LPAREN          shift and go to state 87
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    BoolExpr                       shift and go to state 171
    Expr                           shift and go to state 85
    Variable                       shift and go to state 89
    const                          shift and go to state 90

state 142

    (62) closed_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) open_for_statement -> FOR . Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    ID              shift and go to state 18

    Variable                       shift and go to state 172

state 143

    (87) BoolExpr -> BoolExpr AND BoolExpr .
    (87) BoolExpr -> BoolExpr . AND BoolExpr
    (88) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 87 (BoolExpr -> BoolExpr AND BoolExpr .)
    DO              reduce using rule 87 (BoolExpr -> BoolExpr AND BoolExpr .)
    RPAREN          reduce using rule 87 (BoolExpr -> BoolExpr AND BoolExpr .)
    AND             shift and go to state 109
    OR              shift and go to state 110

  ! AND             [ reduce using rule 87 (BoolExpr -> BoolExpr AND BoolExpr .) ]
  ! OR              [ reduce using rule 87 (BoolExpr -> BoolExpr AND BoolExpr .) ]


state 144

    (88) BoolExpr -> BoolExpr OR BoolExpr .
    (87) BoolExpr -> BoolExpr . AND BoolExpr
    (88) BoolExpr -> BoolExpr . OR BoolExpr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    THEN            reduce using rule 88 (BoolExpr -> BoolExpr OR BoolExpr .)
    DO              reduce using rule 88 (BoolExpr -> BoolExpr OR BoolExpr .)
    RPAREN          reduce using rule 88 (BoolExpr -> BoolExpr OR BoolExpr .)
    AND             shift and go to state 109
    OR              shift and go to state 110

  ! AND             [ reduce using rule 88 (BoolExpr -> BoolExpr OR BoolExpr .) ]
  ! OR              [ reduce using rule 88 (BoolExpr -> BoolExpr OR BoolExpr .) ]


state 145

    (81) BoolExpr -> Expr LT Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 81 (BoolExpr -> Expr LT Expr .)
    AND             reduce using rule 81 (BoolExpr -> Expr LT Expr .)
    OR              reduce using rule 81 (BoolExpr -> Expr LT Expr .)
    DO              reduce using rule 81 (BoolExpr -> Expr LT Expr .)
    RPAREN          reduce using rule 81 (BoolExpr -> Expr LT Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 146

    (82) BoolExpr -> Expr LE Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 82 (BoolExpr -> Expr LE Expr .)
    AND             reduce using rule 82 (BoolExpr -> Expr LE Expr .)
    OR              reduce using rule 82 (BoolExpr -> Expr LE Expr .)
    DO              reduce using rule 82 (BoolExpr -> Expr LE Expr .)
    RPAREN          reduce using rule 82 (BoolExpr -> Expr LE Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 147

    (83) BoolExpr -> Expr GT Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 83 (BoolExpr -> Expr GT Expr .)
    AND             reduce using rule 83 (BoolExpr -> Expr GT Expr .)
    OR              reduce using rule 83 (BoolExpr -> Expr GT Expr .)
    DO              reduce using rule 83 (BoolExpr -> Expr GT Expr .)
    RPAREN          reduce using rule 83 (BoolExpr -> Expr GT Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 148

    (84) BoolExpr -> Expr GE Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 84 (BoolExpr -> Expr GE Expr .)
    AND             reduce using rule 84 (BoolExpr -> Expr GE Expr .)
    OR              reduce using rule 84 (BoolExpr -> Expr GE Expr .)
    DO              reduce using rule 84 (BoolExpr -> Expr GE Expr .)
    RPAREN          reduce using rule 84 (BoolExpr -> Expr GE Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 149

    (85) BoolExpr -> Expr EQ Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 85 (BoolExpr -> Expr EQ Expr .)
    AND             reduce using rule 85 (BoolExpr -> Expr EQ Expr .)
    OR              reduce using rule 85 (BoolExpr -> Expr EQ Expr .)
    DO              reduce using rule 85 (BoolExpr -> Expr EQ Expr .)
    RPAREN          reduce using rule 85 (BoolExpr -> Expr EQ Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 150

    (86) BoolExpr -> Expr NE Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    THEN            reduce using rule 86 (BoolExpr -> Expr NE Expr .)
    AND             reduce using rule 86 (BoolExpr -> Expr NE Expr .)
    OR              reduce using rule 86 (BoolExpr -> Expr NE Expr .)
    DO              reduce using rule 86 (BoolExpr -> Expr NE Expr .)
    RPAREN          reduce using rule 86 (BoolExpr -> Expr NE Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 151

    (71) Expr -> Expr PLUS Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 71 (Expr -> Expr PLUS Expr .)
    LE              reduce using rule 71 (Expr -> Expr PLUS Expr .)
    GT              reduce using rule 71 (Expr -> Expr PLUS Expr .)
    GE              reduce using rule 71 (Expr -> Expr PLUS Expr .)
    EQ              reduce using rule 71 (Expr -> Expr PLUS Expr .)
    NE              reduce using rule 71 (Expr -> Expr PLUS Expr .)
    PLUS            reduce using rule 71 (Expr -> Expr PLUS Expr .)
    MINUS           reduce using rule 71 (Expr -> Expr PLUS Expr .)
    THEN            reduce using rule 71 (Expr -> Expr PLUS Expr .)
    AND             reduce using rule 71 (Expr -> Expr PLUS Expr .)
    OR              reduce using rule 71 (Expr -> Expr PLUS Expr .)
    DO              reduce using rule 71 (Expr -> Expr PLUS Expr .)
    OF              reduce using rule 71 (Expr -> Expr PLUS Expr .)
    RPAREN          reduce using rule 71 (Expr -> Expr PLUS Expr .)
    END             reduce using rule 71 (Expr -> Expr PLUS Expr .)
    SEMICOLON       reduce using rule 71 (Expr -> Expr PLUS Expr .)
    ELSE            reduce using rule 71 (Expr -> Expr PLUS Expr .)
    TO              reduce using rule 71 (Expr -> Expr PLUS Expr .)
    DOWNTO          reduce using rule 71 (Expr -> Expr PLUS Expr .)
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120

  ! TIMES           [ reduce using rule 71 (Expr -> Expr PLUS Expr .) ]
  ! DIVIDE          [ reduce using rule 71 (Expr -> Expr PLUS Expr .) ]
  ! PLUS            [ shift and go to state 117 ]
  ! MINUS           [ shift and go to state 118 ]


state 152

    (72) Expr -> Expr MINUS Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 72 (Expr -> Expr MINUS Expr .)
    LE              reduce using rule 72 (Expr -> Expr MINUS Expr .)
    GT              reduce using rule 72 (Expr -> Expr MINUS Expr .)
    GE              reduce using rule 72 (Expr -> Expr MINUS Expr .)
    EQ              reduce using rule 72 (Expr -> Expr MINUS Expr .)
    NE              reduce using rule 72 (Expr -> Expr MINUS Expr .)
    PLUS            reduce using rule 72 (Expr -> Expr MINUS Expr .)
    MINUS           reduce using rule 72 (Expr -> Expr MINUS Expr .)
    THEN            reduce using rule 72 (Expr -> Expr MINUS Expr .)
    AND             reduce using rule 72 (Expr -> Expr MINUS Expr .)
    OR              reduce using rule 72 (Expr -> Expr MINUS Expr .)
    DO              reduce using rule 72 (Expr -> Expr MINUS Expr .)
    OF              reduce using rule 72 (Expr -> Expr MINUS Expr .)
    RPAREN          reduce using rule 72 (Expr -> Expr MINUS Expr .)
    END             reduce using rule 72 (Expr -> Expr MINUS Expr .)
    SEMICOLON       reduce using rule 72 (Expr -> Expr MINUS Expr .)
    ELSE            reduce using rule 72 (Expr -> Expr MINUS Expr .)
    TO              reduce using rule 72 (Expr -> Expr MINUS Expr .)
    DOWNTO          reduce using rule 72 (Expr -> Expr MINUS Expr .)
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120

  ! TIMES           [ reduce using rule 72 (Expr -> Expr MINUS Expr .) ]
  ! DIVIDE          [ reduce using rule 72 (Expr -> Expr MINUS Expr .) ]
  ! PLUS            [ shift and go to state 117 ]
  ! MINUS           [ shift and go to state 118 ]


state 153

    (73) Expr -> Expr TIMES Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 73 (Expr -> Expr TIMES Expr .)
    LE              reduce using rule 73 (Expr -> Expr TIMES Expr .)
    GT              reduce using rule 73 (Expr -> Expr TIMES Expr .)
    GE              reduce using rule 73 (Expr -> Expr TIMES Expr .)
    EQ              reduce using rule 73 (Expr -> Expr TIMES Expr .)
    NE              reduce using rule 73 (Expr -> Expr TIMES Expr .)
    PLUS            reduce using rule 73 (Expr -> Expr TIMES Expr .)
    MINUS           reduce using rule 73 (Expr -> Expr TIMES Expr .)
    TIMES           reduce using rule 73 (Expr -> Expr TIMES Expr .)
    DIVIDE          reduce using rule 73 (Expr -> Expr TIMES Expr .)
    THEN            reduce using rule 73 (Expr -> Expr TIMES Expr .)
    AND             reduce using rule 73 (Expr -> Expr TIMES Expr .)
    OR              reduce using rule 73 (Expr -> Expr TIMES Expr .)
    DO              reduce using rule 73 (Expr -> Expr TIMES Expr .)
    OF              reduce using rule 73 (Expr -> Expr TIMES Expr .)
    RPAREN          reduce using rule 73 (Expr -> Expr TIMES Expr .)
    END             reduce using rule 73 (Expr -> Expr TIMES Expr .)
    SEMICOLON       reduce using rule 73 (Expr -> Expr TIMES Expr .)
    ELSE            reduce using rule 73 (Expr -> Expr TIMES Expr .)
    TO              reduce using rule 73 (Expr -> Expr TIMES Expr .)
    DOWNTO          reduce using rule 73 (Expr -> Expr TIMES Expr .)

  ! PLUS            [ shift and go to state 117 ]
  ! MINUS           [ shift and go to state 118 ]
  ! TIMES           [ shift and go to state 119 ]
  ! DIVIDE          [ shift and go to state 120 ]


state 154

    (74) Expr -> Expr DIVIDE Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    LT              reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    LE              reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    GT              reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    GE              reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    EQ              reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    NE              reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    PLUS            reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    MINUS           reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    TIMES           reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    DIVIDE          reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    THEN            reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    AND             reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    OR              reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    DO              reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    OF              reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    RPAREN          reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    END             reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    SEMICOLON       reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    ELSE            reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    TO              reduce using rule 74 (Expr -> Expr DIVIDE Expr .)
    DOWNTO          reduce using rule 74 (Expr -> Expr DIVIDE Expr .)

  ! PLUS            [ shift and go to state 117 ]
  ! MINUS           [ shift and go to state 118 ]
  ! TIMES           [ shift and go to state 119 ]
  ! DIVIDE          [ shift and go to state 120 ]


state 155

    (90) BoolExpr -> LPAREN BoolExpr RPAREN .

    THEN            reduce using rule 90 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    AND             reduce using rule 90 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    OR              reduce using rule 90 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    DO              reduce using rule 90 (BoolExpr -> LPAREN BoolExpr RPAREN .)
    RPAREN          reduce using rule 90 (BoolExpr -> LPAREN BoolExpr RPAREN .)


state 156

    (75) Expr -> LPAREN Expr RPAREN .

    LT              reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    LE              reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    GT              reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    GE              reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    EQ              reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    NE              reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    PLUS            reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    MINUS           reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    TIMES           reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    DIVIDE          reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    THEN            reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    AND             reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    OR              reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    DO              reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    OF              reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    RPAREN          reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    END             reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    SEMICOLON       reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    ELSE            reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    TO              reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)
    DOWNTO          reduce using rule 75 (Expr -> LPAREN Expr RPAREN .)


state 157

    (59) open_while_statement -> WHILE BoolExpr DO open_statement .

    END             reduce using rule 59 (open_while_statement -> WHILE BoolExpr DO open_statement .)
    SEMICOLON       reduce using rule 59 (open_while_statement -> WHILE BoolExpr DO open_statement .)


state 158

    (60) closed_while_statement -> WHILE BoolExpr DO closed_statement .

    END             reduce using rule 60 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)
    SEMICOLON       reduce using rule 60 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)
    ELSE            reduce using rule 60 (closed_while_statement -> WHILE BoolExpr DO closed_statement .)


state 159

    (61) open_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO open_statement
    (62) closed_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO closed_statement
    (65) direction -> . TO
    (66) direction -> . DOWNTO

    TO              shift and go to state 174
    DOWNTO          shift and go to state 175

    direction                      shift and go to state 173

state 160

    (63) initial_value -> Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    TO              reduce using rule 63 (initial_value -> Expr .)
    DOWNTO          reduce using rule 63 (initial_value -> Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 161

    (49) case_statement -> CASE case_index OF case_element_list . END
    (50) case_statement -> CASE case_index OF case_element_list . SEMICOLON END
    (52) case_element_list -> case_element_list . SEMICOLON case_element

    END             shift and go to state 176
    SEMICOLON       shift and go to state 177


state 162

    (53) case_element_list -> case_element .

    END             reduce using rule 53 (case_element_list -> case_element .)
    SEMICOLON       reduce using rule 53 (case_element_list -> case_element .)


state 163

    (54) case_element -> case_constant . COLON Statement

    COLON           shift and go to state 178


state 164

    (55) case_constant -> const .

    COLON           reduce using rule 55 (case_constant -> const .)


state 165

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC . OF Type

    OF              shift and go to state 179


state 166

    (12) index_list -> index_list COMMA . index
    (14) index -> . startIndex DOTDOT endIndex
    (20) startIndex -> . const
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    index                          shift and go to state 180
    startIndex                     shift and go to state 135
    const                          shift and go to state 136

state 167

    (14) index -> startIndex DOTDOT . endIndex
    (21) endIndex -> . const
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    endIndex                       shift and go to state 181
    const                          shift and go to state 182

state 168

    (58) closed_if_statement -> IF BoolExpr . THEN closed_statement ELSE closed_statement
    (56) open_if_statement -> IF BoolExpr . THEN Statement
    (57) open_if_statement -> IF BoolExpr . THEN closed_statement ELSE open_statement
    (87) BoolExpr -> BoolExpr . AND BoolExpr
    (88) BoolExpr -> BoolExpr . OR BoolExpr

    THEN            shift and go to state 183
    AND             shift and go to state 109
    OR              shift and go to state 110


state 169

    (57) open_if_statement -> IF BoolExpr THEN closed_statement ELSE . open_statement
    (58) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE . closed_statement
    (30) open_statement -> . label COLON non_labeled_open_statement
    (31) open_statement -> . non_labeled_open_statement
    (32) closed_statement -> . label COLON non_labeled_closed_statement
    (33) closed_statement -> . non_labeled_closed_statement
    (70) label -> . DIGSEQ
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 66
    WHILE           shift and go to state 67
    FOR             shift and go to state 68
    BEGIN           shift and go to state 32
    GOTO            shift and go to state 70
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    ELSE            reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    closed_statement               shift and go to state 184
    open_statement                 shift and go to state 185
    label                          shift and go to state 50
    non_labeled_open_statement     shift and go to state 51
    non_labeled_closed_statement   shift and go to state 52
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    Variable                       shift and go to state 69

state 170

    (32) closed_statement -> label COLON . non_labeled_closed_statement
    (30) open_statement -> label COLON . non_labeled_open_statement
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    BEGIN           shift and go to state 32
    IF              shift and go to state 137
    WHILE           shift and go to state 141
    FOR             shift and go to state 142
    GOTO            shift and go to state 70
    ELSE            reduce using rule 92 (empty -> .)
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    non_labeled_closed_statement   shift and go to state 107
    non_labeled_open_statement     shift and go to state 106
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
    Variable                       shift and go to state 69

state 171

    (60) closed_while_statement -> WHILE BoolExpr . DO closed_statement
    (59) open_while_statement -> WHILE BoolExpr . DO open_statement
    (87) BoolExpr -> BoolExpr . AND BoolExpr
    (88) BoolExpr -> BoolExpr . OR BoolExpr

    DO              shift and go to state 186
    AND             shift and go to state 109
    OR              shift and go to state 110


state 172

    (62) closed_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO closed_statement
    (61) open_for_statement -> FOR Variable . ASSIGNMENT initial_value direction final_value DO open_statement

    ASSIGNMENT      shift and go to state 187


state 173

    (61) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO open_statement
    (62) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO closed_statement
    (64) final_value -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Variable                       shift and go to state 89
    final_value                    shift and go to state 188
    Expr                           shift and go to state 189
    const                          shift and go to state 90

state 174

    (65) direction -> TO .

    LPAREN          reduce using rule 65 (direction -> TO .)
    MINUS           reduce using rule 65 (direction -> TO .)
    ID              reduce using rule 65 (direction -> TO .)
    INT_NUMBER      reduce using rule 65 (direction -> TO .)
    REAL_NUMBER     reduce using rule 65 (direction -> TO .)


state 175

    (66) direction -> DOWNTO .

    LPAREN          reduce using rule 66 (direction -> DOWNTO .)
    MINUS           reduce using rule 66 (direction -> DOWNTO .)
    ID              reduce using rule 66 (direction -> DOWNTO .)
    INT_NUMBER      reduce using rule 66 (direction -> DOWNTO .)
    REAL_NUMBER     reduce using rule 66 (direction -> DOWNTO .)


state 176

    (49) case_statement -> CASE case_index OF case_element_list END .

    END             reduce using rule 49 (case_statement -> CASE case_index OF case_element_list END .)
    SEMICOLON       reduce using rule 49 (case_statement -> CASE case_index OF case_element_list END .)
    ELSE            reduce using rule 49 (case_statement -> CASE case_index OF case_element_list END .)


state 177

    (50) case_statement -> CASE case_index OF case_element_list SEMICOLON . END
    (52) case_element_list -> case_element_list SEMICOLON . case_element
    (54) case_element -> . case_constant COLON Statement
    (55) case_constant -> . const
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    END             shift and go to state 190
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    case_element                   shift and go to state 191
    case_constant                  shift and go to state 163
    const                          shift and go to state 164

state 178

    (54) case_element -> case_constant COLON . Statement
    (28) Statement -> . open_statement
    (29) Statement -> . closed_statement
    (30) open_statement -> . label COLON non_labeled_open_statement
    (31) open_statement -> . non_labeled_open_statement
    (32) closed_statement -> . label COLON non_labeled_closed_statement
    (33) closed_statement -> . non_labeled_closed_statement
    (70) label -> . DIGSEQ
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 66
    WHILE           shift and go to state 67
    FOR             shift and go to state 68
    BEGIN           shift and go to state 32
    GOTO            shift and go to state 70
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    Statement                      shift and go to state 192
    open_statement                 shift and go to state 48
    closed_statement               shift and go to state 49
    label                          shift and go to state 50
    non_labeled_open_statement     shift and go to state 51
    non_labeled_closed_statement   shift and go to state 52
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    Variable                       shift and go to state 69

state 179

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF . Type
    (15) Type -> . INTEGER
    (16) Type -> . REAL
    (17) Type -> . BOOLEAN
    (18) Type -> . arrayName
    (11) arrayName -> . ID

    INTEGER         shift and go to state 40
    REAL            shift and go to state 41
    BOOLEAN         shift and go to state 42
    ID              shift and go to state 30

    arrayName                      shift and go to state 43
    Type                           shift and go to state 193

state 180

    (12) index_list -> index_list COMMA index .

    RBRAC           reduce using rule 12 (index_list -> index_list COMMA index .)
    COMMA           reduce using rule 12 (index_list -> index_list COMMA index .)


state 181

    (14) index -> startIndex DOTDOT endIndex .

    RBRAC           reduce using rule 14 (index -> startIndex DOTDOT endIndex .)
    COMMA           reduce using rule 14 (index -> startIndex DOTDOT endIndex .)


state 182

    (21) endIndex -> const .

    RBRAC           reduce using rule 21 (endIndex -> const .)
    COMMA           reduce using rule 21 (endIndex -> const .)


state 183

    (58) closed_if_statement -> IF BoolExpr THEN . closed_statement ELSE closed_statement
    (56) open_if_statement -> IF BoolExpr THEN . Statement
    (57) open_if_statement -> IF BoolExpr THEN . closed_statement ELSE open_statement
    (32) closed_statement -> . label COLON non_labeled_closed_statement
    (33) closed_statement -> . non_labeled_closed_statement
    (28) Statement -> . open_statement
    (29) Statement -> . closed_statement
    (70) label -> . DIGSEQ
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (30) open_statement -> . label COLON non_labeled_open_statement
    (31) open_statement -> . non_labeled_open_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (19) Variable -> . ID
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement

    DIGSEQ          shift and go to state 25
    BEGIN           shift and go to state 32
    IF              shift and go to state 137
    WHILE           shift and go to state 141
    FOR             shift and go to state 142
    GOTO            shift and go to state 70
    ELSE            reduce using rule 92 (empty -> .)
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    closed_statement               shift and go to state 194
    Statement                      shift and go to state 138
    open_statement                 shift and go to state 48
    label                          shift and go to state 140
    non_labeled_closed_statement   shift and go to state 52
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    non_labeled_open_statement     shift and go to state 51
    Variable                       shift and go to state 69
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55

state 184

    (58) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .

    END             reduce using rule 58 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)
    SEMICOLON       reduce using rule 58 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)
    ELSE            reduce using rule 58 (closed_if_statement -> IF BoolExpr THEN closed_statement ELSE closed_statement .)


state 185

    (57) open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .

    END             reduce using rule 57 (open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .)
    SEMICOLON       reduce using rule 57 (open_if_statement -> IF BoolExpr THEN closed_statement ELSE open_statement .)


state 186

    (60) closed_while_statement -> WHILE BoolExpr DO . closed_statement
    (59) open_while_statement -> WHILE BoolExpr DO . open_statement
    (32) closed_statement -> . label COLON non_labeled_closed_statement
    (33) closed_statement -> . non_labeled_closed_statement
    (30) open_statement -> . label COLON non_labeled_open_statement
    (31) open_statement -> . non_labeled_open_statement
    (70) label -> . DIGSEQ
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    BEGIN           shift and go to state 32
    IF              shift and go to state 137
    WHILE           shift and go to state 141
    FOR             shift and go to state 142
    GOTO            shift and go to state 70
    ELSE            reduce using rule 92 (empty -> .)
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    closed_statement               shift and go to state 158
    open_statement                 shift and go to state 157
    label                          shift and go to state 140
    non_labeled_closed_statement   shift and go to state 52
    non_labeled_open_statement     shift and go to state 51
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
    Variable                       shift and go to state 69

state 187

    (62) closed_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO closed_statement
    (61) open_for_statement -> FOR Variable ASSIGNMENT . initial_value direction final_value DO open_statement
    (63) initial_value -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Variable                       shift and go to state 89
    initial_value                  shift and go to state 195
    Expr                           shift and go to state 160
    const                          shift and go to state 90

state 188

    (61) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO open_statement
    (62) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO closed_statement

    DO              shift and go to state 196


state 189

    (64) final_value -> Expr .
    (71) Expr -> Expr . PLUS Expr
    (72) Expr -> Expr . MINUS Expr
    (73) Expr -> Expr . TIMES Expr
    (74) Expr -> Expr . DIVIDE Expr

    DO              reduce using rule 64 (final_value -> Expr .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120


state 190

    (50) case_statement -> CASE case_index OF case_element_list SEMICOLON END .

    END             reduce using rule 50 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)
    SEMICOLON       reduce using rule 50 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)
    ELSE            reduce using rule 50 (case_statement -> CASE case_index OF case_element_list SEMICOLON END .)


state 191

    (52) case_element_list -> case_element_list SEMICOLON case_element .

    END             reduce using rule 52 (case_element_list -> case_element_list SEMICOLON case_element .)
    SEMICOLON       reduce using rule 52 (case_element_list -> case_element_list SEMICOLON case_element .)


state 192

    (54) case_element -> case_constant COLON Statement .

    END             reduce using rule 54 (case_element -> case_constant COLON Statement .)
    SEMICOLON       reduce using rule 54 (case_element -> case_constant COLON Statement .)


state 193

    (10) ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type .

    SEMICOLON       reduce using rule 10 (ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type .)
    RPAREN          reduce using rule 10 (ArrayDefState -> TYPE arrayName EQ ARRAY LBRAC index_list RBRAC OF Type .)


state 194

    (58) closed_if_statement -> IF BoolExpr THEN closed_statement . ELSE closed_statement
    (57) open_if_statement -> IF BoolExpr THEN closed_statement . ELSE open_statement
    (29) Statement -> closed_statement .

    ELSE            shift and go to state 197
    END             reduce using rule 29 (Statement -> closed_statement .)
    SEMICOLON       reduce using rule 29 (Statement -> closed_statement .)


state 195

    (62) closed_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO closed_statement
    (61) open_for_statement -> FOR Variable ASSIGNMENT initial_value . direction final_value DO open_statement
    (65) direction -> . TO
    (66) direction -> . DOWNTO

    TO              shift and go to state 174
    DOWNTO          shift and go to state 175

    direction                      shift and go to state 198

state 196

    (61) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . open_statement
    (62) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . closed_statement
    (30) open_statement -> . label COLON non_labeled_open_statement
    (31) open_statement -> . non_labeled_open_statement
    (32) closed_statement -> . label COLON non_labeled_closed_statement
    (33) closed_statement -> . non_labeled_closed_statement
    (70) label -> . DIGSEQ
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    IF              shift and go to state 66
    WHILE           shift and go to state 67
    FOR             shift and go to state 68
    BEGIN           shift and go to state 32
    GOTO            shift and go to state 70
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    ELSE            reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    Variable                       shift and go to state 69
    open_statement                 shift and go to state 199
    closed_statement               shift and go to state 200
    label                          shift and go to state 50
    non_labeled_open_statement     shift and go to state 51
    non_labeled_closed_statement   shift and go to state 52
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65

state 197

    (58) closed_if_statement -> IF BoolExpr THEN closed_statement ELSE . closed_statement
    (57) open_if_statement -> IF BoolExpr THEN closed_statement ELSE . open_statement
    (32) closed_statement -> . label COLON non_labeled_closed_statement
    (33) closed_statement -> . non_labeled_closed_statement
    (30) open_statement -> . label COLON non_labeled_open_statement
    (31) open_statement -> . non_labeled_open_statement
    (70) label -> . DIGSEQ
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    BEGIN           shift and go to state 32
    IF              shift and go to state 137
    WHILE           shift and go to state 141
    FOR             shift and go to state 142
    GOTO            shift and go to state 70
    ELSE            reduce using rule 92 (empty -> .)
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    closed_statement               shift and go to state 184
    open_statement                 shift and go to state 185
    label                          shift and go to state 140
    non_labeled_closed_statement   shift and go to state 52
    non_labeled_open_statement     shift and go to state 51
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
    Variable                       shift and go to state 69

state 198

    (62) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO closed_statement
    (61) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction . final_value DO open_statement
    (64) final_value -> . Expr
    (71) Expr -> . Expr PLUS Expr
    (72) Expr -> . Expr MINUS Expr
    (73) Expr -> . Expr TIMES Expr
    (74) Expr -> . Expr DIVIDE Expr
    (75) Expr -> . LPAREN Expr RPAREN
    (76) Expr -> . MINUS Expr
    (77) Expr -> . Variable
    (78) Expr -> . const
    (19) Variable -> . ID
    (79) const -> . INT_NUMBER
    (80) const -> . REAL_NUMBER

    LPAREN          shift and go to state 99
    MINUS           shift and go to state 88
    ID              shift and go to state 18
    INT_NUMBER      shift and go to state 91
    REAL_NUMBER     shift and go to state 92

    Variable                       shift and go to state 89
    final_value                    shift and go to state 201
    Expr                           shift and go to state 189
    const                          shift and go to state 90

state 199

    (61) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .

    END             reduce using rule 61 (open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .)
    SEMICOLON       reduce using rule 61 (open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement .)


state 200

    (62) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .

    END             reduce using rule 62 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)
    SEMICOLON       reduce using rule 62 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)
    ELSE            reduce using rule 62 (closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement .)


state 201

    (62) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO closed_statement
    (61) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value . DO open_statement

    DO              shift and go to state 202


state 202

    (62) closed_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . closed_statement
    (61) open_for_statement -> FOR Variable ASSIGNMENT initial_value direction final_value DO . open_statement
    (32) closed_statement -> . label COLON non_labeled_closed_statement
    (33) closed_statement -> . non_labeled_closed_statement
    (30) open_statement -> . label COLON non_labeled_open_statement
    (31) open_statement -> . non_labeled_open_statement
    (70) label -> . DIGSEQ
    (37) non_labeled_closed_statement -> . assignment_statement
    (38) non_labeled_closed_statement -> . compound_statement
    (39) non_labeled_closed_statement -> . closed_if_statement
    (40) non_labeled_closed_statement -> . closed_while_statement
    (41) non_labeled_closed_statement -> . closed_for_statement
    (42) non_labeled_closed_statement -> . goto_statement
    (43) non_labeled_closed_statement -> . empty
    (44) non_labeled_closed_statement -> . case_statement
    (45) non_labeled_closed_statement -> . continue_statement
    (47) non_labeled_closed_statement -> . break_statement
    (34) non_labeled_open_statement -> . open_if_statement
    (35) non_labeled_open_statement -> . open_while_statement
    (36) non_labeled_open_statement -> . open_for_statement
    (67) assignment_statement -> . Variable ASSIGNMENT Expr
    (68) compound_statement -> . BEGIN StateList END
    (58) closed_if_statement -> . IF BoolExpr THEN closed_statement ELSE closed_statement
    (60) closed_while_statement -> . WHILE BoolExpr DO closed_statement
    (62) closed_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO closed_statement
    (69) goto_statement -> . GOTO label
    (92) empty -> .
    (49) case_statement -> . CASE case_index OF case_element_list END
    (50) case_statement -> . CASE case_index OF case_element_list SEMICOLON END
    (46) continue_statement -> . CONTINUE
    (48) break_statement -> . BREAK
    (56) open_if_statement -> . IF BoolExpr THEN Statement
    (57) open_if_statement -> . IF BoolExpr THEN closed_statement ELSE open_statement
    (59) open_while_statement -> . WHILE BoolExpr DO open_statement
    (61) open_for_statement -> . FOR Variable ASSIGNMENT initial_value direction final_value DO open_statement
    (19) Variable -> . ID

    DIGSEQ          shift and go to state 25
    BEGIN           shift and go to state 32
    IF              shift and go to state 137
    WHILE           shift and go to state 141
    FOR             shift and go to state 142
    GOTO            shift and go to state 70
    ELSE            reduce using rule 92 (empty -> .)
    END             reduce using rule 92 (empty -> .)
    SEMICOLON       reduce using rule 92 (empty -> .)
    CASE            shift and go to state 71
    CONTINUE        shift and go to state 72
    BREAK           shift and go to state 73
    ID              shift and go to state 18

    Variable                       shift and go to state 69
    closed_statement               shift and go to state 200
    open_statement                 shift and go to state 199
    label                          shift and go to state 140
    non_labeled_closed_statement   shift and go to state 52
    non_labeled_open_statement     shift and go to state 51
    assignment_statement           shift and go to state 56
    compound_statement             shift and go to state 57
    closed_if_statement            shift and go to state 58
    closed_while_statement         shift and go to state 59
    closed_for_statement           shift and go to state 60
    goto_statement                 shift and go to state 61
    empty                          shift and go to state 62
    case_statement                 shift and go to state 63
    continue_statement             shift and go to state 64
    break_statement                shift and go to state 65
    open_if_statement              shift and go to state 53
    open_while_statement           shift and go to state 54
    open_for_statement             shift and go to state 55
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 121 resolved as shift
WARNING: shift/reduce conflict for OR in state 121 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 123 resolved as shift
WARNING: shift/reduce conflict for AND in state 143 resolved as shift
WARNING: shift/reduce conflict for OR in state 143 resolved as shift
WARNING: shift/reduce conflict for AND in state 144 resolved as shift
WARNING: shift/reduce conflict for OR in state 144 resolved as shift
